<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Junhui&#39;s Journal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Junhui&#39;s Journal">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Junhui&#39;s Journal">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Junhui">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Junhui&#39;s Journal" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junhui&#39;s Journal</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-LeetCode-方法论-map-set-二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/24/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-map-set-%E4%BA%8C/" class="article-date">
  <time datetime="2019-12-24T12:54:50.000Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/24/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-map-set-%E4%BA%8C/">LeetCode-方法论-map&amp;set-二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>454, </p>
<h1 id="454-4Sum-II"><a href="#454-4Sum-II" class="headerlink" title="#454 4Sum II"></a>#454 4Sum II</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">A &#x3D; [ 1, 2]</span><br><span class="line">B &#x3D; [-2,-1]</span><br><span class="line">C &#x3D; [-1, 2]</span><br><span class="line">D &#x3D; [ 0, 2]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The two tuples are:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑</p>
<pre><code>第一步：将A和B中元素的可能和作为key放入map1，value为这个和出现的频数。
第二步：将C和D中元素的可能和作为key放入map2，value为这个和出现的频数。
第三步：对于map1中的每个元素，在map2中查找这个元素对应的负数，如果找到，则结果中加上(这个元素的频数)×(map2中这个元素负数的频数)  DONE。</code></pre></li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a:A)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b:B)</span><br><span class="line">            mp1[a+b]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c: C)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d: D)</span><br><span class="line">            mp2[c+d]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第三步</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; itr : mp1)&#123;</span><br><span class="line">        <span class="keyword">if</span> (mp2.find(-(itr.first)) != mp2.end())</span><br><span class="line">            res += (itr.second) * (mp2[-(itr.first)]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="green" size="5">敲黑板</font>理清楚逻辑后再实现。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/24/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-map-set-%E4%BA%8C/" data-id="ck5bbuogq001va2fz2lgnc82c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大话-线性代数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/20/%E5%A4%A7%E8%AF%9D-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="article-date">
  <time datetime="2019-12-20T09:36:38.000Z" itemprop="datePublished">2019-12-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linear-Algebra/">Linear Algebra</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/20/%E5%A4%A7%E8%AF%9D-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">大话-线性代数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>把线性代数(LA)中每个概念理解清楚，并且理清概念间的来龙去脉。<br>几乎所有的LA内容都是围绕下面这组等价命题展开的:</p>
<pre><code>对于方阵A(n*n)： 
    1.A可逆(A是非奇异阵)
    2.&lt;=&gt; 线性系统 Ax=0 有唯一解，零解
    3.&lt;=&gt; 线性系统 Ax=b 有唯一解
    4.&lt;=&gt; A的最简化行阶梯矩阵 rref(A)=I 是单位矩阵
    5.&lt;=&gt; A可以表示称一系列初等矩阵的乘积
    6.&lt;=&gt; A的列向量线性无关
    7.&lt;=&gt; A的列向量可以生成n维空间
    8.&lt;=&gt; A的列向量是n维空间的基
    9.&lt;=&gt; A的行秩==A的列秩==n
    10.&lt;=&gt; A满秩(r==n)
    11.&lt;=&gt; A的行空间维度==A的列空间维度==n
    12.&lt;=&gt; A的行向量线性无关
    13.&lt;=&gt; A的行列式 det(A)!=0
    14.&lt;=&gt; 0不是A的特征值</code></pre><p>因为真实世界通常是多维度的，单个数已经不足以来描述真实世界。线性代数研究的就是一组数，也就是向量。</p>
<blockquote>
<p>向量</p>
</blockquote>
<p>向量是一组有序的数，表示方向，如物理世界中。又可以表示多维世界。有序说明了(a, b)和(b, a)是两个不同的向量。</p>
<p>向量有其基本的运算：</p>
<pre><code>1.向量加法
2.数量乘法</code></pre><p>由这两个基本操作想到了向量空间。</p>
<blockquote>
<p>向量空间</p>
</blockquote>
<p>空间是一个集合，我们经常说的2D，3D空间，实际上是欧几里得空间。现在知道，欧几里得空间是点集，又是起点为（0,0）的向量集合。此处所讨论的向量空间默认指的是欧几里得向量空间。</p>
<p>向量空间是个集合，其中的元素必须定义两个基本运算：</p>
<pre><code>1.向量加法
2.数量乘法</code></pre><p>这两个基本运算又必须满足十条性质。(这是向量空间的定义)                                                                </p>
<p>这两个运算十分重要，因为这使得向量成为向量。</p>
<p>之所以把向量默认为欧几里得空间的向量，是因为现实世界中，欧几里得空间是最常见的。</p>
<p>把不是欧几里得空间的其他空间称为“广义线性空间”。比如，所有的2*2的方阵构成一个向量空间，其中定义向两加法为矩阵加法，定义数量乘法为矩阵的数量乘法。可以证明这个空间中的2*2方阵满足十条性质。</p>
<p>有了空间，就有子空间。</p>
<blockquote>
<p>子空间</p>
</blockquote>
<p>啥是子空间：如果V是一个向量空间，S是V的子集，而且S也是一个向量空间(或者说，S对加法和数量乘法封闭)，那么称S是V的一个子空间。</p>
<p>比如，2维欧几里得空间是一个向量空间V，现在有一条过（0,0）的直线，所有这条直线上的向量构成V的一个子空间S。可以证明S对加法和数量乘法封闭。</p>
<p>而假如现在由一条不过（0,0）的直线，所有在这条直线的向量空间不是V的子空间。可以证明，这个空间对加法和数量乘法不封闭。</p>
<p>补充一点，之所以（0,0）点是个关键，是因为欧几里得空间的向量起点一定要是（0,0）。</p>
<p>上述例子进一步说，S空间是过（0,0）的一条直线。那么任何这条只直线上的非零向量v都可表示空间S中的其他任何向量，也就是说v可以生成S中的所有向量。那么这个非零向量v就是这个子空间中的一组基，子空间的维度为1。</p>
<p>有一点需要注意，如果一个欧几里得空间中每个实数元素组包含n个元素，这个空间维度一定是n吗？错！正如上述，过原点的一条直线是二维欧几里得空间的一个子空间，这个子空间中每个元素含有x，y两个元素，但是这个子空间的维度是1，非2。</p>
<p>那么什么是空间的一组基呢？</p>
<blockquote>
<p>空间的基</p>
</blockquote>
<p>先看两个命题：</p>
<pre><code>命题1：如果m个向量生成n维空间，则m最小为n。
命题2：如果m个n维向量线性无关，则m最大为n。</code></pre><p>由上述两个命题，可以得到空间基的定义：<br>若一组向量可以生成整个n维空间，且线性无关，则这组向量一定有n个。这样一组向量是n维空间的的一组基。</p>
<p>基的作用是啥：在n维空间中，如果给定一组基，任何一个向量(或点)都可以表示成这组基的线性组合。而且表示方法唯一。</p>
<p>比如2维欧几里得空间中由无数组基，其中最常使用的是标准正交基：(e1，e2)。e1与e2正交，就是垂直，且模为1。</p>
<p>实际上，我们常说的一个向量，如(12,8)，默认是使用二维欧几里得空间的基来表示的，也就是说，(12,8)左边是默认左乘(e1, e2)=((1,0)T,(0,1)T)。这个乘法表示的含义是，在(1,0)T这个方向上移动12个单位，在(0,1)T这个方向上移动8个单位，后得到的点或坐标(12,8)。</p>
<p>同样这个点也可以使用其他的基来表示。如(u,v)=((4,1)T,(2,3)T)。在这个基中，(12,8)用(2,2)来表示，就是说，在方向(4,1)T上移动2个单位，在(2,3)T方向上移动2个单位，就移动到了(12,8)。所以在(u,v)这组基下(2,2)来表示同一个点。</p>
<p>由上述，可以理解：矩阵A的列向量线性无关+矩阵A可以生成n维空间=&gt;A是方阵且A的列向量是n为空间的基。也就是等假命题6，7，8。</p>
<p>只是用标准正交基不行吗，为什么还要由其他基。因为对于特定的问题，把问题放到其他基会更容易解决问题。</p>
<p>知道了什么是空间的基，那什么是空间的维度呢？</p>
<blockquote>
<p>空间的维度</p>
</blockquote>
<p>空间维度的定义是：一个空间的基中，向量的个数，称为空间的维度。</p>
<p>如二维欧几里得空间的基(e1,e2)这个基中由两个向量，所以dim()=2。</p>
<p>回看空间基的两个命题，什么叫线性无关? 什么又是“生成n维空间”?</p>
<blockquote>
<p>线性无关</p>
</blockquote>
<p>定义：对于p个n维向量，存在一组k（p个）全为零时才有，v与对应k相乘后相加的结果为0。则称p个v线性无关。</p>
<p>也就是说，任何一个v都是独立存在的，不能由其他向量的线性组合来代替。</p>
<p>反过来，如果一组向量线性相关，那么表示其中有一个向量可以由其他向量线性表示，这个向量对应的k为0。也就是说，被线性表示的向量不能增加系统的信息量，系统有信息冗余。</p>
<p>把上述“v与对应k相乘后相加”称作v的线性组合。</p>
<blockquote>
<p>线性组合</p>
</blockquote>
<p>就是向量相乘后相加，体现了向量的两种最基本运算：向量相加，数量乘法。</p>
<p>从矩阵的列视角来看，矩阵与向量的乘法也是个线性组合，是矩阵列向量的线性组合。其中的v以列向量的形式构成矩阵，所有的k构成向量。</p>
<p>另一个例子，Guass-Jordan 消元法，结果的每一行，是原来矩阵各行的一个线性组合。注意，消元法的结果描述的是原矩阵列向量的关系。</p>
<blockquote>
<p>生成空间</p>
</blockquote>
<p>假如有两个线性无关的二维向量(u,v)，在二维欧几里得空间中的任何一个向量都可以表示成u，v的线性组合，则称u，v可以生成整个二维空间。</p>
<p>可以拓展到n维空间。</p>
<p>但是既然u，v可以生成整个二维空间，那么再增加任意一个向量w，这三个向量u，v，w也能生成整个二维空间。只需要w前的系数为0。问题来了，至少需要多少个向量才能生成整个二维空间呢?结论是：对于n维空间，至少需要n个向量才能生成。用反证法，把问题转化齐次线性方程组解的问题。</p>
<blockquote>
<p>看待矩阵的4大视角</p>
</blockquote>
<p>视角：</p>
<pre><code>空间视角：列向量  (坐标系或空间)
系统视角：线性方程组
函数视角：行向量 （与线性变换相关）
数据视角：记录与特征</code></pre><blockquote>
<p>线性系统</p>
</blockquote>
<p>啥是线性？所有未知数是一次的。</p>
<p>线性系统就是多个一次方程联立。线性系统中存在一个矩阵叫做增广矩阵。对这个矩阵的操作使用Guass-Jordan消元，返回一个阶梯矩阵。使用这个操作来判断这个线性方程组解的结构。解的结构本质上是经过消元后，方程组的个数与未知数个数的关系。</p>
<p>线性系统中，当等号右边全为零时，叫做其次方程组。</p>
<p>许多LA相关问题都可以经由线性系统的视角，证明线性方程组的解，来证明。</p>
<p>比如：方阵的逆与线性相关的关系。如何判断线性相关否，根据定义来：这几个向量的线性组合（等号右边为0）是否只有零解，若只有零解，表示定义中的k全为零，全为零啥意思，就是所有k对应的所有向量线性无关（线性无关的定义）。 如果方阵A可逆，那么Ax=0 &lt;=&gt; A的逆*A = A的逆*0，即I*x=0（0矩阵）,所以x=0。</p>
<p>也就是说，方阵A可逆，则A的列向量线性无关。</p>
<blockquote>
<p>线性变换</p>
</blockquote>
<p>变换是一个函数，一个线性变换T(x)必须满足两个条件：</p>
<p><code>T(u+v)=T(u)+T(v)</code><br><code>T(C*u)=C*T(u)</code>, C属于1D欧几里得空间</p>
<p>看，又是<font color="gree" size="3">加法</font>和<font color="gree" size="3">数量乘法</font>。<br>一个线性变换对应一个矩阵。而且所有矩阵都对应一个线性变换。</p>
<p>从几何角度理解特征值特征向量时，因为只给出了一个<font color="gree" size="3">变换</font>，所以首先那需要判断这个变换是否是一个<font color="gree" size="3">线性变换</font>，若果是，那么就对应一个矩阵。有了矩阵，才能根据定义找到特征值和特征向量。</p>
<blockquote>
<p>基与坐标系</p>
</blockquote>
<blockquote>
<p>行空间</p>
</blockquote>
<blockquote>
<p>列空间</p>
</blockquote>
<blockquote>
<p>方阵的秩</p>
</blockquote>
<blockquote>
<p>标准正交基</p>
</blockquote>
<blockquote>
<p>方阵的行列式</p>
</blockquote>
<p>行列式只是方阵的一个属性，对于非方阵是没有行列式这一说的(暂时)。方阵A的行列式用<code>det(A)</code> 表示。对于二维欧几里得空间，它由无数个基，怎样来区分彼此呢？可以使用基构成的<font color="gree" size="3">面积</font>的大小来区分。对于3D欧几里得空间，就是体积了。</p>
<p>所以行列式的几何意义就明确了。由于行列式有正负之分的，所以更确切的说，行列式的几何意义是有向面积或有向体积。</p>
<p>行列式其实是用于研究特征值和特征矩阵的。</p>
<p>行列式的计算在大学是着重练习的，但其实计算不是重点。这里由个通用的计算行列式的方法：</p>
<pre><code>进行Guass消元，
过程中不做归一化，
行置换列置换操作，每一次置换操作，符号改变一次没所以要记录置换了多少次，
最终化为上三角矩阵，即对角线以下为0。</code></pre><p>堆中行列式的结果，就是对角向上元素累乘。</p>
<p>补充一点，啥是<code>初等矩阵</code>：对单位矩阵进行初等行操作得到的矩阵。</p>
<p>还有一部分内容是关于<code>行列式的代数表达</code>，涉及到余子式，代数余子式，伴随矩阵，Cramer法则等。代数表达在数学上很优美，但是咋实际计算行列式值时，很低效。行列式中重要的是其性质，之后的LA高阶内容都会用到行列式性质。</p>
<blockquote>
<p>特征值特征向量</p>
</blockquote>
<p>这又是方阵的另外两个属性。是把方阵作为基，从<font color="gree" size="3">变换</font>的角度看的。这个变换拥有一些特征，这些特征被特征向量特征值描述。</p>
<p>一个向量在基<code>A</code>中的表达是<code>u</code>，在标准正交基<code>E</code>中的表达是<code>v</code>，如果变换满足<code>A*u=lambda*E*v</code>，而<code>E*v=u</code>，给出一个向量，默认都是用<code>E</code>基表达。<code>lambda</code>为标量。</p>
<p>也就是<code>A*u=lambda*u</code>，也就是说，<code>u</code>和<code>v</code> <font color="gree" size="3">同方向</font>。<code>lambda</code>称作方阵<code>A</code>的特征值，<code>u</code>为<code>A</code>对于<code>lambda</code>的特征向量。</p>
<ul>
<li><p>如何求一个方阵的特征值和特征向量？</p>
<p>  对于<code>A*u=lambda*u</code>.</p>
<ul>
<li><p>当<code>u</code>为零向量时，不论A是啥，等号都成立，所以<code>u=0</code>是平凡解。也就是说，<code>u=0</code><font color="gree" size="3">不是</font>任何方阵的特征向量。不能表达A的特性。</p>
</li>
<li><p>当<code>lambda=0</code>时，不是平凡解。<code>lambda=0</code>，即<code>A*u=0</code>。是齐次线性方程组。上一条说过了，<code>u</code>不能为0向量。也就是说，<code>A*u=0</code>有非零解。<br>回忆：[若A可逆，A*u=0只有零解]，现在条件是，u是其非零解，即A不可逆。<br>总结：若<code>lambda=0</code>是<code>A</code>的特征值， 那么<code>A</code>不可逆。即不可逆方阵的一个特征值可以是0.</p>
<p>接着求，<code>A*u=lambda*E*v</code> =&gt; <code>A*u - I*lambda*u = 0</code> =&gt; <code>(A-lambda*I)*u=0</code> 我希望这个表达式有非零解。</p>
<p>若有非零解，则<code>(A-lambda*I)</code> 不可逆，就是说<code>det(A-lambda*I)=0</code>. （看到了把，行列式在此出现）。</p>
<p>根据<code>det(A-lambda*I)=0</code>可以求出A的若干特征值<code>lambda</code>，进一步，把<code>lambda</code>带入<code>A*u=lambda*u</code>便可以求得这个lambda对应的特征向量组。</p>
</li>
</ul>
</li>
</ul>
<pre><code>理解的重点：

* A的特征向量不可能是0向量，
* 同一个向量在不同的基中的表示同方向或逆方向，
* 特征值特征向量与变换有关。</code></pre><ul>
<li><p>特征值与特征向量的一些性质：</p>
<ul>
<li>如果u值A对应于lambda的一个特征向量，则k*u也是lambda的一个特征向量。</li>
<li>如果A的一个lambda=0，则A不可逆。</li>
<li>对角矩阵，上三角矩阵，下三角矩阵的特征值，就是主对角线上元素的值。</li>
<li>如果lambda是A是特征值，则lambda^m 是A^m的特值。</li>
<li>如果lambda是A的特征值，则1/lambda是A的逆的特征值。</li>
</ul>
</li>
<li><p>从几何角度理解特征值和特征向量</p>
<p>  几何中，一个变换，比如投影变换：2D中将任意向量投影到向量(2,3)所在的直线。不一定对应一个矩阵。所以要先判断这个变换是一个线性变换。根据线性变换的内容：满足下面两个条件才是线性变换：<br>  <code>T(u+v)=T(u)+T(v)</code><br>  <code>T(C*u)=C*T(u)</code>, C属于1D欧几里得空间<br>  显然投影变换满足上述条件，所以可以得到矩阵A。不过我们不求矩阵A，也可以从几何角度的到这个变换的特征值特征向量。</p>
<p>  投影变换的特征值是什么呢？因为从定义看，特征向量经过变换后与变换前同方向。所以秩序在投影变换图中找那些向量满足变换前后同方向。</p>
<p>  显然对于过(0,0)和(2,3)两点的直线l，其上向量俊满足上述条件。对于特征值，英文l上的 向量投影到自身，还是自身，所以lambda=1。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/20/%E5%A4%A7%E8%AF%9D-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" data-id="ck5c9ovpr0003r4fzdhda86ad" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-方法论-数组相关-三" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/20/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%89/" class="article-date">
  <time datetime="2019-12-20T09:17:12.000Z" itemprop="datePublished">2019-12-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/20/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%89/">LeetCode-方法论-数组相关-三</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接着记录leetcode问题：<br>1002, 4, 215, 88, 674, 950</p>
<p>提炼技术：</p>
<ul>
<li>记录字符频数</li>
<li>实时更新</li>
<li>额外变量</li>
<li>逻辑中由插入操作，考虑使用<font color="red" size="4">队列</font></li>
</ul>
<h1 id="1002"><a href="#1002" class="headerlink" title="#1002"></a>#1002</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">找到单词的共有字符：</span><br><span class="line">Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>  假设输入单词的列表是：[‘bcdc’, ‘dcc’, ‘cddcb’]<br>  过程如下：</p>
<pre><code>loop：对于每一个单词记录其中字母出现的频数count，根据这个count，更新count26。
        当所有单词统计过后，count26就包含了最终每个单词共有的字符出现的频数。
最后一步：将count26中频数大于0的字母放入res数组。</code></pre><p>  其中，count26把元素初始化为可能的最大值；而且是个全局变量，对于每个单词都实时更新其值，节省了空间。</p>
  <div align="center"><img src="/2019/12/20/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%89/1002.png" width="650"></div>

<p>  最终返回两个c一个d：[‘c’,’c’,’d’]。</p>
</li>
<li><p>看图说话</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; commonChars(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count26(<span class="number">26</span>, INT_MAX);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word: A)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计每个单词中每个字母出现的频数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> chara: word)&#123;</span><br><span class="line">            count[chara - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每一个单词统计频数后更新count26</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">            count26[i] = min(count26[i], count[i]);  <span class="comment">// online update</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终的count26中记录了每个字母出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;count26[i]; j++)</span><br><span class="line">            res.push_back(<span class="built_in">string</span>(<span class="number">1</span>, i+<span class="string">'a'</span>));  <span class="comment">// 索引0对应‘a’</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关键：<font color="red" size="4">记录字符频数</font>，<font color="red" size="4">实时更新</font>，</p>
<h1 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="#4 Median of Two Sorted Arrays"></a>#4 Median of Two Sorted Arrays</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">There are two sorted arrays nums1 and nums2 of size m and n respectively.</span><br><span class="line">Find the median of the two sorted arrays.</span><br><span class="line"></span><br><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line">The median is (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>思路</p>
<p>  思路直接：第一步：merge两个有序数组，第二步：找到median。</p>
</li>
</ul>
<ul>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">    <span class="keyword">int</span> n = nums2.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// aux 数组记录merge后的数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; aux(n+m ,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge two sorted arrays</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt; m+n; k++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i&gt;=m)   <span class="comment">// 如果i超过了nums1的长度，表示nums1中元素遍历完毕</span></span><br><span class="line">            aux[k] = nums2[j++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j&gt;=n) <span class="comment">// 如果j超过了nums2 的长度，表示nums2中元素遍历完毕 </span></span><br><span class="line">            aux[k] = nums1[i++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j] &amp;&amp; i&lt;m &amp;&amp; j&lt;n) <span class="comment">// 如果两个数组都没有遍历完毕</span></span><br><span class="line">            aux[k] = nums1[i++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt;= nums2[j] &amp;&amp; i&lt;m &amp;&amp; j&lt;n) <span class="comment">// 如果两个数组都没有遍历完毕</span></span><br><span class="line">            aux[k] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算中间两个数的median</span></span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((m+n)%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        res = <span class="number">0.5</span>*(aux[(m+n)/<span class="number">2</span>] + aux[(m+n)/<span class="number">2</span><span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((m+n)%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        res = (aux[(m+n)/<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关键：merge操作的情况要考虑清楚</p>
<h1 id="215-Kth-largest-element"><a href="#215-Kth-largest-element" class="headerlink" title="#215 Kth largest element"></a>#215 Kth largest element</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k &#x3D; 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑</p>
<p>  当数组中的元素可以使任何整数时：</p>
<pre><code>先排序，后直接取第k个元素</code></pre><p>  当数组中的元素中只含有0~9这10个，可以有其他方法：</p>
<pre><code>使用频数数组记录每个digit出现的次数，根据这个频数与k的关系取到最终值。</code></pre></li>
</ul>
<ul>
<li><p>实现</p>
<ol>
<li><p>第一种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Increase</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargestElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end(), Increase());</span><br><span class="line">    <span class="keyword">return</span> nums[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种情况可以使用如下方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">findKthLargestElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>;  <span class="comment">// 与k比较</span></span><br><span class="line">	<span class="keyword">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 频数记录</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">		count[nums[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">9</span>; i&gt;=<span class="number">0</span>; i--)&#123;    </span><br><span class="line">		<span class="keyword">if</span> (count[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=count[i]; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (res &lt; k) res+=<span class="number">1</span>;  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(res == k) <span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">throw</span> invalid_argument(<span class="string">"no return"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h1 id="88-Merge-Two-Array"><a href="#88-Merge-Two-Array" class="headerlink" title="#88 Merge Two Array"></a>#88 Merge Two Array</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br><span class="line"></span><br><span class="line">NOTE: num1&amp;num2 are sorted</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑</p>
<p>  其实就是实现Merge Sort的一个树结点的操作</p>
</li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; merge2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">//def num1 的index</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;  <span class="comment">//def num2 的index</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="comment">//def  结果array的index</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(m+n);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m || j&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &lt;= nums2[j])</span><br><span class="line">            arr[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            arr[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="674-最长连续递增子序列的长度"><a href="#674-最长连续递增子序列的长度" class="headerlink" title="#674 最长连续递增子序列的长度"></a>#674 最长连续递增子序列的长度</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如：nums&#x3D;[1,3,7,5,6,8,9]</span><br><span class="line"></span><br><span class="line">返回4. 最长递增子序列是[5,6,8,9]</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑</p>
<p>  用变量<code>start</code>标记每个递增子序列的第一个数的索引。<br>  遍历<code>nums</code>数组，只要<code>nums[i]&lt;=nums[i-1]</code>，更新<code>start</code>为当前索引<code>i</code>。<br>  <code>i</code>每次加1，<code>res</code>更新一次：<code>res=max(res, i-start+1)</code>.</p>
</li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;  <span class="comment">// extra variable </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]&lt;=nums[i<span class="number">-1</span>])</span><br><span class="line">            start=i;</span><br><span class="line">        res = max(res, i-start+<span class="number">1</span>); <span class="comment">// update</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键： <font color="red" size="4">额外变量</font>，<font color="red" size="4">实时更新</font>，<font color="red" size="4">先手动实现</font>，</p>
</li>
</ul>
<h1 id="950-Reveal-Cards-In-Increasing-Order"><a href="#950-Reveal-Cards-In-Increasing-Order" class="headerlink" title="#950 Reveal Cards In Increasing Order"></a>#950 Reveal Cards In Increasing Order</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给出一个序列，含若干个元素，任意顺序，现在确定一种顺序S，使得这个顺序的序列执行如下操作的过程中，第一步取出元素为递增顺序。这个操作如下：</span><br><span class="line">    1. 取出序列的第一个元素</span><br><span class="line">    2. 如果此时序列中还有元素，将第一个元素放到序列尾部。</span><br><span class="line">    3. 只要序列中有元素，就执行1,2步骤。 </span><br><span class="line"></span><br><span class="line">返回S。</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">Input: [17,13,11,2,3,5,7]</span><br><span class="line">Output: [2,13,3,11,5,17,7]</span><br><span class="line">Explanation: </span><br><span class="line">We get the deck in the order [17,13,11,2,3,5,7] (this order doesn&#39;t matter), and reorder it.</span><br><span class="line">After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.</span><br><span class="line">We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].</span><br><span class="line">We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].</span><br><span class="line">We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].</span><br><span class="line">We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].</span><br><span class="line">We reveal 11, and move 17 to the bottom.  The deck is now [13,17].</span><br><span class="line">We reveal 13, and move 17 to the bottom.  The deck is now [17].</span><br><span class="line">We reveal 17.</span><br><span class="line">Since all the cards revealed are in increasing order, the answer is correct.</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑</p>
<ol>
<li><p>既然初始序列<code>deck</code>是任意的，所以先排序，从大到小排序得到新<code>deck</code>。</p>
</li>
<li><p>过程中需要插入序列第二个位置，所以考虑使用双端队列为容器<code>dq</code>。把第一个元素放入队列，从第二个元素开始。</p>
<ul>
<li>第一步 将队列的最后元素插入队列的第一个位置。</li>
<li>第二步 将当前序列中的元素<code>deck[i]</code> 插入队列首。</li>
<li>第三步 将此时的队列中最后元素删除。</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; deckRevealedIncreasing(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)&#123;</span><br><span class="line">    sort(deck.begin(), deck.end(), [](<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a&gt;b;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">    dq.push_front(deck[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; deck.size(); i++)&#123;</span><br><span class="line">        dq.insert(dq.begin(), *(dq.end()<span class="number">-1</span>));</span><br><span class="line">        dq.push_front(deck[i]);</span><br><span class="line">        dq.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(dq.begin(), dq.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关键： <font color="red" size="4">已知结果求原因，反推过去</font>，<br>逻辑中由插入操作，考虑使用<font color="red" size="4">队列</font>、<br>双端队列常用方法： <code>push_front()</code>, <code>push_back()</code>, <code>pop_back()</code>, <code>pop_front()</code>, <code>insert()</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/20/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%89/" data-id="ck5bbuohp002wa2fz10q182g8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-方法论-数组相关-二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/19/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%BA%8C/" class="article-date">
  <time datetime="2019-12-19T05:25:32.000Z" itemprop="datePublished">2019-12-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/19/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%BA%8C/">LeetCode-方法论-数组相关-二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接着记录数组相关问题。<br>56, 74, 240, 136, 1122, 1009, 868, 985,  </p>
<p>常用技术：</p>
<ul>
<li>粗调+精调</li>
<li>XOR性质</li>
<li>额外变量的使用</li>
<li>数进制间的对应(相互为等价信息)</li>
<li>移位操作</li>
<li>首先想到的方法不是好的方法</li>
</ul>
<h1 id="56-Merge-intervals-合并区间"><a href="#56-Merge-intervals-合并区间" class="headerlink" title="#56 Merge intervals 合并区间"></a>#56 Merge intervals 合并区间</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<pre><code>第一步：按区间左边界排序
第二步：把第一个interval[0]放入结果容器res中，从第二个interval[1]开始：
    如果interval[1]的左边界 &gt;= res的最后一个interval的右边界，表示两者无交集，
        把interval[1] append到res中；
    如果interval[1]的左边界 &lt; res的最后一个interval的右边界，表示两者有交集，
        把interval[1]的右边界写入res最后一个interval的右边界。</code></pre><p>  第二部过程间下示意图</p>
</li>
</ul>
<pre><code>&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;LeetCode-方法论-数组相关-二/interval.png&quot; width=600&gt;&lt;/div&gt;</code></pre><ul>
<li><p>看图说话实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (intervals.size()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span> (intervals.size()==<span class="number">1</span>)&#123;</span><br><span class="line">        res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区间左端点从小到大排序</span></span><br><span class="line">    sort(intervals.begin(), intervals.end(), compare); </span><br><span class="line"></span><br><span class="line">    res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; intervals.size())&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; last = res.back();  <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (last[<span class="number">1</span>] &lt; intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">            res.push_back(intervals[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            last[<span class="number">1</span>] = max(last[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关键： <code>vector&lt;int&gt;&amp; last = res.back();</code> 定义last 的类型是reference。由逻辑，<font color="red" size="4">凡是last被修改，就是res.back()被修改</font>，所以last和res.back()为一个对象。</p>
<h1 id="64-Search-2D-matrix"><a href="#64-Search-2D-matrix" class="headerlink" title="#64 Search 2D matrix"></a>#64 Search 2D matrix</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix &#x3D; [</span><br><span class="line">[1,   3,  5,  7],</span><br><span class="line">[10, 11, 16, 20],</span><br><span class="line">[23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target &#x3D; 16</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">1.Integers in each row are sorted from left to right.</span><br><span class="line">2.The first integer of each row is greater than the last integer of the previous row.</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路 </p>
<p>  根据问题的特点，设计<code>粗调+精调</code>方法：</p>
<pre><code>粗调：把每一行的最后一个元素放入新的数组中（m长度）: [7, 20, 50].
    用target与其中的每个元素比较，找到第一个比target大的元素并返回index。
    如：20 是第一个大于target的元素，返回1，即target在index=1的行。
精调：在index=1的行中搜索target。</code></pre></li>
</ul>
<ul>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; station(row, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;row; r++)</span><br><span class="line">        station[r] = matrix[r][col<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rough-tuning</span></span><br><span class="line">    <span class="keyword">int</span> pr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;station.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == station[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; station[i])&#123;</span><br><span class="line">            pr = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fine-tuning</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;col; c++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[pr][c] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键： <font color="red" size="4">粗调&amp;精调</font></p>
</li>
</ul>
<h1 id="240-Search-2D-matrix-II"><a href="#240-Search-2D-matrix-II" class="headerlink" title="#240 Search 2D matrix II"></a>#240 Search 2D matrix II</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">[1,   4,  7, 11, 15],</span><br><span class="line">[2,   5,  8, 12, 19],</span><br><span class="line">[3,   6,  9, 16, 22],</span><br><span class="line">[10, 13, 14, 17, 24],</span><br><span class="line">[18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target &#x3D; 5, return true.</span><br><span class="line"></span><br><span class="line">Given target &#x3D; 20, return false.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.Integers in each row are sorted in ascending from left to right.</span><br><span class="line">2.Integers in each column are sorted in ascending from top to bottom.</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路 </p>
<p>  与#74不同，对于方阵，可以使用粗调精调，但是对于非方阵，此法复杂。考虑新的方法，如下图：</p>
  <div align="center"><img src="/2019/12/19/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%BA%8C/matrix.png" width="500"></div>

<p>  从右上角或(左下角开始)，target与所到元素比较：</p>
<pre><code>if (target &gt; matrix[i][j]) i++;    // 向下走
else if (target &lt; matrix[i][j]) j--;    // 向右走
else if（target == matrix[i][j]）return true  // 找到</code></pre></li>
<li><p>看图说话</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span> (col == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[row<span class="number">-1</span>][col<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> r = row<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &gt;= <span class="number">0</span> &amp;&amp; c &lt; col )&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == matrix[r][c]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[r][c]) c++;</span><br><span class="line">        <span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="#136 Single Number"></a>#136 Single Number</h1><ul>
<li><p>描述</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty <span class="built_in">array</span> of integers, every element appears twice except <span class="keyword">for</span> one. Find that single one.</span><br><span class="line"></span><br><span class="line">Input: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>  方法一： map<br>  方法二： set<br>  方法三： XOR 使用XOR的数学性质，可以很快地解决问题</p>
<pre><code>XOR 数学性质
    I)   a^0=a (a!=0)
    II)  a^a=0 (a!=0)
    III) a^b^a = a^a^b = b^a^a = b </code></pre></li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: nums)</span><br><span class="line">        res ^= i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关键: <font color="red" size="4">XOR行为</font></p>
<h1 id="1122-Relative-Sort-Array"><a href="#1122-Relative-Sort-Array" class="headerlink" title="#1122  Relative Sort Array"></a>#1122  Relative Sort Array</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.</span><br><span class="line"></span><br><span class="line">Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2.  Elements that don&#39;t appear in arr2 should be placed at the end of arr1 in ascending order.</span><br><span class="line"></span><br><span class="line">Input: arr1 &#x3D; [2,3,1,3,2,4,6,7,9,2,19], arr2 &#x3D; [2,1,4,3,9,6]</span><br><span class="line">Output: [2,2,2,1,4,3,3,9,6,7,19]</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>  很直接，遍历arr2，对于arr2中所有元素，在arr1中找到这个元素，并且放到合适的位置，这个位置由变量index指示。看下图：</p>
  <div align="center"><img src="/2019/12/19/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%BA%8C/relative.png" width="450"></div>



</li>
</ul>
<ul>
<li><p>看图说话</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; relativeSortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;    <span class="comment">// extra variable</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr2.size(); i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=index; j&lt;arr1.size(); j++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (arr1[j]==arr2[i])&#123;</span><br><span class="line">                swap(arr1[j], arr1[index]);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(arr1.begin()+index, arr1.end());</span><br><span class="line">    <span class="keyword">return</span> arr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关键： <font color="red" size="4">额外变量的使用</font></p>
<h1 id="1009-Complement-of-Base-10-Integer"><a href="#1009-Complement-of-Base-10-Integer" class="headerlink" title="#1009 Complement of Base 10 Integer"></a>#1009 Complement of Base 10 Integer</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 10 is &quot;1010&quot; in binary, with complement &quot;0101&quot; in binary, which is 5 in base-10.</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路  </p>
<p>  找到对应的111…1，减去已知，的结果。<br>  假设N=5，规律：</p>
<table>
<thead>
<tr>
<th>binary</th>
<th>dec</th>
<th>公式</th>
<th>判断</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>0*2+1</td>
<td>5&gt;1</td>
</tr>
<tr>
<td>11</td>
<td>3</td>
<td>1*2+1</td>
<td>5&gt;3</td>
</tr>
<tr>
<td>111</td>
<td>7</td>
<td>3*2+1</td>
<td>5&lt;7 =&gt;7-5=2</td>
</tr>
<tr>
<td>1111</td>
<td>15</td>
<td>7*1+1</td>
<td></td>
</tr>
<tr>
<td>11111</td>
<td>31</td>
<td>15*2+1</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>看图说话</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (N&gt;x)</span><br><span class="line">        x = x*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x-N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关键：<font color="red" size="4">找到规律</font>，<font color="red" size="4">数进制间的对应</font>，</p>
<h1 id="868-Binay-Bap"><a href="#868-Binay-Bap" class="headerlink" title="#868 Binay Bap"></a>#868 Binay Bap</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: 22</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">22 in binary is 0b10110.</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; N &lt;&#x3D; 10^9</span><br><span class="line">其中相邻1与1之间距离最大的是2，所以返回2.</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>  规律：一个整数的奇偶与其二进制的尾数相关，奇数对应位二进制的尾数是1；偶数对应二进制的尾数是0. 假如N=22：</p>
<table>
<thead>
<tr>
<th>N</th>
<th>左移一位结果</th>
<th>结果的二进制</th>
<th>与N的关系</th>
</tr>
</thead>
<tbody><tr>
<td>22</td>
<td></td>
<td>10110</td>
<td>N左移0位</td>
</tr>
<tr>
<td>22&gt;&gt;1</td>
<td>11</td>
<td>01011</td>
<td>N左移1位</td>
</tr>
<tr>
<td>11&gt;&gt;1</td>
<td>5</td>
<td>00101</td>
<td>N左移2位</td>
</tr>
<tr>
<td>5&gt;&gt;1</td>
<td>2</td>
<td>00010</td>
<td>N左移3位</td>
</tr>
<tr>
<td>2&gt;&gt;1</td>
<td>1</td>
<td>00001</td>
<td>N左移4位</td>
</tr>
<tr>
<td>1&gt;&gt;1</td>
<td>0</td>
<td>00000</td>
<td>N左移5位</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>关键：<font color="red" size="4">移位操作</font>，<font color="red" size="4">找到问题的等价信息</font></p>
<h1 id="985-Sum-of-Even-Numbers-After-Queries"><a href="#985-Sum-of-Even-Numbers-After-Queries" class="headerlink" title="#985 Sum of Even Numbers After Queries"></a>#985 Sum of Even Numbers After Queries</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [1,2,3,4], queries &#x3D; [[1,0],[-3,1],[-4,0],[2,3]]</span><br><span class="line">Output: [8,6,2,4]</span><br><span class="line">Explanation: </span><br><span class="line">At the beginning, the array is [1,2,3,4].</span><br><span class="line">After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 &#x3D; 8.</span><br><span class="line">After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 &#x3D; 6.</span><br><span class="line">After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 &#x3D; 2.</span><br><span class="line">After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 &#x3D; 4.</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>  第一步：原始A数组偶数求和sum</p>
<p>  第二步：对于queries中的每个元素执行如下操作：</p>
<pre><code>1. 如果A中待改变索引的数为even，则从sum中把这个索引对应的数减去。(因为不知道更新后的实际是偶)
2. 更新A数组。
3. 更新后的A中被修改的数如果是even，则把他加到sum中。(更新后的奇偶知道了)
4. 记录sum。</code></pre></li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sumEvenAfterQueries(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(A.begin(), A.end(), <span class="number">0</span>, [](<span class="keyword">int</span> s, <span class="keyword">int</span> a)&#123;</span><br><span class="line">            <span class="keyword">return</span> s+(a%<span class="number">2</span>==<span class="number">0</span>?a:<span class="number">0</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q:queries)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[q[<span class="number">1</span>]]%<span class="number">2</span>==<span class="number">0</span>) sum-=A[q[<span class="number">1</span>]];  <span class="comment">// 1.</span></span><br><span class="line">        A[q[<span class="number">1</span>]] += q[<span class="number">0</span>];               <span class="comment">//2.</span></span><br><span class="line">        <span class="keyword">if</span> (A[q[<span class="number">1</span>]]%<span class="number">2</span>==<span class="number">0</span>) sum+=A[q[<span class="number">1</span>]]; <span class="comment">//3.</span></span><br><span class="line">        res.push_back(sum);            <span class="comment">// 4.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关键：<font color="red" size="4">直接想到的方法通常不是最好的</font>，<font color="red" size="4">lambda函数</font></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/19/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%BA%8C/" data-id="ck5bbuohq002ya2fz9vl34llw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vim-neovim" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/18/vim-neovim/" class="article-date">
  <time datetime="2019-12-18T14:22:49.000Z" itemprop="datePublished">2019-12-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Utility/">Utility</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/18/vim-neovim/">vim-neovim</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>将这些操作变为肌肉记忆。<br>可以将常用操作写进配置文件文件中。</p>
<ol>
<li>vim 对应的配置文件 <code>~.vimrc</code> </li>
<li>neovim 对应的配置文件 <code>~.config/nvim/init.vim</code></li>
</ol>
<ul>
<li><p>Open files</p>
<pre><code>vi a.txt b.txt -O   :窗口打开两个文件</code></pre></li>
<li><p>Command Mode</p>
<pre><code>:           :进入Command Mode
e!          :重新加载文件，撤销这次修改
set nu      :加上行号   .vimrc
syntax on   :语法高亮   .vimrc
help s      :查看s的文档
ls          :列出打开的文件（所有的buffer）
b a.txt     :跳到a.txt
e b.txt     :打开b.txt 加入另一个buffer
vs          :当前文件分一个窗口显示
vs a.txt    :分窗口打开a.txt
ZZ          :关闭这个窗口，但不退出对应的buffer

ctrl w w            :光标移动到下一个文件

ctrl w =            :所有窗口等宽度
ctrl w |            :最大化当前窗口
ctrl w p            :回到上一个窗口</code></pre></li>
<li><p>Insert Mode</p>
<pre><code>ctrl u  :删除当前行 从行首到当前位置的内容
ctrl h  :删除当前位置前一个字符
ctrl w  :删除当前单词 从单词首到当前位置内容</code></pre></li>
<li><p>Visual Mode</p>
<p>  Visual Mode的一般操作步骤：进入Visual Mode，后<font color="red" size="4">选择</font>所需内容，对所选内容进行<font color="red" size="4">操作</font>。</p>
<pre><code>v   :从Normal Mode进入Visual Mode
V   :从Normal Mode进入Visual Mode 并且选中当前行</code></pre></li>
<li><p>Normal Mode (即Read Mode，是进入Vim的默认模式，Esc返回Normal Mode)</p>
<pre><code>a   :从当前位置的下一个位置 进入Insert Mode
i   :从当前位置开始 进入Insert Mode

I   :从当前行行首开始 进入Insert Mode
A   :从当前行行尾开始 进入Insert Mode

o   :从下一行的行首 进入Insert Mode
O   :从上一行的行首 进入Insert Mode

gg      :跳到整个文件的首行
25gg    :跳到25行行首
G       :跳到整个文件的尾行

H/M/L   :移动到窗口的高/中/低位置

ctrl u  :向上翻页
ctrl f  :向下翻页

zz  :当前行放到窗口的中间

w/b      :以单词为单位移动 向后移动/向前移动
h/j/k/l  :以字符为单位移动 左/下/上/右

0   :移到行首
$   :移到行尾

y   :复制
yiw :复制这个词
yy  :复制这一行
p   :粘贴到下一行
P   :大p粘到上一行
dd  :删除这一行
diw :删除这个词

u   :撤销这一步
ZZ  :保存并退出

ctrl s/ctrl q   :锁vim窗口/解锁窗口</code></pre></li>
<li><p>Combo operations</p>
<pre><code>ciw     :进入insert mode 更改这个单词 i表示“in”
viw     :选中这个单词
caw     :改变这个单词
viw-&gt;y-&gt;viw-&gt;p  :拷贝一个单词从这里拷贝到那里        

vi(     :选中括号中内容
ci&quot;     :改变这一行中“”中内容 
ci[     :改变这一行中[]中内容
vi&quot;     :选中这一行中“”中内容
yi)     :选择()中所有内容
da[     :删除[]中所有内容

dt&quot;     :删除从此到“的内容 t表示“to”
di&lt;
:% s/XXX/YYY/g     :用XXX替换YYY   
:32,65d            :delete from line 32 to line 65,  

v, $, y :从此处复制到行尾
v, $, p :从此处粘贴到行尾 </code></pre></li>
</ul>
<ul>
<li><p>命令中的字母含义</p>
<pre><code>gg,G        : top, bottom
d,c,y,v     : delete, change, copy, visually select
w,s,p,t     : words, sentences, paragraphs, tags(HTML)
a,i,t,f,F   : all, in, till, find formard, find Backward</code></pre></li>
<li><p>Code 补全</p>
<pre><code>ctrl n + ctrl p     :自动补全词</code></pre></li>
<li><p>查询且高亮</p>
<pre><code>:set incsearch  :一边查一边高亮     
:set hlsearch   :查询结果高亮      
/JUNHUI         :(normal mode下)查询字符“JUNHUI”，n定位到下一个，N定位到上一个。 </code></pre></li>
<li><p>有用插件</p>
<ul>
<li><p>NERDTree        :显示目录的插件。</p>
<p>  使用方法：<code>cd</code>到project目录-&gt;进入<code>nvim</code>-&gt;<code>Command Mode</code>输入<code>:NERDTree</code>，即可显示当前project的文件和文件夹。</p>
<p>  可以使用<code>&lt;Leader&gt;</code>快捷键避免繁复输入<code>NERDTree</code>。类似的设置要写入配置文件。</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/18/vim-neovim/" data-id="ck5bbuoha002ia2fz7mk5dcv8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-方法论-map-set-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/18/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-map-set-%E4%B8%80/" class="article-date">
  <time datetime="2019-12-18T05:53:03.000Z" itemprop="datePublished">2019-12-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/18/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-map-set-%E4%B8%80/">LeetCode-方法论-map&amp;set-一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>594, 349, 350, 1, 290, 205, 451, 202, </p>
<p>map包括有序map和无序map，set也分为有序set和无序set。<br>map由键值构成，set中元素无重复。</p>
<p>常用操作: <code>find()</code>, <code>insert()</code>, <code>erase()</code>, <code>change()</code>, <code>search()</code>,</p>
<h1 id="594-最长Harmonius-子序列"><a href="#594-最长Harmonius-子序列" class="headerlink" title="#594 最长Harmonius 子序列"></a>#594 最长Harmonius 子序列</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,2,2,5,2,3,7]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest harmonious subsequence is [3,2,2,2,3].</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：<br>  1) 第一步 将数组元素作为key，对应出现的次数作为val，放入map中。如下：</p>
<pre><code>map | 1st | 2nd | 3rd | 4th| 5th 
-|-|-|-|-|-
key | 1 | 2 | 3 | 5 | 7 |
val | 1 | 3 | 2 | 1 | 1 |</code></pre><p>  2) 遍历map：</p>
<pre><code>对于key=1，如果key=2存在，则子序列长度为： key=1的val + key=2的val： 1+3=4
对于key=2，如果key=3存在，则子序列长度为： key=2的val + key=3的val： 3+2=5
对于key=3，如果key=4不存在，continue
对于key=5，如果key=6不存在，continue
对于key=7，如果key=8不存在，continue
最终返回最大值 5</code></pre></li>
<li><p>实现如下：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// create map</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item: nums)</span><br><span class="line">        mp[item]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main process</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itr = mp.begin(); itr!=mp.end(); itr++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( mp.find(itr-&gt;first + <span class="number">1</span>) != mp.end())&#123;</span><br><span class="line">            res = max(res, mp[itr-&gt;first] + mp[itr-&gt;first+<span class="number">1</span>]);  <span class="comment">// update max</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="349-Intersection-Of-Two-Arrays"><a href="#349-Intersection-Of-Two-Arrays" class="headerlink" title="#349 Intersection Of Two Arrays"></a>#349 Intersection Of Two Arrays</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">Output: [9,4]</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑</p>
<pre><code>第一步：将nums1中元素放入set中
第二步：从set中查找nums2中每个元素，
    如果找到，就放入结果set中，如此一来，结果中也没有重复元素。
    如果没找到，continue。</code></pre></li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; record(nums1.begin(), nums1.end());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; resSet;</span><br><span class="line">    <span class="comment">// 第二步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums2.size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (record.find(nums2[i]) != record.end()) <span class="comment">//in record</span></span><br><span class="line">            resSet.insert(nums2[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;( resSet.begin(), resSet.end() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="350-INtersection-Of-Two-Arrays-II"><a href="#350-INtersection-Of-Two-Arrays-II" class="headerlink" title="#350 INtersection Of Two Arrays II"></a>#350 INtersection Of Two Arrays II</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑</p>
<pre><code>第一步：将nums1中元素放入map中
第二步：遍历num2中每个元素：
    如果当前元素在map中的频数&gt;0, 那么在结果vector中加入这个元素，同时map中这个元素的频数-1.
    如果当前元素在map中的频数==0，说明这个元素不是共有的，continue。</code></pre></li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums1.size(); i++)</span><br><span class="line">        record[nums1[i]] ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; resV;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (record[nums2[i]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            resV.push_back(nums2[i]);</span><br><span class="line">            record[nums2[i]] -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="#1 Two Sum"></a>#1 Two Sum</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br><span class="line"></span><br><span class="line">NOTE:You may assume that each input would have exactly one solution, </span><br><span class="line">and you may not use the same element twice.</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑</p>
<pre><code>遍历nums中所有元素nums[i]：
    如果:map中没有找到target-nums[i]这个值，就把{nums[i], i}放入map中；
    如果:map中找到了target-nums[i]，那么当前值index和target-nums[i]的index放入结果中。done</code></pre></li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">        <span class="comment">// nums[i] is not in the record</span></span><br><span class="line">        <span class="keyword">if</span> (record.find(target - nums[i]) == record.end())&#123;</span><br><span class="line">            record[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// nums[i] is in the record</span></span><br><span class="line">            <span class="keyword">int</span> res[<span class="number">2</span>] = &#123;record[target-nums[i]], i&#125;;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res, res+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> invalid_argument(<span class="string">"NO SOLUTION!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="green" size="5">敲黑板</font>这个问题虽然简单，但有两点值得注意：<br><font color="red" size="4">元素逐个放入map</font>，<font color="red" size="4">map的value为index</font>。相同的技巧，看#290.</p>
</li>
</ul>
<h1 id="290-Word-Pattern"><a href="#290-Word-Pattern" class="headerlink" title="#290 Word Pattern"></a>#290 Word Pattern</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat dog&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑 (不容易想到)</p>
<p>  要使用c++ 中 map容器的一个性质：”空的map中任何key对应的value都是0”。</p>
<pre><code>第一步：为两个input分别声明map。
第二步：同步遍历pattern和str每一个元素：
    如果 两个map的key对应的value（index）相同，赋值给两个value为index+1;
    否则 返回false
最终判断：最终的循环变量i是否等于input 的长度。</code></pre></li>
</ul>
<ul>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp1;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从一个string中逐个读取单词</span></span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, n = pattern.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">string</span> word; in &gt;&gt; word; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n || mp1[pattern[i]] != mp2[word])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        mp2[word] = i + <span class="number">1</span>;</span><br><span class="line">        mp1[pattern[i]] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>细节：从一个string中逐个读取单词。使用了c++中map的特性，考虑其他更通用的方法。</p>
<h1 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="#205 Isomorphic Strings"></a>#205 Isomorphic Strings</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>  思路与#290相同。用图示表示出来：</p>
<p>  以 s = “egg”, t = “add” 为例：</p>
  <div align="center"><img src="/2019/12/18/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-map-set-%E4%B8%80/205-1.png" width="500"></div>

<p>  以 s = “egg”, t = “ade” 为例：</p>
  <div align="center"><img src="/2019/12/18/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-map-set-%E4%B8%80/205-2.png" width="500"></div>
</li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mpS;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mpT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (mpS[s[i]] != mpT[t[i]])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        mpS[s[i]]=i+<span class="number">1</span>;</span><br><span class="line">        mpT[t[i]]=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><font color="green" size="5">敲黑板</font>逐个放入map</p>
<h1 id="451-Sort-Charactors-By-Frequency"><a href="#451-Sort-Charactors-By-Frequency" class="headerlink" title="#451 Sort Charactors By Frequency"></a>#451 Sort Charactors By Frequency</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;aBbbccc&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;cccbbaB&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑</p>
<p>  很直接</p>
<pre><code>第一步：将string s中元素放入map中，并且把键值对作为元素翻入vector中。
第二步：按value的大小从大到小排序。
第三步：将vector中的元素放入结果string中。</code></pre></li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmpByValue</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; l, <span class="keyword">const</span> pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l.second &gt; r.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">frequencySort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)</span><br><span class="line">        mp[s[i]] ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; mapValue(mp.begin(), mp.end());</span><br><span class="line">    sort(mapValue.begin(), mapValue.end(), cmpByValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mapValue.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;mapValue[i].second; j++)&#123;</span><br><span class="line">            res+=mapValue[i].first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="#202 Happy Number"></a>#202 Happy Number</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">1**2 + 9**2 &#x3D; 82</span><br><span class="line">8**2 + 2**2 &#x3D; 68</span><br><span class="line">6**2 + 8**2 &#x3D; 100</span><br><span class="line">1**2 + 0**2 + 0**2 &#x3D; 1</span><br><span class="line"></span><br><span class="line">Those numbers for which this process ends 1 are happy numbers.</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑</p>
<p>  过程如描述中的Explanation。要注意的是，对于不是happy number的数，防止无限循环，将每一步的结果放入set中（不重复）。</p>
</li>
</ul>
<ul>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        res+=<span class="built_in">pow</span>(n % <span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line">        n/=<span class="number">10</span>;   <span class="comment">// 每次循环，从高高位到低位得到每一位的数值。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; record;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n ==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        </span><br><span class="line">        record.insert(n);</span><br><span class="line">        n = func(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (record.find(n) != record.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/18/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-map-set-%E4%B8%80/" data-id="ck5bbuogy0021a2fz5cct489k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CUDA-Nsight-Eclipse-Edition" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/10/CUDA-Nsight-Eclipse-Edition/" class="article-date">
  <time datetime="2019-12-10T04:13:56.000Z" itemprop="datePublished">2019-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CUDA/">CUDA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/10/CUDA-Nsight-Eclipse-Edition/">CUDA-Nsight Eclipse Edition</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Nsight 是一个开发CUDA程序的IDE和debug工具。</p>
<ol>
<li><p>使用Nsight打开samples程序。<br>选择“new”，“CUDA C/C++ Project”,给<code>project</code>命名，<code>Project type</code> 选择”Import CUDA Sample“。接下来从你的机器的<code>samples install location</code>中选择想要打开的project。如果机器上有CUDA-enabled GPU，接下来的设置默认就好。此时可以看到，<code>.cu</code>文件存在于project下的<code>src</code>文件中。这表示，如果自己新建的project也应个先create一个<code>src</code>文件夹，来存放所有源文件。</p>
</li>
<li><p>使用Nsight创建自己的project。<br>如上述，只需在<code>project type</code>选择“Empty Project”。然后在这个project中 新建一个“Source Folder”，取名为<code>src</code>。最后就可以把所有的 <code>.cu</code>, <code>.cuh</code>, <code>.cpp</code>, <code>.h</code> 等源码文件在src中创建。</p>
</li>
</ol>
<p>Nsight 的强大之处在于debug。它可以告诉你你的程序使用了多少<code>SM</code>，多少<code>warp</code>，多少<code>registers</code>，以及每个<code>register</code>中所存放的内容，<code>SM</code>的利用率，硬件基本信息等等。除了debug，Nsight还集成了<code>visual profiler</code>的功能，即可视化程序每个部分的执行时间，以便找到程序可优化之处：<br>以如下简单code为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">kernel</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> tid = threadIdx.x + blockDim.x * blockIdx.x;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> idd=tid; idd&lt;N; idd+=stride)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"hello from thread: %d\n"</span>, idd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	kernel&lt;&lt;&lt;<span class="number">2</span>, <span class="number">12</span>&gt;&gt;&gt;(<span class="number">36</span>);</span><br><span class="line">	cudaDeviceSynchronize(); <span class="comment">//同步Device和Host，即，device 执行完后再执行Host</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello from Host\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即我有36个元素要处理，使用32个线程，并且32个线程分配到1个block中。当启用debug时，可以得到Device端的信息。<br>从硬件角度看：</p>
<div align="center"> <img src="/2019/12/10/CUDA-Nsight-Eclipse-Edition/01.png" width="700"> </div>
可以看到我的GPU编号为0，共有5个SM，使用了2个SM，每个SM都有64分warp，只使用了1个warp。

<p>具体看一个SM中的一个warp。一个warp有32个线程，此处只使用了12个。</p>
<div align="center"> <img src="/2019/12/10/CUDA-Nsight-Eclipse-Edition/02.png" width="700"> </div>

<p>从逻辑角度看：启用了两个block，分别在两个SM中。</p>
<div align="center"> <img src="/2019/12/10/CUDA-Nsight-Eclipse-Edition/03.png" width="700"> </div>

<p>每个block使用12个线程。</p>
<div align="center"> <img src="/2019/12/10/CUDA-Nsight-Eclipse-Edition/04.png" width="700"> </div>

<p>另外Nsight还会给出Host的信息，如下：</p>
<div align="center"> <img src="/2019/12/10/CUDA-Nsight-Eclipse-Edition/05.png" width="700"> </div>

<p>以下是GPU中registers中的信息：</p>
<div align="center"> <img src="/2019/12/10/CUDA-Nsight-Eclipse-Edition/06.png" width="700"> </div>

<p>以及dissambly信息：</p>
<div align="center"> <img src="/2019/12/10/CUDA-Nsight-Eclipse-Edition/07.png" width="700"> </div>

<p>当生成可执行文件后，便可以使用profiler测程序的性能。</p>
<hr>
<p><span style="font-family:Papyrus; font-size:2em;">CUDA</span></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/10/CUDA-Nsight-Eclipse-Edition/" data-id="ck5bbuog6001ca2fzcjve0z3c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CUDA/" rel="tag">CUDA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CUDA-project-review" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/09/CUDA-project-review/" class="article-date">
  <time datetime="2019-12-09T02:49:07.000Z" itemprop="datePublished">2019-12-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CUDA/">CUDA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/09/CUDA-project-review/">CUDA-project review</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇blog记录了项目中使用或未使用到的CUDA知识点。</p>
<ul>
<li><p><code>__constant__ float d_arr[10]</code> 在constant memory中开辟10个空间。 </p>
</li>
<li><p><code>cudaMemcpyToSymbol(d_arr, h_arr, sizeof(h_arr))</code> 将Host中的数据复制进Device中所开辟的空间。</p>
</li>
<li><p><code>__device__ float d_arr[10][5]</code> 在Global memory中开辟空间。</p>
</li>
<li><p><code>cudaMemcpyFromSymbol(h_arr,d_arr, sizeof(d_arr))</code> 将Device中的数据复制到Host中所开辟的空间。</p>
</li>
<li><p>在<code>local memory</code>中开辟空间，lifetime为threads的周期：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> tmp[<span class="number">7</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>registers</code>而非<code>local memory</code>，当所需数据大小较小，且数量固定时将<code>float a[3]</code> 改写成<code>float a0,a1,a2</code>.</p>
</li>
<li><p>使用<code>grid-stride-loop</code>。其中idd需要根据实际问题计算得到:</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid = ...;</span><br><span class="line">    <span class="keyword">int</span> stride = ...;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idd = tid; idd&lt;N; idd+=stride)&#123;</span><br><span class="line">        <span class="comment">// idd is the thread id in this loop;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  使用grid-stride-loop 后，将kernel函数改为<code>&lt;&lt;&lt;1,1&gt;&gt;&gt;</code>，并且在适当的位置加上打印语句。便于调试。</p>
</li>
<li><p>实现时，在cuda相关的 语句前加上<code>checkCudaError()</code>.这个函数要自己实现。</p>
</li>
<li><p>在调用跟kernel函数后，加上<code>checkCudaError(cudaGetLatError())</code>;</p>
</li>
<li><p>根据当前问题找example中可用内容。</p>
</li>
<li><p>实验函数，先用笔在纸上实现，定义内个变量的含义，左后写code。</p>
</li>
<li><p>在一个较大的实现中，保证一段code一个功能，这一段的实现尽量不要使用其他段code的变量，尽量使每段code独立化。</p>
</li>
<li><p><code>pinned memory</code> VS <code>pageable memory</code>.</p>
</li>
<li><p>deviceQuery 轻量级的方法。</p>
</li>
<li><p>协作组</p>
</li>
<li><p>对于 代操作数据为二维或三维点，一个技巧是，为了尽可能减少PCIe的使用，线程id天然可以表示成数据点的坐标：<code>(idx,idy)&lt;=&gt;(x,y)</code>.</p>
</li>
<li><p>因为Device段不能动态分配空间，所以当实现摸个算法的CPU版本时，要使用stack内存，开辟足够多的空间。</p>
</li>
<li><p><code>cudaMallocPitch()</code>;</p>
</li>
<li><p><code>cudaMemSet2D()</code>;</p>
</li>
<li><p><code>std::bitset&lt;16&gt; foo</code>;</p>
</li>
<li><p>角度与弧度的转化：<code>1°=π/180,1rad=(180/π)°</code></p>
</li>
<li><p>choose device</p>
</li>
<li><p>multiple GPUs</p>
</li>
<li><p>使用event给code计时。或自己写计时类。</p>
</li>
<li><p>Unified Memory.</p>
</li>
<li><p>循环展开，减少操作。</p>
</li>
<li><p>注意CPU code中不可并行的部分，如下：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tid &lt; N)&#123;</span><br><span class="line">    bb[tid+<span class="number">1</span>] = count + bb[tid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  上面的指令只能串行执行。</p>
</li>
</ul>
<hr>
<p><span style="font-family:Papyrus; font-size:2em;">CUDA</span></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/09/CUDA-project-review/" data-id="ck5bbuofm000ha2fz0w0o2c83" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CUDA/" rel="tag">CUDA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CUDA-optimize-data-transfer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/28/CUDA-optimize-data-transfer/" class="article-date">
  <time datetime="2019-11-28T15:06:15.000Z" itemprop="datePublished">2019-11-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CUDA/">CUDA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/28/CUDA-optimize-data-transfer/">CUDA-optimize data transfer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Optimize-Data-Transfers"><a href="#Optimize-Data-Transfers" class="headerlink" title="Optimize Data Transfers"></a>Optimize Data Transfers</h1><p>The peak bandwidth between the device memory and the GPU is much higher (<strong>144 GB/s</strong> on the NVIDIA Tesla C2050, for example) than the peak bandwidth between host memory and device memory (<strong>8 GB/s</strong> on PCIe x16 Gen2). This disparity means that your implementation of data transfers between the host and GPU devices can make or break your overall application performance. <br>Let’s start with a few general guidelines for host-device data transfers.</p>
<ol>
<li>Minimize the amount of data transferred between host and device when possible, even if that means running kernels on the GPU that get little or no speed-up compared to running them on the host CPU.</li>
<li>Higher bandwidth is possible between the host and the device when using page-locked (or “pinned”) memory.</li>
<li>Batching many small transfers into one larger transfer performs much better because it eliminates most of the per-transfer overhead.</li>
<li>Data transfers between the host and device can sometimes be overlapped with kernel execution and other data transfers.</li>
</ol>
<p>We investigate the first three guidelines above in this post, and we dedicate the next post to <strong>overlapping data transfers</strong>. First I want to talk about how to measure time spent in data transfers without modifying the source code.</p>
<h2 id="Measuring-Data-Transfer-Times-with-nvprof"><a href="#Measuring-Data-Transfer-Times-with-nvprof" class="headerlink" title="Measuring Data Transfer Times with nvprof"></a>Measuring Data Transfer Times with nvprof</h2><p>To measure the time spent in each data transfer, we could record a CUDA event before and after each transfer and use cudaEventElapsedTime(), as we described in a previous post.  However, we can get the elapsed transfer time without instrumenting the source code with CUDA events by using <strong>nvprof</strong>.<br>推荐使用nvprof，测试间。</p>
<p>使用实例.假如有一源文件·<code>profile.cu</code>, 编译: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nvcc profile.cu</span><br><span class="line">$ nvprof ./a.out</span><br></pre></td></tr></table></figure>

<p>It returns as follow:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ nvprof ./a.out </span><br><span class="line">======== NVPROF is profiling a.out...</span><br><span class="line">======== Command: a.out</span><br><span class="line">======== Profiling result:</span><br><span class="line">Time(%)     Time  Calls      Avg      Min      Max Name</span><br><span class="line">  <span class="number">50.08</span> <span class="number">718.11u</span>s      <span class="number">1</span> <span class="number">718.11u</span>s <span class="number">718.11u</span>s <span class="number">718.11u</span>s [CUDA <span class="built_in">memcpy</span> DtoH]</span><br><span class="line">  <span class="number">49.92</span> <span class="number">715.94u</span>s      <span class="number">1</span> <span class="number">715.94u</span>s <span class="number">715.94u</span>s <span class="number">715.94u</span>s [CUDA <span class="built_in">memcpy</span> HtoD]</span><br></pre></td></tr></table></figure>

<h2 id="Minimizing-Data-Transfers"><a href="#Minimizing-Data-Transfers" class="headerlink" title="Minimizing Data Transfers"></a>Minimizing Data Transfers</h2><p>如果可以不传输数据，就不要传输。总之，尽量少用PCIe。</p>
<h2 id="Pinned-Host-Memory"><a href="#Pinned-Host-Memory" class="headerlink" title="Pinned Host Memory"></a>Pinned Host Memory</h2><p>测试使用P106 和 GTX1060，使用pinned memory 并没有显著提高。</p>
<h2 id="Batching-Small-Transfers"><a href="#Batching-Small-Transfers" class="headerlink" title="Batching Small Transfers"></a>Batching Small Transfers</h2><p>Due to the overhead associated with each transfer, it is preferable to batch many small transfers together into a single transfer. This is easy to do by using a temporary array, preferably pinned, and packing it with the data to be transferred.</p>
<p>For two-dimensional array transfers, you can use <code>cudaMemcpy2D()</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaMemcpy2D(dest, dest_pitch, src, src_pitch, w, h, cudaMemcpyHostToDevice)</span><br></pre></td></tr></table></figure>
<p>The arguments here are a pointer to the first destination element and the pitch of the destination array, a pointer to the first source element and pitch of the source array, the width and height of the submatrix to transfer, and the memcpy kind. There is also a cudaMemcpy3D() function for transfers of rank three array sections.</p>
<p>原文作者 Mark Harris<br>原文<a href="https://devblogs.nvidia.com/how-optimize-data-transfers-cuda-cc/" target="_blank" rel="noopener">链接</a></p>
<hr>
<p><span style="font-family:Papyrus; font-size:2em;">CUDA</span></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/28/CUDA-optimize-data-transfer/" data-id="ck5bbuofj000ca2fz4gse3ty2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CUDA/" rel="tag">CUDA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CUDA-overlap-data-transfer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/28/CUDA-overlap-data-transfer/" class="article-date">
  <time datetime="2019-11-28T15:01:48.000Z" itemprop="datePublished">2019-11-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CUDA/">CUDA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/28/CUDA-overlap-data-transfer/">CUDA-overlap data transfer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Overlap-Data-Transfers"><a href="#Overlap-Data-Transfers" class="headerlink" title="Overlap Data Transfers"></a>Overlap Data Transfers</h1><p>目的是通过并发，隐藏延时。we discuss how to overlap data transfers with computation on the host。并发是指数据传输和host上的操作一同执行。Achieving overlap between data transfers and other operations requires the use of CUDA streams, so first let’s learn about streams.</p>
<h2 id="CUDA-Srteam"><a href="#CUDA-Srteam" class="headerlink" title="CUDA Srteam"></a>CUDA Srteam</h2><p>A stream in CUDA is a sequence of operations that execute on the device in the order in which they are issued by the host code. While operations within a stream are guaranteed to execute in the prescribed order, operations in different streams can be interleaved and, when possible, they can even run concurrently.</p>
<h3 id="1-The-default-stream"><a href="#1-The-default-stream" class="headerlink" title="1. The default stream"></a>1. The default stream</h3><p>All device operations (kernels and data transfers) in CUDA run in a stream. When no stream is specified, the default stream (also called the “null stream”) is used. The default stream is different from other streams because it is a synchronizing stream with respect to operations on the device: no operation in the default stream will begin until all previously issued operations in any stream on the device have completed, and an operation in the default stream must complete before any other operation (in any stream on the device) will begin.</p>
<p>Please note that CUDA 7, released in 2015, introduced a new option to use a separate default stream per host thread, and to treat per-thread default streams as regular streams (i.e. they don’t synchronize with operations in other streams)</p>
<p>Let’s look at some simple code examples that use the default stream, and discuss how operations progress from the perspective of the host as well as the device.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cudaMemcpy(d_a, a, numBytes, cudaMemcpyHostToDevice);</span><br><span class="line">increment&lt;&lt;&lt;<span class="number">1</span>,N&gt;&gt;&gt;(d_a)</span><br><span class="line">cudaMemcpy(a, d_a, numBytes, cudaMemcpyDeviceToHost);</span><br></pre></td></tr></table></figure>

<p>From the perspective of the device, all three operations are issued to the same (default) stream and will execute in the order that they were issued.</p>
<p>From the perspective of the host, the implicit data transfers are blocking or synchronous transfers, while the kernel launch is asynchronous. </p>
<p>Since the host-to-device data transfer on the first line is synchronous, the CPU thread will not reach the kernel call on the second line until the host-to-device transfer is complete. Once the kernel is issued, the CPU thread moves to the third line, but the transfer on that line cannot begin due to the device-side order of execution.</p>
<p>The asynchronous behavior of kernel launches from the host’s perspective makes overlapping device and host computation very simple. We can modify the code to add some independent CPU computation as follows.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cudaMemcpy(d_a, a, numBytes, cudaMemcpyHostToDevice);</span><br><span class="line">increment&lt;&lt;&lt;<span class="number">1</span>,N&gt;&gt;&gt;(d_a)    <span class="comment">// device 执行这个</span></span><br><span class="line">myCpuFunction(b)           <span class="comment">// 同时 host 执行这个</span></span><br><span class="line">cudaMemcpy(a, d_a, numBytes, cudaMemcpyDeviceToHost);</span><br></pre></td></tr></table></figure>

<p>上述code实现了一个overlap，在<code>increment()</code>和<code>myCpuFunction()</code>同时分别在device和host端执行。Whether the host function or device kernel completes first doesn’t affect the subsequent device-to-host transfer, which will begin only after the kernel completes.  From the perspective of the device, nothing has changed from the previous example; the device is completely unaware of myCpuFunction(). 从device的角度看，device并不知道<code>myCpuFunction()</code>这个操作的存在，device端的操作与前一段code一模一样。</p>
<h3 id="2-Non-default-streams"><a href="#2-Non-default-streams" class="headerlink" title="2. Non-default streams"></a>2. Non-default streams</h3><p>Non-default streams in CUDA C/C++ are declared, created, and destroyed in host code as follows.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cudaStream_t stream1;    <span class="comment">// 声明一个stream</span></span><br><span class="line">cudaError_t result;</span><br><span class="line">result = cudaStreamCreate(&amp;stream1)  <span class="comment">// create</span></span><br><span class="line">result = cudaStreamDestroy(stream1)   <span class="comment">// destroy</span></span><br></pre></td></tr></table></figure>

<p>To issue a data transfer to a non-default stream we use the <code>cudaMemcpyAsync()</code> function, which is similar to the <code>cudaMemcpy()</code> function discussed in the previous post, but takes a stream identifier as a <strong>fifth</strong> argument.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = cudaMemcpyAsync(d_a, a, N, cudaMemcpyHostToDevice, stream1)</span><br></pre></td></tr></table></figure>

<p><code>cudaMemcpyAsync()</code> is non-blocking on the host, so control returns to the host thread immediately after the transfer is issued. There are <code>cudaMemcpy2DAsync()</code> and <code>cudaMemcpy3DAsync()</code> variants of this routine which can transfer 2D and 3D array sections asynchronously in the specified streams.</p>
<p>To issue a kernel to a non-default stream we specify the stream identifier as a <strong>fourth</strong> execution configuration parameter (the <strong>third</strong> execution configuration parameter allocates <code>shared device memory</code>, which we’ll talk about later; use 0 for now).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">increment&lt;&lt;&lt;<span class="number">1</span>, N, <span class="number">0</span>, stream1&gt;&gt;&gt;(d_a)</span><br></pre></td></tr></table></figure>

<h3 id="3-Synchronization-with-streams"><a href="#3-Synchronization-with-streams" class="headerlink" title="3. Synchronization with streams"></a>3. Synchronization with streams</h3><p>在执行cudaMemcpy()时，code变为同步的，就是说，host code要等待这个copy函数执行完毕，才能接着往下执行。而all operations in non-default streams are non-blocking with respect to the host code,  you will run across situations where you need to synchronize the host code with operations in a stream. 同步就需要我们来做了。有若干种方法来同步：The “heavy hammer” way is to use <code>cudaDeviceSynchronize()</code>, which blocks the host code until all previously issued operations on the device have completed. In most cases this is <strong>overkill</strong>, and can really hurt performance due to stalling the entire device and host thread.</p>
<p>The <strong>CUDA stream API</strong> has multiple less severe methods of synchronizing the host with a stream. </p>
<ul>
<li><code>cudaStreamSynchronize(stream)</code> can be used to block the host thread until all previously issued operations in the specified stream have completed.</li>
<li><code>cudaStreamQuery(stream)</code> tests whether all operations issued to the specified stream have completed, without blocking host execution.</li>
<li><code>cudaEventSynchronize(event)</code> &amp; <code>cudaEventQuery(event)</code> act similar to their stream counterparts, except that their result is based on whether a specified event has been recorded rather than whether a specified stream is idle.</li>
<li><code>cudaStreamWaitEvent(event)</code> You can also synchronize operations within a single stream on a specific event using cudaStreamWaitEvent(event) (even if the event is recorded in a different stream, or on a different device!).</li>
</ul>
<h2 id="Overlapping-Kernel-Execution-and-Data-Transfers"><a href="#Overlapping-Kernel-Execution-and-Data-Transfers" class="headerlink" title="Overlapping Kernel Execution and Data Transfers"></a>Overlapping Kernel Execution and Data Transfers</h2><p>Earlier we demonstrated how to overlap kernel execution in the default stream with execution of code on the host. But our main goal in this post is to show you how to overlap kernel execution with data transfers. There are several requirements for this to happen. There are several requirements for this to happen.</p>
<ul>
<li>The device must be capable of <code>“concurrent copy and execution”</code>.  This can be queried from the deviceOverlap field of a <code>cudaDeviceProp</code> struct, or from the output of the deviceQuery sample included with the CUDA SDK/Toolkit. Nearly all devices with compute capability 1.1 and higher have this capability.</li>
<li>The kernel execution and the data transfer to be overlapped must both occur <strong>in different, non-default streams</strong>.</li>
<li>The host memory involved in the data transfer must be <strong>pinned</strong> memory.</li>
</ul>
<p>附录为实例程序，we break up the array of size <code>N</code> into chunks of <code>streamSize</code> elements. Since the kernel operates independently on all elements, each of the chunks can be processed independently. The number of (non-default) streams used is <code>nStreams=N/streamSize</code>. There are multiple ways to implement the domain decomposition of the data and processing; one is to loop over all the operations for each chunk of the array as in this example code.</p>
<p>原文内容作者Mark Harris<br>原文<a href="https://devblogs.nvidia.com/how-overlap-data-transfers-cuda-cc/" target="_blank" rel="noopener">链接</a><br>原文<a href="https://github.com/NVIDIA-developer-blog/code-samples/blob/master/series/cuda-cpp/overlap-data-transfers/async.cu" target="_blank" rel="noopener">程序</a></p>
<hr>
<p><span style="font-family:Papyrus; font-size:2em;">CUDA</span></p>
<p>附录<br>完整code：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Convenience function for checking CUDA runtime API results</span></span><br><span class="line"><span class="comment">// can be wrapped around any runtime API call. No-op in release builds.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> cudaError_t <span class="title">checkCuda</span><span class="params">(cudaError_t result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG) || defined(_DEBUG)</span></span><br><span class="line">  <span class="keyword">if</span> (result != cudaSuccess) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"CUDA Runtime Error: %s\n"</span>, cudaGetErrorString(result));</span><br><span class="line">    assert(result == cudaSuccess);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">kernel</span><span class="params">(<span class="keyword">float</span> *a, <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = offset + threadIdx.x + blockIdx.x*blockDim.x;</span><br><span class="line">  <span class="keyword">float</span> x = (<span class="keyword">float</span>)i;</span><br><span class="line">  <span class="keyword">float</span> s = sinf(x); </span><br><span class="line">  <span class="keyword">float</span> c = cosf(x);</span><br><span class="line">  a[i] = a[i] + sqrtf(s*s+c*c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">maxError</span><span class="params">(<span class="keyword">float</span> *a, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">float</span> maxE = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">float</span> error = <span class="built_in">fabs</span>(a[i]<span class="number">-1.0f</span>);</span><br><span class="line">    <span class="keyword">if</span> (error &gt; maxE) maxE = error;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> blockSize = <span class="number">256</span>, nStreams = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">4</span> * <span class="number">1024</span> * blockSize * nStreams;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> streamSize = n / nStreams;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> streamBytes = streamSize * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> bytes = n * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">int</span> devId = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) devId = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  cudaDeviceProp prop;</span><br><span class="line">  checkCuda( cudaGetDeviceProperties(&amp;prop, devId));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Device : %s\n"</span>, prop.name);</span><br><span class="line">  checkCuda( cudaSetDevice(devId) );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate pinned host memory and device memory</span></span><br><span class="line">  <span class="keyword">float</span> *a, *d_a;</span><br><span class="line">  checkCuda( cudaMallocHost((<span class="keyword">void</span>**)&amp;a, bytes) );      <span class="comment">// host pinned</span></span><br><span class="line">  checkCuda( cudaMalloc((<span class="keyword">void</span>**)&amp;d_a, bytes) );    <span class="comment">// device</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> ms; <span class="comment">// elapsed time in milliseconds</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// create events and streams</span></span><br><span class="line">  cudaEvent_t startEvent, stopEvent, dummyEvent;</span><br><span class="line">  cudaStream_t stream[nStreams];</span><br><span class="line">  checkCuda( cudaEventCreate(&amp;startEvent) );</span><br><span class="line">  checkCuda( cudaEventCreate(&amp;stopEvent) );</span><br><span class="line">  checkCuda( cudaEventCreate(&amp;dummyEvent) );</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nStreams; ++i)</span><br><span class="line">    checkCuda( cudaStreamCreate(&amp;stream[i]) );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// baseline case - sequential transfer and execute</span></span><br><span class="line">  <span class="built_in">memset</span>(a, <span class="number">0</span>, bytes);</span><br><span class="line">  checkCuda( cudaEventRecord(startEvent,<span class="number">0</span>) );</span><br><span class="line">  checkCuda( cudaMemcpy(d_a, a, bytes, cudaMemcpyHostToDevice) );</span><br><span class="line">  kernel&lt;&lt;&lt;n/blockSize, blockSize&gt;&gt;&gt;(d_a, <span class="number">0</span>);</span><br><span class="line">  checkCuda( cudaMemcpy(a, d_a, bytes, cudaMemcpyDeviceToHost) );</span><br><span class="line">  checkCuda( cudaEventRecord(stopEvent, <span class="number">0</span>) );</span><br><span class="line">  checkCuda( cudaEventSynchronize(stopEvent) );</span><br><span class="line">  checkCuda( cudaEventElapsedTime(&amp;ms, startEvent, stopEvent) );</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Time for sequential transfer and execute (ms): %f\n"</span>, ms);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"  max error: %e\n"</span>, maxError(a, n));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// asynchronous version 1: loop over &#123;copy, kernel, copy&#125;</span></span><br><span class="line">  <span class="built_in">memset</span>(a, <span class="number">0</span>, bytes);</span><br><span class="line">  checkCuda( cudaEventRecord(startEvent,<span class="number">0</span>) );</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nStreams; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> offset = i * streamSize;</span><br><span class="line">    checkCuda( cudaMemcpyAsync(&amp;d_a[offset], &amp;a[offset], </span><br><span class="line">                               streamBytes, cudaMemcpyHostToDevice, </span><br><span class="line">                               stream[i]) );</span><br><span class="line">    kernel&lt;&lt;&lt;streamSize/blockSize, blockSize, <span class="number">0</span>, stream[i]&gt;&gt;&gt;(d_a, offset);</span><br><span class="line">    checkCuda( cudaMemcpyAsync(&amp;a[offset], &amp;d_a[offset], </span><br><span class="line">                               streamBytes, cudaMemcpyDeviceToHost,</span><br><span class="line">                               stream[i]) );</span><br><span class="line">  &#125;</span><br><span class="line">  checkCuda( cudaEventRecord(stopEvent, <span class="number">0</span>) );</span><br><span class="line">  checkCuda( cudaEventSynchronize(stopEvent) );</span><br><span class="line">  checkCuda( cudaEventElapsedTime(&amp;ms, startEvent, stopEvent) );</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Time for asynchronous V1 transfer and execute (ms): %f\n"</span>, ms);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"  max error: %e\n"</span>, maxError(a, n));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// asynchronous version 2: </span></span><br><span class="line">  <span class="comment">// loop over copy, loop over kernel, loop over copy</span></span><br><span class="line">  <span class="built_in">memset</span>(a, <span class="number">0</span>, bytes);</span><br><span class="line">  checkCuda( cudaEventRecord(startEvent,<span class="number">0</span>) );</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nStreams; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> offset = i * streamSize;</span><br><span class="line">    checkCuda( cudaMemcpyAsync(&amp;d_a[offset], &amp;a[offset], </span><br><span class="line">                               streamBytes, cudaMemcpyHostToDevice,</span><br><span class="line">                               stream[i]) );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nStreams; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> offset = i * streamSize;</span><br><span class="line">    kernel&lt;&lt;&lt;streamSize/blockSize, blockSize, <span class="number">0</span>, stream[i]&gt;&gt;&gt;(d_a, offset);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nStreams; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> offset = i * streamSize;</span><br><span class="line">    checkCuda( cudaMemcpyAsync(&amp;a[offset], &amp;d_a[offset], </span><br><span class="line">                               streamBytes, cudaMemcpyDeviceToHost,</span><br><span class="line">                               stream[i]) );</span><br><span class="line">  &#125;</span><br><span class="line">  checkCuda( cudaEventRecord(stopEvent, <span class="number">0</span>) );</span><br><span class="line">  checkCuda( cudaEventSynchronize(stopEvent) );</span><br><span class="line">  checkCuda( cudaEventElapsedTime(&amp;ms, startEvent, stopEvent) );</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Time for asynchronous V2 transfer and execute (ms): %f\n"</span>, ms);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"  max error: %e\n"</span>, maxError(a, n));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cleanup</span></span><br><span class="line">  checkCuda( cudaEventDestroy(startEvent) );</span><br><span class="line">  checkCuda( cudaEventDestroy(stopEvent) );</span><br><span class="line">  checkCuda( cudaEventDestroy(dummyEvent) );</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nStreams; ++i)</span><br><span class="line">    checkCuda( cudaStreamDestroy(stream[i]) );</span><br><span class="line">  cudaFree(d_a);</span><br><span class="line">  cudaFreeHost(a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/28/CUDA-overlap-data-transfer/" data-id="ck5bbuogs001xa2fz24us9cl2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CUDA/" rel="tag">CUDA</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CUDA/">CUDA</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hardware/">Hardware</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linear-Algebra/">Linear Algebra</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Utility/">Utility</a><span class="category-list-count">7</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CUDA/" rel="tag">CUDA</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hardware/" rel="tag">hardware</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithms/" style="font-size: 15px;">Algorithms</a> <a href="/tags/CUDA/" style="font-size: 20px;">CUDA</a> <a href="/tags/hardware/" style="font-size: 10px;">hardware</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/01/">January 1970</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/17/CUDA-%E4%BC%98%E5%8C%96%E4%BC%98%E5%85%88%E7%BA%A7/">CUDA-优化优先级</a>
          </li>
        
          <li>
            <a href="/2020/01/15/CUDA-Memory-Optimization-Local-Memory/">CUDA-Memory Optimization-Local Memory</a>
          </li>
        
          <li>
            <a href="/2020/01/15/CUDA-Memory-Optimization-Shared-Memory/">CUDA-Memory Optimization-Shared Memory</a>
          </li>
        
          <li>
            <a href="/2020/01/14/CUDA-APOD-Strong-Scaling-Weak-Scaling/">CUDA-APOD Strong-Scaling Weak-Scaling</a>
          </li>
        
          <li>
            <a href="/2020/01/13/Computer-Composition/">Computer Composition</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Junhui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>