<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Junhui&#39;s Journal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Junhui&#39;s Journal">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="Junhui&#39;s Journal">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Junhui">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Junhui&#39;s Journal" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junhui&#39;s Journal</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-回顾cpp-多态-二-虚函数表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/29/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%BA%8C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/" class="article-date">
  <time datetime="2019-08-29T04:41:49.000Z" itemprop="datePublished">2019-08-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/29/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%BA%8C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/">回顾cpp-多态-虚函数表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>封装-&gt;继承-&gt;多态</p>
<ul>
<li>普通虚函数 check</li>
<li>虚析构函数 check</li>
<li>纯虚函数 </li>
<li>抽象类</li>
<li>接口类</li>
<li>RTTI</li>
<li>异常处理 </li>
<li>隐藏 覆盖    check</li>
<li>早绑定 晚绑定  check</li>
<li>虚函数表     check</li>
</ul>
<h1 id="虚函数实现原理"><a href="#虚函数实现原理" class="headerlink" title="虚函数实现原理"></a>虚函数实现原理</h1><p>虚函数实现原理是</p>
<p>函数指针：</p>
<ul>
<li>对象指针—&gt;指针指向对象</li>
<li>函数指针—&gt;指针指向函数</li>
</ul>
<p>函数存在内存中，可以通过指针指向这段代码的开头，那么函数就会从头一直向下执行。如图：</p>
<div align="center"><img src="/2019/08/29/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%BA%8C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/func-ptr.png" width="600"></div>

<p>比如可以通过<code>Func1_ptr</code> 得到<code>fun3()</code>函数入口，并开始执行。函数指针与普通指针一样，存储着内存的地址，这个地址就是函数的首地址。</p>
<hr>
<p>虚函数实现原理是<strong>虚函数表指针</strong>。假如有两个类<code>Shape</code>和<code>Circle</code>类：<br>父类<code>Shape</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape()&#123;&#125;   <span class="comment">// virtual 析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>&#123;  <span class="comment">// 虚函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_iEdge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，当<strong>实例化一个<code>Shape</code>对象</strong>时，<strong>此<code>Shape</code>对象中包含如下左侧内容</strong>：</p>
<div align="center"><img src="/2019/08/29/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%BA%8C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/vftable1.png" width="600"></div>

<p>此<code>Shape对象</code>中，除了<code>m_iEdge</code>外，还有一个成员<strong>vftable_ptr</strong>，<strong>称为虚函数表指针</strong>。</p>
<ol>
<li>这个指针指向一个虚函数表，此<font color="red">虚函数表与Shape类的定义同时出现</font>。</li>
<li>此表占空间，从起始位置<code>0xCCFF</code>处开始，也就是<code>vftable_ptr</code>这里存储内容为<code>0xCCFF</code>。</li>
<li><font color="red">此表只有一个</font>，通过Shape实例化出的<strong>所有对象</strong>都指向<strong>同一个</strong>虚函数表，即所有通过<code>Shape</code>实例化的对象，其<code>vftable_ptr</code>都存储<code>0xCCFF</code>。也就是说每一个实例的<code>vftable_ptr</code>都指向<strong>Shape类</strong>的虚函数表。言外之意，<font color="red">虚函数表属于类，而非类对象</font>。</li>
</ol>
<p>在父类<code>Shape</code>的虚函数表中一定定义了一个函数指针：<code>calcArea_ptr</code>，它是<code>calcArea</code>函数入口地址，即<code>calcArea_ptr</code>中存储<code>0x3355</code>（<code>0x3355</code>是<code>Shape类</code>中<code>calcArea</code>函数地址）。调用<code>calcArea</code>时，先通过<code>vftable_ptr</code> 找到虚函数表，再通过位置偏移找到虚函数的入口地址，从而最终找到<code>calcArea</code>计算面积。</p>
<hr>
<p>上述过程实例化Shape父类对象。<br>当定义了子类Circle：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape&#123;   <span class="comment">// 共有继承Shape</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> r);</span><br><span class="line">    <span class="comment">// 没有自己的calcArea</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_dR;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意Circle中并没有<code>calcArea()</code>函数，也就说，<strong>Circle使用Shape类的<code>calcArea</code>计算面积</strong>。<br>当实例化<code>Circle</code>子类对象后。此<code>Circle</code>对象中存储的内容如下：</p>
<div align="center"><img src="/2019/08/29/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%BA%8C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/vftable-2.png" width="600"></div>

<p>因为<code>Circle</code>中没有定义虚函数，但它从父类中继承了虚函数<code>calcArea</code>，所以在实例化一个<code>Circle</code>对象时，也会产生一个虚函数表（<font color="red">这个虚拟性是从父类继承过来的</font>）。注意<strong>此虚函数表是Circle类自己的虚函数表，起始地址为<code>0x6688</code></strong>，而Shape类的虚函数表起始地址是<code>0xCCFF</code>。但是<code>Circle</code>虚函数表中计算面积的指针<code>calcArea_ptr</code>是一样的，都存储<code>0x3355</code>（因为是继承过来的）。<br><br>这就能够保证在<code>Circle</code>中访问父类Shape的<code>calcArea</code>时，也能够通过虚函数表指针找到自己的虚函数表，从而找到父类Shape的<code>calcArea</code>。</p>
<hr>
<p>如果子类Circle定义中定义了自己的<code>calcArea</code>函数，即子类的<code>calcArea</code>有自己的函数地址<code>0x4B2C</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape&#123;   <span class="comment">// 共有继承Shape</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> r);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calcAera</span><span class="params">()</span></span>;   <span class="comment">// 定义了自己的calcArea，覆盖父类calcArea</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_dR;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当实例化一个Circle类对象时，Shape类没有任何变化(当然，父类不会因为子类的变化而改变呀！)，但是Circle会有变化：如图：</p>
<div align="center"><img src="/2019/08/29/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%BA%8C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/vftable-3.png" width="600"></div>

<p><code>Circle</code>虚函数表是一样的(即表地址是一样的)，但是因为<code>Circle</code>自己定义了自己的<code>calcArea</code>方法，所以<code>calcArea_ptr</code>所指向的也是Circle自己的<code>calcArea</code>地址<code>0x4B2C</code>，换句话说，原先<code>calcArea_ptr</code>中父类的<code>calcArea</code>地址被Circle自己的<code>calcArea</code>地址<strong>覆盖</strong>。所以，此时如果使用Shape的指针指向Circle的对象，执行子类的虚函数<code>calcArea</code>。这便是virtual的功能</p>
<p>上述过程就是<font color="red">多态原理</font>。</p>
<h1 id="函数的覆盖与隐藏"><a href="#函数的覆盖与隐藏" class="headerlink" title="函数的覆盖与隐藏"></a>函数的覆盖与隐藏</h1><ul>
<li><p><strong>覆盖</strong>即上述过程：</p>
<p>  当Circle没有自己的<code>calcArea()</code>时，Circle的虚函数表中<code>calcArea_ptr</code>存的是<code>0x3355</code>，即父类<code>calcArea()</code>的地址。</p>
<p>  当Circle有自己的<code>calcArea()</code>时，Circle的虚函数表中<code>calcArea_ptr</code>存的是<code>0x4B2C</code>，即子类自己的<code>calcArea()</code>的地址。<br>  此时虚函数表中，<strong>子类的虚函数地址覆盖父类虚函数地址</strong>。</p>
</li>
<li><p><strong>隐藏</strong>与多态无关：</p>
<p>  与多态（virtual）无关，即当父类子类中没有<code>virtual</code>虚函数时，也就是说这个类我不希望他有多塔的性质，父类子类出现了同名函数，且<font color="red" size="4">父类指针</font>分别指向<font color="red" size="4">子类对象</font>，父类同名函数隐藏了子类同名函数。（毕竟这个子类对象类型是父类，回顾<a href="https://ashburnlee.github.io/categories/C/" target="_blank" rel="noopener">继承篇</a>）</p>
</li>
</ul>
<p><font color="gree" size="5">敲黑板</font>首先判断需不需要这个父类有多态的性质，如果需要，这个父类中一定要有virtual函数，才会有虚函数表。虚函数表属于类，而非对象。</p>
<h1 id="虚析构函数原理"><a href="#虚析构函数原理" class="headerlink" title="虚析构函数原理"></a>虚析构函数原理</h1><p>回顾上一篇笔记，当父类中<strong>析构函数</strong>都为<strong>virtual析构函数</strong>时，通过父类指针指向子类对象，最后通过<code>delete</code> 接父类指针就可以，先执行子类析构函数紧接着执行父类析构函数。这个过程与<strong>虚函数表</strong>有关。</p>
<p>强调一下前提：先执行子类析构函数紧接着执行父类析构函数（也就是说通过父类指针执行到了子类的析构函数，这就是为什么先执行子类析构函数）</p>
<p>在父类Shape中加上虚虚析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcAera</span><span class="params">()</span></span>&#123;  <span class="comment">// 虚函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape()&#123;&#125;        <span class="comment">// 虚析构函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_iEdge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>定义子类，写上子类虚析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape&#123;   <span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> r)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcAera</span><span class="params">()</span></span>&#123;&#125;;   </span><br><span class="line">    <span class="keyword">virtual</span> ~Circle()&#123;&#125;;         <span class="comment">// 子类虚析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_dR;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时用父类指针指向子类对象，且delete接父类指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Shape* shape = <span class="keyword">new</span> Circle(<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape;</span><br><span class="line">    shape = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚函数表如何工作：</p>
<div align="center"><img src="/2019/08/29/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%BA%8C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/vftable-4.png" width="600"></div>

<p>当在Shape中定义了虚析构函数，Shape类的虚函数表中就会有一个Shape类的虚函数指针<code>～Shape_ptr</code>（指向父类析构函数），</p>
<div align="center"><img src="/2019/08/29/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%BA%8C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/vftable-5.png" width="600"></div>

<p>同时在Circle类中也会产生一个子类析构函数的函数指针<code>～Circle_ptr</code>（指向子类析构函数）。注意上述<strong>两个析构函数指针同时出现</strong>。</p>
<p>如果使用Shape的指针指向Circle的对象，执行子类的虚函数calcArea。<font color="red">当delete接Shape指针时，<strong>通过Shape找到Circle类的vftable_ptr</strong>（Shape类指针指向Circle类对象），进而找到虚函数表，最后找到Circle类的析构函数，从而使得Circle类析构函数得意执行。最后执行Shape类析构函数</font>。</p>
<p>{有疑惑，父类指针指向子类对象，会执行子类虚函数？（delete父类的指针时，程序会去找父类的指针指向的地址，该地址就是子类头部虚函数表指针的地址，进而找到子类虚函数表，最后执行子类析构函数） delete时，发生了什么？回顾<a href="https://ashburnlee.github.io/categories/C/" target="_blank" rel="noopener">继承篇</a>}  </p>
<h1 id="现实中的虚函数"><a href="#现实中的虚函数" class="headerlink" title="现实中的虚函数"></a>现实中的虚函数</h1><p>明确概念：</p>
<ol>
<li>对象的大小：实例化对象中数据成员所占内存大小，（不包括成员函数）。</li>
<li>对象的地址：通过类实例化一个对象，这个对象的所占的内存单元的首地址。</li>
<li>对象成员的地址：一个对象中每一个成员所占据的地址。因为每个成员的数据类型不同，所以占用不同大小的内存。</li>
<li>虚函数表指针：当实例化一个对象后，这个对象的第一个内存中所存储的指针，这个指针就是虚函数表的指针。就是上述所有的<code>vftable_ptr</code>。可以根据这个特点，通过计算对象的大小来证明虚函数表示的存在。</li>
</ol>
<h2 id="当没有virtual时"><a href="#当没有virtual时" class="headerlink" title="当没有virtual时"></a>当没有virtual时</h2><p>假如有两个类：</p>
<p>父类Shape：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span>   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape()&#123;&#125;</span><br><span class="line">    ~Shape()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Shape-&gt;calc area"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>子类Circle：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">int</span> r)&#123; m_iR = r; &#125;</span><br><span class="line">    ~Circle()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_iR;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shape shape;                  <span class="comment">// 实例化一个对象</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(shape)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">// 该对象的大小</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;shape;        <span class="comment">// 该对象的地址</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;                <span class="comment">// 对象起始地址</span></span><br></pre></td></tr></table></figure>

<p>结果1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1                 // 对于一个数据成员都没有的类对象，c++ 用一个内存单元来标记它。 </span><br><span class="line">0x7fff478ce38f    // 对象起始地址</span><br></pre></td></tr></table></figure>

<p>执行2：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Circle <span class="title">circle</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(circle)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span>* q= (<span class="keyword">int</span>*)&amp;circle;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;q&lt;&lt;<span class="built_in">endl</span>;         <span class="comment">// 指针q中内容</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(*q)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 指针q中内容的内容</span></span><br></pre></td></tr></table></figure>

<p>结果2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4                  // int 型数据占4个内存单元</span><br><span class="line">0x7ffdca8b3e20    // 对象起始地址</span><br><span class="line">100               // 起始地址中的内容</span><br></pre></td></tr></table></figure>
<h2 id="当有virtual时"><a href="#当有virtual时" class="headerlink" title="当有virtual时"></a>当有virtual时</h2><p>父类与子类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape()&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>&#123; &#125; <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">int</span> r)&#123; m_iR = r; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Circle()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_iR;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Shape shape;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(shape)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;shape;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(*p)&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line"></span><br><span class="line"><span class="function">Circle <span class="title">circle</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span>* q= (<span class="keyword">int</span>*)&amp;circle;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(*q)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">q++;   </span><br><span class="line">q++;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(*q)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8              </span><br><span class="line">4198160</span><br><span class="line">4198120</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<p>shape对象大小是<code>8</code>，Shape类对象地址中第一个内容是虚函数表地址<code>4198160</code>；<br>Circle类对象地址中的第一个内容是虚函数表地址<code>4198120</code>，之后移动指针2次，便是存储数据成员100的位置。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/29/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%BA%8C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/" data-id="ckatsrguz0080xqfzdwbd4ixm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-回顾cpp-多态-一-虚函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/28/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%B8%80-%E8%99%9A%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2019-08-28T04:38:51.000Z" itemprop="datePublished">2019-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/28/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%B8%80-%E8%99%9A%E5%87%BD%E6%95%B0/">回顾cpp-多态-虚函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>封装-&gt;继承-&gt;多态</p>
<ul>
<li>普通虚函数 </li>
<li>虚析构函数  check</li>
<li>纯虚函数</li>
<li>抽象类</li>
<li>接口类</li>
<li>RTTI</li>
<li>异常处理 </li>
<li>隐藏 覆盖 </li>
<li>早绑定 晚绑定 check</li>
<li>虚函数表 </li>
</ul>
<h1 id="静态多态（早绑定）"><a href="#静态多态（早绑定）" class="headerlink" title="静态多态（早绑定）"></a>静态多态（早绑定）</h1><p>函数重构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calcArea</span><span class="params">(<span class="keyword">int</span> width)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calcAera</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Rect rect;</span><br><span class="line">    rect.calcAera(<span class="number">10</span>);</span><br><span class="line">    rect.calcAera(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序在运行之前，在编译阶段就已经确定下来要使用哪个<code>calsAera()</code>函数了。很早地就将函数编译进去了。此情况叫做<font color="green">早绑定</font>，即<font color="green">静态多态</font>。</p>
<h1 id="动态多态（晚绑定）"><a href="#动态多态（晚绑定）" class="headerlink" title="动态多态（晚绑定）"></a>动态多态（晚绑定）</h1><p>不同的对象下达相同的指令，做着不同的操作，为动态多态。有前提的：它必须以封装，继承为基础。</p>
<p>也就是说，有了封装继承之后，才能谈动态多态。动态多态至少由两个类，父子类，三个类时动态多态才表现的更加明显。</p>
<p>注意只有当一个类需要有多态的的性质时，才体现多态。此时的<code>base classes</code>需要将其析构函数声明为<code>virtual</code>。当没有声明<code>virtual</code>时，看下例：</p>
<p>父类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape()&#123;&#125;</span><br><span class="line">    ~Shape()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"~Shape()"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>&#123;                  <span class="comment">// 不是虚函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Shape-&gt;calc area"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>子类Circle：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> r)&#123;</span><br><span class="line">        m_dR = r;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Circle()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"~Circle()"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>&#123;                 <span class="comment">// 不是虚函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span>*m_dR*m_dR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_dR;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>子类Rect：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rect(<span class="keyword">double</span> width, <span class="keyword">double</span> height)&#123;</span><br><span class="line">        m_dWidth = width;</span><br><span class="line">        m_dHeight = height;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Rect()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"~Rect()"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calcAera</span><span class="params">()</span></span>&#123;                  <span class="comment">// 不是虚函数</span></span><br><span class="line">        <span class="keyword">return</span> m_dHeight*m_dWidth;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_dWidth;</span><br><span class="line">    <span class="keyword">double</span> m_dHeight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>含有多态性质的<code>base class</code>的设计目的是为了通过<code>base class</code>的接口来使用<code>derived class</code>，所以，如果用两个<font color="red" size="4">base class指针</font>分别指向<font color="red" size="4">两个不同derived class</font>，后分别调用两个<code>derived class</code>的计算面积方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Shape *shape1 = <span class="keyword">new</span> Circle(<span class="number">1.0</span>);     <span class="comment">// 父类指针指向子类对象</span></span><br><span class="line">Shape *shape2 = <span class="keyword">new</span> Rect(<span class="number">3.0</span>, <span class="number">5.0</span>);  <span class="comment">// 父类指针指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;shape1-&gt;calcArea()&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;shape2-&gt;calcArea()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> shape1;</span><br><span class="line">shape1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> shape2;</span><br><span class="line">shape2 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>结果并不是我们想要的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shape-&gt;calc area    <span class="comment">//  调用父类方法</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">Shape-&gt;calc area    <span class="comment">// 调用父类方法</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">~Shape()     <span class="comment">// 调用父类析构函数</span></span><br><span class="line">~Shape()     <span class="comment">// 调用父类析构函数</span></span><br></pre></td></tr></table></figure>
<p>都调用了父类的<code>calcArea()</code>方法。且都调用了父类的析构函数。此现象称为<font color="green">隐藏</font>.</p>
<p><font color="red">WHY</font>：我们不希望这样，我们希望通过父类指针可以调用子类的方法。如何解决？使用<code>virtual</code> 关键字。</p>
<hr>
<p>解决方法：在父类中想要实现多态的函数前加virtual，同时在子类的相同函数前也加上<code>virtual</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>&#123;         <span class="comment">// 虚函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"calc area..."</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>&#123;         <span class="comment">//  虚函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span>*m_dR*m_dR;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>&#123;       <span class="comment">// 虚函数</span></span><br><span class="line">        <span class="keyword">return</span> m_dHeight*m_dWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span>     <span class="comment">// 调用Circle 的方法</span></span><br><span class="line"><span class="number">15</span>       <span class="comment">// 调用Rect 的方法</span></span><br><span class="line">~Shape()    <span class="comment">// 只调用父类析构函数</span></span><br><span class="line">~Shape()</span><br></pre></td></tr></table></figure>

<p>只有base class的同名函数被声明为virtual。</p>
<p>很自然的情况是：当使用<font color="red" size="4">derived class指针</font>指向<font color="red" size="4">derived class对象</font>时，不管是不是<code>virtual</code>，都会由正确执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Circle *circle1 = <span class="keyword">new</span> Circle(<span class="number">1.0</span>);</span><br><span class="line">Rect *rect1 = <span class="keyword">new</span> Rect(<span class="number">3.0</span>, <span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> circle1;</span><br><span class="line">circle1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> rect1;</span><br><span class="line">rect1 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line">~Circle()    <span class="comment">// 既调用子类析构函数</span></span><br><span class="line">~Shape()     <span class="comment">// 又调用父类析构函数</span></span><br><span class="line">~Rect()</span><br><span class="line">~Shape()</span><br></pre></td></tr></table></figure>

<p><font color="grenn" size="6">敲黑板</font></p>
<ul>
<li>父类子类要实现多态的方法前，父类要声明为<code>virtual</code>。</li>
<li>当父类的析构函数不是虚函数时，类指针指向子类对象时，只调用父类析构函数。</li>
<li>当父类的析构函数不是虚函数时，<code>delete</code> 后跟父类指针，只执行父类析构函数，如果<code>delete</code> 后跟子类指针，执行父类和子类析构函数。</li>
<li>只将要作为父类的类的析构函数声明为<code>virtual</code>。</li>
</ul>
<h1 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h1><p>为啥要有虚析构函数？如果要将这个class作为基类而且是有多态性质的基类，应该把其析构函数定义成<code>virtual</code>！看以下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">        m_pCenter = <span class="keyword">new</span> Coordinate(x, y)   <span class="comment">// 2.实例化一个坐标对象</span></span><br><span class="line">        m_dR = r;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Circle()&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_pCenter;                 <span class="comment">// 3.释放坐标对象</span></span><br><span class="line">        m_pCenter = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span>*m_dR*m_dR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_dR;</span><br><span class="line">    Coordinate* m_pCenter;      <span class="comment">// 1.多一个坐标类属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在析构函数中释放了坐标对象，不会内存泄露。可是！<br>在多态时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Shape *shape1 = <span class="keyword">new</span> Circle(<span class="number">1.0</span>);    </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;shape1-&gt;calcArea()&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> shape1;      <span class="comment">// 使用父类指针销毁子类对象</span></span><br><span class="line">shape1 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>使用父类指针销毁子类对象时，<strong>只调用了父类析构函数<code>~Shape()</code>，而子类<code>~Circle()</code>未被调用。坐标对象不会被释放，此时</strong>内存泄漏。<strong>这就不合理了，虚构函数设计就是要被执行的</strong></p>
<p>如何解决？<br>虚析构函数！在父类的析构函数前加<code>virtual</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~Shape()&#123;            <span class="comment">// 虚析构</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Circle()&#123;           </span><br><span class="line">    <span class="keyword">delete</span> m_pCenter;                 <span class="comment">// 释放坐标对象</span></span><br><span class="line">    m_pCenter = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，使用父类指针销毁子类对象时，<strong>既调用了父类析构函数<code>~Shape()</code>，又调用子类<code>~Circle()</code></strong>。父类子类的析构函数都被执行。情理上就对了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape()&#123;   <span class="comment">//  虚</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"~Shape()"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Circle()&#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"~Circle()"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    ~Rect()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"~Rect()"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>父类子类的析构函数都被执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    Shape *shape1 = <span class="keyword">new</span> Circle(<span class="number">1.0</span>);</span><br><span class="line">    Shape *shape2 = <span class="keyword">new</span> Rect(<span class="number">3.0</span>, <span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">OUTPUT：</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line">~Circle()</span><br><span class="line">~Shape()</span><br><span class="line">~Rect()</span><br><span class="line">~Shape()</span><br></pre></td></tr></table></figure>

<p><strong>执行完子类虚析构函数，再执行父类虚析构函数。</strong></p>
<h2 id="virtual使用限制"><a href="#virtual使用限制" class="headerlink" title="virtual使用限制"></a>virtual使用限制</h2><ul>
<li><p>普通函数不能是虚函数</p>
</li>
<li><p>不能修饰静态成员函数</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>; </span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></li>
<li><p>不能修饰<code>inline</code>函数，如果这么做了，计算机会忽略<code>inline</code>关键字，使之成为虚函数。</p>
</li>
<li><p>不能修饰构造函数。</p>
</li>
</ul>
<p><font color="grenn" size="6">敲黑板</font><br>任何时候都应该为含有多态性质的基类（父类）声明<code>virtual</code>析构函数。如果一个class含有任何<code>virual</code>函数，就一定要有一个<code>virtual</code>析构函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/28/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%B8%80-%E8%99%9A%E5%87%BD%E6%95%B0/" data-id="ckatsrgsx004txqfzb6d14v9o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-方法论-数组相关-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/25/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%80/" class="article-date">
  <time datetime="2019-08-24T18:28:14.000Z" itemprop="datePublished">2019-08-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/25/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%80/">LeetCode-方法论-数组相关-一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>与数组相关的问题是最常出现的问题。<br>这篇笔记记录问题编号：<br>283, 167, 209, 75, 11, 125, 3</p>
<p><font color="gree" size="5">敲黑板</font><br>常用技术：</p>
<ul>
<li>计数排序，当元素种类较小时使用</li>
<li>对撞指针，当数据元素有序时使用</li>
<li>滑动串口，注意此窗口大小不一定固定</li>
<li>图示简化实现，有些情况下，画好了中间过程的图示，实现起来就像看图说话</li>
<li>循环不变量，保证程序正确性，并且使图示简化实现成为可能</li>
<li>更新记录，更新循环中的每一步结果</li>
<li>跳过，</li>
<li>频数记录，技巧 记录频数</li>
<li>大条件先满足，在if语句中，大小条件一定要在小条件之前</li>
</ul>
<p>实现时的注意：</p>
<ul>
<li>对边界的正确处理，明确循环不变量的定义且需要始终维护。</li>
<li>使用小数据集调试，先保证算法的正确性。</li>
<li>应尽量减少代码量，合并可以合并的，删掉无用的。经验上讲，同一个算法，代码量越多越容易出错。</li>
<li>先由算法过程，后实现，不要上来就实现。</li>
</ul>
<h1 id="283-Move-Zeros"><a href="#283-Move-Zeros" class="headerlink" title="#283 Move Zeros"></a>#283 Move Zeros</h1><ul>
<li><p>描述：给出一个序列，将所有0元素移动到序列尾部，并且其他元素相对位置不变。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路一：</p>
  <div align="center"><img src="/2019/08/25/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%80/array1.png"></div>

<p>  如图，整个过程保持[0,..,k)中元素非零。遍历结束后，将k及其以后的元素值设为0。就得到最后值。</p>
<p>  时间复杂度：O(N)<br>  空间复杂度：O(1)</p>
</li>
<li><p>思路二：</p>
  <div align="center"><img src="/2019/08/25/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%80/array3.png" width="800"></div>

<p>  将思路一中，当<code>nums[i]!=0</code>时，的执行改为 <code>swap(nums[i], nums[k++])</code>。如此不需要思路一的最后一步。</p>
<p>  时间复杂度：O(N)<br>  空间复杂度：O(1)</p>
</li>
<li><p>实现见<a href="https://github.com/AshburnLee/LeetCode" target="_blank" rel="noopener">这里</a>，的对应文件。</p>
</li>
</ul>
<p>关键：<font color="red" size="4">协调两指针</font></p>
<h1 id="167-Two-Sum-II-对撞指针"><a href="#167-Two-Sum-II-对撞指针" class="headerlink" title="#167 Two Sum II 对撞指针"></a>#167 Two Sum II 对撞指针</h1><ul>
<li><p>问题描述：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>
<p>  当数组有序时使用对撞指针。<br>  <code>number[0+1] + number[1+1] = target</code>.</p>
</li>
<li><p>思路：</p>
<pre><code>一个指针`i`从左端向右，另一个指针`j`从右端向左。
如果`number[i] + mumber[j] = target` 时，返回对应的`i+1, j+1`。
如果`number[i] + number[j] &lt; target`, 说明`number[i]`小，所以`i++`；
如果`number[i] + number[j] &gt; taregt`, 说明`number[j]`大，所以`j--`；</code></pre></li>
<li><p>实现见<a href="https://github.com/AshburnLee/LeetCode" target="_blank" rel="noopener">这里</a>，的对应文件。</p>
</li>
<li><p>同类问题：<br>345</p>
</li>
</ul>
<h1 id="209-Minimum-Size-Subarray-Sum-滑动窗口"><a href="#209-Minimum-Size-Subarray-Sum-滑动窗口" class="headerlink" title="#209 Minimum Size Subarray Sum  滑动窗口"></a>#209 Minimum Size Subarray Sum  滑动窗口</h1><ul>
<li><p>问题描述：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: the subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure></li>
<li><p>思路</p>
<p>  设置窗口左右端，并且初始化：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  l=<span class="number">0</span>, r=<span class="number">-1</span>  <span class="comment">//始终保证nums[l,...,r]为滑动窗口，初始化为空</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = nums.size()<span class="number">-1</span>  <span class="comment">// 结果设置为可能的最大值</span></span><br></pre></td></tr></table></figure>

<p>  然后窗口向右移动，移动过程中要判断两次：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; nums.size())&#123;</span><br><span class="line">    <span class="comment">// 第一次判断</span></span><br><span class="line">    <span class="keyword">if</span> (r+<span class="number">1</span> &lt; nums.size() &amp;&amp; sum &lt; s)</span><br><span class="line">        sum += nums[++r];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sum -= nums[l++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次判断</span></span><br><span class="line">    <span class="keyword">if</span> (sum&gt;s)</span><br><span class="line">        res = min(res, r-l+<span class="number">1</span>);  <span class="comment">// 更新结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  循环中:</p>
<pre><code>第一次判断:
    如果r没有到头，且sum小于s：则r右移，sum加上此时的nums[r]。
    如果r到最右边，或sum大于等于s：则Sum减去nums[l]，且l右移。
第二次判断:
    如果sum大于等于s，
    结果res取这次res和上次res的最小值。

最后一步，判断，如果res扔等于初始值，即没有发生变化，则表示sum中所有元素和都小于s。返回0.</code></pre><p>  第一次判断的两种情况：</p>
  <div align="center"><img src="/2019/08/25/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%80/win.png" width="700"></div>

</li>
</ul>
<p>关键：<font color="red" size="4">图示简化实现</font>，<font color="red" size="4">循环不变量</font>，<font color="red" size="4">更新记录</font>，<font color="red" size="4">滑动窗口</font>，<font color="red" size="4">大条件先满足</font></p>
<h1 id="75-Sort-Colors-三路快排"><a href="#75-Sort-Colors-三路快排" class="headerlink" title="#75 Sort Colors 三路快排"></a>#75 Sort Colors 三路快排</h1><ul>
<li><p>问题描述：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个数组由n个元素，元素只有0,1,2三种数值，为这个数组排序</span><br></pre></td></tr></table></figure></li>
<li><p>思路</p>
<ol>
<li><p>思路一： 计数排序</p>
<p> 先统计每个数值出现过多少次，之后从小到大将对应的值放入元素组，放入多少个呢，放入对应数值出现的次数个。实现：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;   </span><br><span class="line">    <span class="keyword">if</span> (nums.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录每个数值出现的频数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">        count[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挨个儿放入元素组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count[<span class="number">0</span>]; i++)</span><br><span class="line">        nums[index++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count[<span class="number">1</span>]; i++)</span><br><span class="line">        nums[index++] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count[<span class="number">2</span>]; i++)</span><br><span class="line">        nums[index++] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 很容易理解。</p>
</li>
<li><p>思路二： 三路快排</p>
<p> 初始化函数操作，</p>
 <div align="center"><img src="/2019/08/25/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%80/xxx.png" , width="700"></div>

 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zero = <span class="number">-1</span>;         <span class="comment">// 定义[0,...,zero] 的元素为0</span></span><br><span class="line">    <span class="keyword">int</span> two = nums.size();   <span class="comment">// 定义[two,...,n-1] 的元素为 3</span></span><br></pre></td></tr></table></figure>

<p> 明确循环不变量的定义 <code>zero：数组中元素为0的最后一个index</code>，<code>two：数组中元素为2的第一个index</code>。</p>
<p> 之后执行如下图的操作：</p>
 <div align="center"><img src="/2019/08/25/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%80/xxx.png" , width="700"></div>

 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;two; )&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)</span><br><span class="line">            swap(nums[--two], nums[i] );</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert( nums[i] == <span class="number">0</span> );</span><br><span class="line">            swap(nums[++zero], nums[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<p>关键：<font color="red" size="4">图示简化实现</font>，<font color="red" size="4">循环不变量</font></p>
<h1 id="11-Container-With-Most-Water-对撞指针"><a href="#11-Container-With-Most-Water-对撞指针" class="headerlink" title="#11 Container With Most Water 对撞指针"></a>#11 Container With Most Water 对撞指针</h1><ul>
<li><p>问题描述：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. </span><br><span class="line"></span><br><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路(无序数组求最值)：</p>
<p>  两指针分别从数组首位处开始，两个指针向中间移动，两指针的距离为<code>宽</code>，两指针对应的数值的较小值为<code>高度</code>，要最大化<code>宽度</code>x<code>高度</code>。注意两指针相互靠近，所以<code>宽度</code>是单调减小的，所以，要想记录最大值，就要跳过高度减小的值，即<code>i++</code>和<code>j++</code>。</p>
</li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化时，宽度是最大的</span></span><br><span class="line">    <span class="keyword">int</span> maxWater = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=height.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始对撞</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">int</span> h = min(height[i], height[j]);</span><br><span class="line">        maxWater = max(maxWater, h*(j-i));  <span class="comment">// 每次循环，更新最大值</span></span><br><span class="line">        <span class="keyword">while</span>(height[i]&lt;=h &amp;&amp; i&lt;j) i++;   <span class="comment">// h减小了，所以跳过</span></span><br><span class="line">        <span class="keyword">while</span>(height[j]&lt;=h &amp;&amp; i&lt;j) j--;   <span class="comment">// 跳过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxWater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键：<font color="red" size="4">两指针对撞</font>，<font color="red" size="4">跳过</font>，<font color="red" size="4">更新记录</font></p>
</li>
</ul>
<h1 id="125-PalineDrome-判断是否是回文"><a href="#125-PalineDrome-判断是否是回文" class="headerlink" title="#125 PalineDrome 判断是否是回文"></a>#125 PalineDrome 判断是否是回文</h1><ul>
<li><p>问题描述：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br><span class="line">Note: For the purpose of this problem, we define empty string as valid palindrome.</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>,r=s.length()<span class="number">-1</span>;l&lt;r; l++,r-- )&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isalnum</span>(s[l])==<span class="literal">false</span> &amp;&amp; l&lt;r) l++;  <span class="comment">//跳过 non alnum</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isalnum</span>(s[r])==<span class="literal">false</span> &amp;&amp; l&lt;r) r--;  <span class="comment">//跳过 non alnum</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[l]) != <span class="built_in">tolower</span>(s[r])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关键：<font color="red" size="4">两指针对撞</font>，<font color="red" size="4">跳过</font>，<font color="red" size="4">常用字符串函数</font></p>
<h1 id="3-Longest-Substring-Without-Repeating-Charactors-最长无重复子串"><a href="#3-Longest-Substring-Without-Repeating-Charactors-最长无重复子串" class="headerlink" title="#3 Longest Substring Without Repeating Charactors 最长无重复子串"></a>#3 Longest Substring Without Repeating Charactors 最长无重复子串</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">            Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路见图示：</p>
  <div align="center"><img src="/2019/08/25/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%80/leetcode_array_3.png" , width="400"></div>
</li>
<li><p>看图说话：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">// 记录频数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;    <span class="comment">// 滑动窗口保证s[l,...,r]始终无重复字符，初始化为空 </span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; s.size())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r+<span class="number">1</span>&lt;s.size() &amp;&amp; freq[s[r+<span class="number">1</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            freq[s[r]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">// r is out of bound || freq[r+1] == 1</span></span><br><span class="line">            freq[s[l]] --;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = max(res, r-l+<span class="number">1</span>);   <span class="comment">// 更新结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关键：<font color="red" size="4">图示简化实现</font>，<font color="red" size="4">循环不变量</font>，<font color="red" size="4">更新记录</font>，<font color="red" size="4">记录频数</font>，<font color="red" size="4">滑动窗口</font>，<font color="red" size="4">大条件先满足</font></p>
<hr>
<p><span style="font-family:Papyrus; font-size:2em">敲黑板</span>想要思维升级，就需要见足够多的问题类型，每种类型见过并解决不止一遍。只见过一遍就像完全掌握，是不实际的。见得多了，自然大脑就接受了，思维就升级了。另外一点，“回头看”会把之前不明白或者不能接受的问题“回锅”，可以增强大脑对这个问题的接纳程度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/25/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3-%E4%B8%80/" data-id="ckatsrgu4007ixqfzha512x3r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-方法论-回溯法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/22/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%9B%9E%E6%BA%AF%E6%B3%95/" class="article-date">
  <time datetime="2019-08-22T14:15:58.000Z" itemprop="datePublished">2019-08-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/22/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%9B%9E%E6%BA%AF%E6%B3%95/">LeetCode-方法论-回溯法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>46, 77, 40, 515, </p>
<ul>
<li>回溯法解决一类问题，排列与组合。</li>
<li>属于树型问题，所以通常需要画递归树。</li>
<li>通常需要有个容器来保存状态。</li>
<li>实现方法：理解问题，画递归树。</li>
<li>递归实现，需要“跳进跳出”的思维</li>
<li><font color="red" size="4">分清楚操作部分和结点移动部分</font></li>
<li>一个模式：<font color="red" size="4">移动控制+结点操作</font> 对上一条的强调</li>
</ul>
<h1 id="46"><a href="#46" class="headerlink" title="#46"></a>#46</h1><ul>
<li><p>描述</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给出一组不重复的整数，返回所有排列。如：</span><br><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>逻辑</p>
<p>  每一种排列包含3个元素，思路很直接：构建一棵树，树的结点表示形成的一个组合，叶节点表示一个完整的组合。过程中需要一个容器来记录每一个叶节点，即一个排列。还需要一个布尔型容器来记录已经处理过的元素。最后还需要一个容器记录所有找到的排列，即最终返回的结果。过程可以用一棵树的先序遍历完成：</p>
  <div align="center"><img src="/2019/08/22/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%9B%9E%E6%BA%AF%E6%B3%95/tree.png" width></div>

<p>  图中橘红色箭头表示程序执行过程。<font color="green" size="4">体会递归“跳进跳出”的执行方式，每到“触底反弹”，便体现了回溯的“回”，所有变量值均回到上一层</font>。递归算法很”整齐”，所有结点执行<strong>相同</strong>的操作。</p>
</li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// res 记录所有排列，最终返回res</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="comment">// used 记录检查过的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数找到一个排列, num是输入，index表示当前考察元素的Index，p表示逐渐形成的一个排列</span></span><br><span class="line"><span class="comment">// 向这个排列的末尾添加第index个元素，获得一个有Index个元素的排列。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPermutaion</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归到底的情况，所有元素都考察过之后。</span></span><br><span class="line">    <span class="keyword">if</span> (index == nums.size())&#123;</span><br><span class="line">        res.push_back(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以每一个元素作为这棵树的根：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">        <span class="comment">// 只有当元素没有考察过，才执行以下</span></span><br><span class="line">        <span class="keyword">if</span> (used[i] == <span class="literal">false</span>)&#123;</span><br><span class="line">            used[i] = <span class="literal">true</span>;        <span class="comment">//</span></span><br><span class="line">            p.push_back(nums[i]);   <span class="comment">// 把这个元素放入p中</span></span><br><span class="line">            getPermutaion(nums, index+<span class="number">1</span>, p);   <span class="comment">// 形成这棵树的子树</span></span><br><span class="line">            p.pop_back();    <span class="comment">// 这里体现了回溯的“回”，回到上一步</span></span><br><span class="line">            used[i]=<span class="literal">false</span>;   <span class="comment">// 回到上一步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    used = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(nums.size(), <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    getPermutaion(nums, <span class="number">0</span>, p);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="gree" size="5">敲黑板</font></p>
</li>
</ul>
<ol>
<li>思维：跳进跳出</li>
<li>实现：跳进跳“回”</li>
<li>明确(写出)结点函数的定义，并且保持整个过程定义不变。</li>
</ol>
<h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h1 id="77"><a href="#77" class="headerlink" title="#77"></a>#77</h1><ul>
<li><p>描述：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">从n个数中取k个数，一共有哪些组合：</span><br><span class="line">Input: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">[2,4],</span><br><span class="line">[3,4],</span><br><span class="line">[2,3],</span><br><span class="line">[1,2],</span><br><span class="line">[1,3],</span><br><span class="line">[1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>逻辑</p>
<p>  分析问题：<br>  开始，根节点中不存在任何值，它的子节点从1开始遍历，形成组合中的第一个值<code>[1], [2], [3], [4]</code>。<br>  当结点第一个值为<code>1</code>时，它的子节点从<code>2</code>开始向后遍历。形成的组合有<code>[1,2], [1,3], [1,4]</code>。<br>  当结点第一个值为<code>2</code>时，其子节点从<code>3</code>开始遍历。得到组合<code>[2,3], [2,4]</code>。<br>  当结点第一个值为<code>3</code>时，其子节点从<code>4</code>开始遍历。得到组合<code>[3,4]</code>。<br>  当结点第一个值为<code>4</code>时，<code>4</code>超过了索引<code>0~3</code>，返回到根节点。</p>
<p>  给出递归树：</p>
  <div align="center"><img src="/2019/08/22/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%9B%9E%E6%BA%AF%E6%B3%95/tree2.png"></div>
</li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// res保存所有的组合</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：从n个数中取k个数，把当前的数值放入c中，从Index开始向后查找：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generatCombination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当c的大小为2时，表示找到一个组合</span></span><br><span class="line">    <span class="keyword">if</span> (c.size()==k)&#123;</span><br><span class="line">        res.push_back(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index; i&lt;n; i++)&#123;</span><br><span class="line">        c.push_back(i);</span><br><span class="line">        <span class="comment">// 以当前结点为根，从index+1开始向后找：</span></span><br><span class="line">        generatCombination(n, k, index+<span class="number">1</span>, c);</span><br><span class="line">        c.pop_back();   <span class="comment">// 回溯的“回”，跳回上一层。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combination(<span class="keyword">int</span> n, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;k || n&lt;=<span class="number">0</span>||k&lt;=<span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="comment">// 从根节点开始，</span></span><br><span class="line">    generatCombination(n, k, <span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这个问题的实现中，在递归函数里的for循环，循环变量i与index有关，表示从Index后查找，这保证了，组合中元素无重复，且组合无重复。这也是与上一个问题不同之处。可以回过去看排列问题，其递归函数中for循环i与Index无关，表示，i每次从0开始查找，使得每个排列中元素不必只是递增，就是说像<code>[3,2,1]</code>，也是一个排列。</p>
</li>
</ul>
<p><font color="gree" size="5">敲黑板</font>体会递归函数中for循环循环变量与index有关，无关的不同。</p>
<h1 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="#40. Combination Sum II"></a>#40. Combination Sum II</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">[1,2,2],</span><br><span class="line">[5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路</p>
<p>  感觉上，需要回溯，所以先画出递归树：</p>
<p>  假设<code>candidate=[1,2,3,4,5]</code>, <code>target=5</code>。</p>
  <div align="center"><img src="/2019/08/22/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%9B%9E%E6%BA%AF%E6%B3%95/40.png"></div>
</li>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;   <span class="comment">// res中的每个元素</span></span><br><span class="line">    sort(candidates.begin(), candidates.end());</span><br><span class="line">    DFS(candidates, target, res, tmp ,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;res.begin(), res.end()&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个结点的操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target==<span class="number">0</span>)&#123;   <span class="comment">// 如果最后剩下为0，则表示找到一个sum为target</span></span><br><span class="line">        res.insert(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index; i&lt;candidates.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates[i]&lt;=target)&#123;</span><br><span class="line">            tmp.push_back(candidates[i]);</span><br><span class="line">            DFS(candidates, target-candidates[i], res, tmp, i+<span class="number">1</span>);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="gree" size="5">敲黑板</font>一定要<strong>先</strong>画递归树，<strong>后</strong>写code，试图从别人的code中画递归树，是很容易懵掉的。</p>
</li>
</ul>
<h1 id="515-Find-Largest-Value-in-Each-Tree-Row"><a href="#515-Find-Largest-Value-in-Each-Tree-Row" class="headerlink" title="#515 Find Largest Value in Each Tree Row"></a>#515 Find Largest Value in Each Tree Row</h1><ul>
<li><p>描述</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">You need to find the largest value in each row of a binary tree.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">        &#x2F; \</span><br><span class="line">        3   2</span><br><span class="line">    &#x2F; \   \</span><br><span class="line">    5   3   9 </span><br><span class="line"></span><br><span class="line">Output: [1, 3, 9]</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑</p>
<p>  先画二叉树，见下图。</p>
<p>  本质是二叉树的遍历，先序遍历，顺序为下图中<font color="pink" size="4">粉色</font>箭头。而对于每个结点的操作是下图中<font color="orange" size="4">橙色</font>箭头。每个操作改变的是res数组，根据res的长度与row的索引决定。</p>
  <div align="center"><img src="/2019/08/22/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%9B%9E%E6%BA%AF%E6%B3%95/515.png"></div>



</li>
</ul>
<ul>
<li><p>实现</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largestValues(TreeNode* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    DFS(root, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode* root, <span class="keyword">int</span> row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="comment">// operation ORANGE</span></span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (row &gt;= res.size())</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        res[row] = max(res[row], root-&gt;val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move PINK</span></span><br><span class="line">    DFS(root-&gt;left, row+<span class="number">1</span>, res);</span><br><span class="line">    DFS(root-&gt;right, row+<span class="number">1</span>, res);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关键： <font color="red" size="4">变量row的跳进跳出</font>,<font color="red" size="4">分清楚操作部分和结点移动部分</font></p>
<h1 id="17-Letter-Combinations-of-a-phone-number"><a href="#17-Letter-Combinations-of-a-phone-number" class="headerlink" title="#17 Letter Combinations of a phone number"></a>#17 Letter Combinations of a phone number</h1><h1 id="491-All-increasing-Sub-sequences"><a href="#491-All-increasing-Sub-sequences" class="headerlink" title="#491 All increasing Sub-sequences"></a>#491 All increasing Sub-sequences</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/22/LeetCode-%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%9B%9E%E6%BA%AF%E6%B3%95/" data-id="ckatsrgu5007lxqfz96ry69tn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线性模型-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/22/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B-%E4%B8%80/" class="article-date">
  <time datetime="2019-08-22T07:02:28.000Z" itemprop="datePublished">2019-08-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Machine-Learning/">Machine Learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/22/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B-%E4%B8%80/">线性模型-(一)-最小二乘</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>线性模型形式简单，具有很好的可解释性。虽然简单却蕴藏着重要的机器学习的基本思想。一般实践中，都会先使用线性回归方法尝试。</li>
<li>把分类问题的样本点放在在坐标轴上，坐标轴每一个轴代表一个特征。而回归问题的样本点放到坐标轴上，<strong>x轴是连续的，可以是其中一个特征的连续值</strong>，其他轴代表不同的特征。</li>
<li>线性回归的目标是度量出模型没有拟合住样本点的部分，此时的目标函数称为 loss fucntion。</li>
<li>而有的算法中度量的是拟合的程度，此时成目标函数为效用函数 utility function 。</li>
<li>通过分析问题，确定问题的目标函数，通过最优化目标(最小化loss 或最大化utility)，获得机器学习模型。</li>
<li>为参数学习，找到一组参数，这组参数可以最小化loss 或最大化utility。涉及到<strong>最优化原理</strong>或<strong>凸优化理论</strong>，如常见的牛顿法，梯度下降，模拟退火等算法。许多计算机问题如最短路径，背包问题都属于最优化问题。</li>
<li>对于(一元或多元)线性回归，直接用最小二乘法求解。</li>
<li>使用线性模型的前提，是假设数据与目标间由线性关系。</li>
</ul>
<h1 id="最小二乘法解一元线性回归"><a href="#最小二乘法解一元线性回归" class="headerlink" title="最小二乘法解一元线性回归"></a>最小二乘法解一元线性回归</h1><p>基于<strong>最小化均方误差</strong>来进行模型求解的方法为<strong>最小二乘法</strong>，即试图找一条直线，使得所有样本点到该直线的欧氏距离之和最小。具体的结果是经过数学推导，而非迭代参数学习。</p>
<p>数据为一维向量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小写X表示这是一个向量</span></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,])</span><br><span class="line">y = np.array([<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">11</span>,])</span><br></pre></td></tr></table></figure>

<p>根据最小二乘法结果公式的得：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最小二乘法</span></span><br><span class="line">x_bar = np.mean(x)</span><br><span class="line">y_bar = np.mean(y)</span><br><span class="line"></span><br><span class="line">fenzi = <span class="number">0.0</span></span><br><span class="line">fenmu = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> zip(x, y):</span><br><span class="line">    fenzi += (i - x_bar) * (j - y_bar)</span><br><span class="line">    fenmu += (i - x_bar)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">a = fenzi / fenmu</span><br><span class="line">b = y_bar - a * x_bar</span><br></pre></td></tr></table></figure>

<p>绘制拟合直线：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制直线</span></span><br><span class="line">y_hat = a*x + b</span><br><span class="line"></span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.plot(x, y_hat, color=<span class="string">'r'</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">12</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<div align="center"><img src="/2019/08/22/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B-%E4%B8%80/linear.png" width="500"></div>

<p>使用模型，分别预测单个值，预测一组值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预测单个值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a * x + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测多个值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_X</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.asarray([a * x + b <span class="keyword">for</span> x <span class="keyword">in</span> X])</span><br></pre></td></tr></table></figure>

<p>上述计算过程是遍历每一个x和y，部分相乘后相加，这样计算的效率并不高。另一种方式是使用矩阵的乘法，即<strong>内积(Dot Product 点乘)</strong></p>
<h1 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h1><p>使用矩阵的内积，便可以用python中的向量相乘法则快速计算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x_mean = np.mean(x_train)</span><br><span class="line">y_mean = np.mean(y_train)</span><br><span class="line"></span><br><span class="line">a = (x_train - x_mean).dot(y_train - y_mean) / (x_train - x_mean).dot(x_train - x_mean)</span><br><span class="line">b = y_mean - a * x_mean</span><br></pre></td></tr></table></figure>

<p>用内积代替了循环遍历，计算性能上会有很大提升。对于1亿的数据量，两者使用时间：</p>
<pre><code>循环遍历： 55.904422
内积：    2.4315210000000036</code></pre><p>很多时候，<font color="red" size="4">算法原理的数学推导，最终要能变化成向量内积的形式，很重要</font>。</p>
<h1 id="评价现行模型的性能"><a href="#评价现行模型的性能" class="headerlink" title="评价现行模型的性能"></a>评价现行模型的性能</h1><p>评价线性模型主要用MSE, RMSE, MAE:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公式：</span></span><br><span class="line">mse = np.sum((y_predict - y_test)**<span class="number">2</span> / len(y_test))</span><br><span class="line">rmse = math.sqrt(mse)</span><br><span class="line">mae = np.sum(np.absolute(y_predict - y_test)) / len(y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sklearn：</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error</span><br></pre></td></tr></table></figure>

<p>相对来说，RMSE比MAE好，最小化RMSE，它表示错误样本中最大的错误值相应的比较小。而在线性回归中最好的指标要数R Squared。</p>
<h1 id="R-Squared"><a href="#R-Squared" class="headerlink" title="R Squared"></a>R Squared</h1><p>这个是线性回归最常用的性能指标。其定义为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r_squared = <span class="number">1</span> - (y_predict - y_test).dot(y_predict - y_test)</span><br><span class="line">               /</span><br><span class="line">               (y_means - y_test).dot(y_means - y_test)</span><br></pre></td></tr></table></figure>

<p>其中分子可以表示，使用我们的模型预测产生的错误。<br>而分母表示使用baseline 模型y=y_means 预测产生的错误。</p>
<p>分母的预测是不论x是多少，我都把他预测成y_means，错误率自然多。而分子是我们训练模型的实际预测，即我的模型实际拟合住样本的地方。</p>
<p>所以</p>
<ul>
<li>r_squared 是我的模型与baseline的比较。</li>
<li>两者相除小于等于1，</li>
<li>r_squared 越大，表示我们的模型越好</li>
<li>当r_squared = 1，表示，我的模型没有犯任何错。</li>
<li>当r_squared = 0，表示，我的模型性能等同于baseline。</li>
<li>当r_squared &lt; 0，表示，我的模型不如baseline，很可能，原数据不存在现<strong>线性关系</strong>。</li>
</ul>
<p>当r_squared 定义中分子分母同时除以测试样本个数，r_squared还可以写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r_squared = <span class="number">1</span> - mse(y_predict, y_test)/var(y_test)</span><br></pre></td></tr></table></figure>
<p>其中var(y_test)，表示y_test 数据方差。所以r_squared 是由统计意义的。</p>
<p>在sklearn中使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line"></span><br><span class="line">r2_score(y_predict, y_test)</span><br></pre></td></tr></table></figure>
<p>在sklearn中的LinearRegression模型里的 score成员方法返回的就是r_squared：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MODEL 表示任何模型的实例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(x_test, y_test)</span>:</span></span><br><span class="line">    y_predict = MODEL.predict(x_test)</span><br><span class="line">    <span class="keyword">return</span> r2_score(y_test, y_predict)</span><br></pre></td></tr></table></figure>

<h1 id="多元线性回归与Normal-Equation"><a href="#多元线性回归与Normal-Equation" class="headerlink" title="多元线性回归与Normal Equation"></a>多元线性回归与Normal Equation</h1><p>依旧可以使用最小二乘法得到最终解，即normal equation。但是计算机求解normal equation 的时间复杂度为O(n^3)。优点是根据数学解方程得到，不需要归一化处理。</p>
<p>sklearn中多元线性回归套路：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">boston = datasets.load_boston()</span><br><span class="line"><span class="comment"># print(boston.DESCR)  # (503, 13)</span></span><br><span class="line"><span class="comment"># print(boston.feature_names)</span></span><br><span class="line"></span><br><span class="line">X = boston.data</span><br><span class="line">y = boston.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 除去异常点</span></span><br><span class="line">X = X[y &lt; <span class="number">50</span>]</span><br><span class="line">y = y[y &lt; <span class="number">50</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">print(lin_reg.coef_)      <span class="comment">#  得到最终模型所有参数</span></span><br><span class="line">print(lin_reg.intercept_)  <span class="comment"># 包括截距</span></span><br><span class="line">print(lin_reg.score(X_test, y_test))   <span class="comment"># 应用在测试数据集上的得分</span></span><br></pre></td></tr></table></figure>

<p>实现normal equation：</p>
<p>首先在原本X_train中加入一列全为1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_b = np.hstack([np.ones((len(X_train), <span class="number">1</span>)), X_train])</span><br></pre></td></tr></table></figure>

<p>根据normal equation 的公式，其中intercept_表示直线上的截距，截距与样本特征无关，或者说，截距对应的特征是常数1。coef_表示coefficient，每个特征的系数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_theta = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y_train)  <span class="comment"># 完全根据公式</span></span><br><span class="line"></span><br><span class="line">intercept_ = _theta[<span class="number">0</span>]  <span class="comment"># 参数的第一列为截距</span></span><br><span class="line">coef_ = _theta[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>

<p>有了参数，就可以用于测试样本。写成函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X_sample)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> intercept_ <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> coef_ <span class="keyword">in</span> <span class="keyword">not</span> <span class="literal">None</span>, \</span><br><span class="line">        <span class="string">"Must fit before predict"</span></span><br><span class="line">    <span class="keyword">assert</span> X_sample.shape[<span class="number">1</span>] == len(coef_), \</span><br><span class="line">        <span class="string">"the feature number of X_sample must be equal to the lenght of coef_"</span></span><br><span class="line">    </span><br><span class="line">    X_b = np.hstack([np.ones((len(X_sample), <span class="number">1</span>)), X_sample])</span><br><span class="line">    <span class="keyword">return</span> X_b.dot(_theta)</span><br></pre></td></tr></table></figure>
<p>创建样本，使用模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X_sample = np.array([[<span class="number">0.5</span>, <span class="number">20.</span>, <span class="number">4.</span>, <span class="number">0.</span>, <span class="number">0.57</span>, <span class="number">7.</span>, <span class="number">52.</span>, <span class="number">2.8</span>, <span class="number">5.</span>, <span class="number">264.</span>, <span class="number">13.</span>, <span class="number">390.</span>, <span class="number">3.16</span>]])</span><br><span class="line"></span><br><span class="line">lr.predict(X_sample)  <span class="comment"># 返回模型认为的预测值</span></span><br></pre></td></tr></table></figure>
<h2 id="线性回归的可解释性"><a href="#线性回归的可解释性" class="headerlink" title="线性回归的可解释性"></a>线性回归的可解释性</h2><p>对所有数据解normal equation 方程得所有系数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ -1.05574295e-01   3.52748549e-02  -4.35179251e-02   4.55405227e-01</span><br><span class="line">  -1.24268073e+01   3.75411229e+00  -2.36116881e-02  -1.21088069e+00</span><br><span class="line">   2.50740082e-01  -1.37702943e-02  -8.38888137e-01   7.93577159e-03</span><br><span class="line">  -3.50952134e-01]</span><br></pre></td></tr></table></figure>
<p>系数的正负表示，这个特征与预测指标(如房价)是正相关还是负相关。<br>正值表示正相关，越大表示这个特征越大房价越高。<br>负值表示负相关，越大表示这个特征越大，房价越低。 <br>系数的绝对值的大小表示了该特征对房价的影响程度。可以把特征的值从小到大排列，分析什么特征的影响大，什么特和那个的影响小：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按系数排序，返回排序后的索引</span></span><br><span class="line">sort_index = np.argsort(lin_reg2.coef_)</span><br><span class="line"><span class="comment"># 使用排序后的索引，给特征名称排序 </span></span><br><span class="line">boston.feature_names[sort_index]</span><br></pre></td></tr></table></figure>
<p>比如，最大值系数表示房间数目。房间数目与房价正相关，且越大房价越高。合理。<br>最小系数对应一氧化氮浓度。浓度与房价成负相关，且值越大，房价越低。合理。</p>
<p>这就是“现行模型的可解释性”，有针对的采集更多数据，帮助决策。 </p>
<p><strong>注意</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])  </span><br><span class="line">np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br></pre></td></tr></table></figure>
<p>前者是向量，大小为： (8,)<br><br>后者是矩阵，大小为： (2, 8)</p>
<p><font color="gree" size="5">敲黑板</font>机器学习算法实现不是目的，一个算法的优劣是将它放在特定任务中，与其他算法比较得出的。也就是说，单单训练好一个模型，还没结束，而是与其他训练好的模型一起评价，比如使用由confusion matrix 得到的指标：查准率，查全率，F-alpha，P-R曲线， ROC曲线等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/22/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B-%E4%B8%80/" data-id="ckatsrgvd008exqfz5a1h4bst" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-集成学习-Boosting-四" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/21/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-Boosting-%E5%9B%9B/" class="article-date">
  <time datetime="2019-08-21T07:03:16.000Z" itemprop="datePublished">2019-08-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Machine-Learning/">Machine Learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/21/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-Boosting-%E5%9B%9B/">集成学习-Boosting-(四)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前说过，集成学习分为两类：学习器间无关系，和基学习器间有关系。前者常使用Bagging 和随机森林。而后者常使用Boosting。Boosting的工作机制如下：<strong>先从训练集中训练出一个基学习器，然后根据这个学习器的表现调整样本分布，使得先前的学习器分类错误的样本在后续收到更多关注，最后基于调整后的样本训练下一个学习器。如此反复</strong>。也就是说，每个基学习器都在尝试提升整体效果。可以看出，Boosting不能并行执行。</p>
<p>常见两个Boosting</p>
<ol>
<li>Ada Boosting</li>
<li>Gradient Boosting</li>
</ol>
<h1 id="Ada-Boosting"><a href="#Ada-Boosting" class="headerlink" title="Ada Boosting"></a>Ada Boosting</h1><p>Boosting算法最著名的代表是AdaBoost：其过程如下：</p>
<div align="center"><img src="/2019/08/21/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-Boosting-%E5%9B%9B/ada.png" width="600"></div>
<div align="center">图 多个学习器串行，调整样本权值</div>

<p>初始样本集每个样本有一个权值，当第一个学习器学习完后，对于不能正确捕捉的样本，调整这些样本的权值。然后第二个学习器接着学习，对于不能正确捕捉的样本调整权值。然后让第三个学习器接着学习。如此反复。可以看出，在整个样本的学习过程中，样本的权值在不断变化。<br>那么怎样给样本点附上权值，这其实是个<strong>问题转化</strong>，转化为求极值的问题。</p>
<p>sklearn中使用<code>AdaBoostClassifier()</code>实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据集</span></span><br><span class="line">x, y = datasets.make_moons(n_samples=<span class="number">200</span>, noise=<span class="number">0.4</span>, random_state=<span class="number">111</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建adaboost 模型</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line">ada = AdaBoostClassifier(DecisionTreeClassifier(max_depth=<span class="number">2</span>),</span><br><span class="line">                         n_estimators=<span class="number">100</span>)</span><br><span class="line">model = ada.fit(x_train, y_train)</span><br><span class="line">print(model)</span><br><span class="line">print(model.score(x_test, y_test))</span><br></pre></td></tr></table></figure>

<p>在测试集上结果：92.0%</p>
<h1 id="Gradient-Boosting"><a href="#Gradient-Boosting" class="headerlink" title="Gradient Boosting"></a>Gradient Boosting</h1><p>Gradient Boosting 是另外一种思路，它<strong>仅以决策树</strong>为基学习器。过程如下图：</p>
<div align="center"><img src></div>

<p>对于所有样本，训练第一个模型<code>m1</code>，得到所有分类错误样本。对于上一步中的所有错误分类样本，训练第二个模型<code>m2</code>， 得到这次分类错误样本。如此反复。最终的模型<code>m</code>等于这个过程中所有模型之和：<code>m = m1 + m2 + m3 + m4 + ...</code>。</p>
<p>sklearn使用<code>GradientBoostingClassifier()</code>实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同样的数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gradient Boosting使用决策树为基学习器：</span></span><br><span class="line">gb = GradientBoostingClassifier(max_depth=<span class="number">2</span>, n_estimators=<span class="number">100</span>)</span><br><span class="line">gb.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">print(gb.score(x_test, y_test))</span><br></pre></td></tr></table></figure>
<p>模型在测试集上的性能： 88.0%</p>
<p>Gradient Boosting 其实是一种<font color="red">残差学习</font>，每一个学习器并不是学习整个样本集，只学习错误分类集。</p>
<p>同样的，Ada Boosting 和 Gradient Boosting 也可以用来处理回归任务。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/21/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-Boosting-%E5%9B%9B/" data-id="ckatsrgth006axqfzbizxb1d1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-集成学习-三-随机森林" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/21/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/" class="article-date">
  <time datetime="2019-08-21T06:04:54.000Z" itemprop="datePublished">2019-08-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Machine-Learning/">Machine Learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/21/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/">集成学习-(三)-随机森林</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="为什么随机森林强"><a href="#为什么随机森林强" class="headerlink" title="为什么随机森林强"></a>为什么随机森林强</h1><p>当集成学习的基学习器均为决策树时，称随机森林，是Bagging的一种变体。决策树在<font color="orange">选择划分属性</font>时，是在当前属性集合中选择最优属性；<font color="red">而在随机森林中，对每个基决策树的每个结点，从该节点的属性集合中随机选择一个包含<code>k</code>个属性的子集，再从这个子集中选择最优的属性用作划分</font>。</p>
<p><font color="red">这个<code>k</code>控制了随机性的程度</font>：当k值等于当前结点的属性集合中所有属性时，表示随机性为0；当k=1时，则表示，在当前结点的属性集合中随机选取一个，之后就使用这一个作为划分，不管它是好是坏(因为没得选，只有这一个)。一般情况下，选取k为<code>log(d)</code>, 以2为底数。</p>
<p>为什么随机森林可以“代表集成学习技术”，Bagging中的基学习器<font color="orange">多样性</font>是仅仅通过数据的扰动达到的。而随机森林的多样性，<font color="red">不仅来源于数据扰动，还来自属性的扰动</font>。</p>
<p>实现随机森林：</p>
<h1 id="例"><a href="#例" class="headerlink" title="例"></a>例</h1><p>使用moon数据集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y = datasets.make_moons(n_samples=<span class="number">1000</span>, noise=<span class="number">0.2</span>, random_state=<span class="number">111</span>)</span><br></pre></td></tr></table></figure>

<p>构建一片由500棵树的森林：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line">rf = RandomForestClassifier(n_estimators=<span class="number">500</span>,</span><br><span class="line">                            random_state=<span class="number">233</span>,</span><br><span class="line">                            oob_score=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">model = rf.fit(x, y)</span><br><span class="line"><span class="comment"># 查看模型参数</span></span><br><span class="line">print(model)</span><br><span class="line"><span class="comment"># 使用oob，用剩下的样本做测试</span></span><br><span class="line">print(model.oob_score_)</span><br></pre></td></tr></table></figure>

<p>模型参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RandomForestClassifier(bootstrap=<span class="literal">True</span>, class_weight=<span class="literal">None</span>, criterion=<span class="string">'gini'</span>,</span><br><span class="line">            max_depth=<span class="literal">None</span>, max_features=<span class="string">'auto'</span>, max_leaf_nodes=<span class="literal">None</span>,</span><br><span class="line">            min_impurity_decrease=<span class="number">0.0</span>, min_impurity_split=<span class="literal">None</span>,</span><br><span class="line">            min_samples_leaf=<span class="number">1</span>, min_samples_split=<span class="number">2</span>,</span><br><span class="line">            min_weight_fraction_leaf=<span class="number">0.0</span>, n_estimators=<span class="number">500</span>, n_jobs=<span class="number">1</span>,</span><br><span class="line">            oob_score=<span class="literal">True</span>, random_state=<span class="number">233</span>, verbose=<span class="number">0</span>, warm_start=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>可以看出随机森林由那些参数，可以如何设置。<font color="red" size="3">理解了算法原理，才能理解每个参数如何使用</font>。测试集上准确率为95.6%.</p>
<h1 id="Extra-Tree"><a href="#Extra-Tree" class="headerlink" title="Extra-Tree"></a>Extra-Tree</h1><p>还有一种特殊随机森林：Extra-Tree，与经典森林不同的是，这种森林在结点划分时，完全随机，也就是说在当前节点的<font color="red">所有属性里随机选择一个，而非选择最优的</font>。如此一来，森林中的每一棵树的就更加不同了，即多样性更强了。示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> ExtraTreesClassifier</span><br><span class="line">etree = ExtraTreesClassifier(n_estimators=<span class="number">500</span>,</span><br><span class="line">                             bootstrap=<span class="literal">True</span>,</span><br><span class="line">                             oob_score=<span class="literal">True</span>,</span><br><span class="line">                             random_state=<span class="number">233</span>)</span><br><span class="line"></span><br><span class="line">model2 = etree.fit(x, y)</span><br><span class="line">print(model2)</span><br><span class="line">print(model2.oob_score_)</span><br></pre></td></tr></table></figure>

<p>结果 95.5%</p>
<p>回顾了Bagging，随机森林，Extra-Tree 都进行了分类任务的应用。也可以将这些集成用于回归任务。</p>
<p><font color="gree" size="5">敲黑板</font>样本数量的扰动，样本属性的扰动，增强不同决策树的<font color="red">多样性</font>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/21/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/" data-id="ckatsrgtk006jxqfzdinf39uk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-集成学习-ensemble-learning-二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/20/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-ensemble-learning-%E4%BA%8C/" class="article-date">
  <time datetime="2019-08-20T15:43:46.000Z" itemprop="datePublished">2019-08-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Machine-Learning/">Machine Learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/20/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-ensemble-learning-%E4%BA%8C/">集成学习-(二)-Bagging</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>集成学习可以分为两大类：</p>
<ul>
<li>学习器之间存在依赖关系，必须串行生成序列化方法。</li>
<li>学习器之间不存在依赖关系，可以同时生成的并行化方法。</li>
</ul>
<p>前者的代表是“Boosting”，后者的代表是“Bagging”和“随机森林(Random Forest)”.</p>
<p>得到泛化能力强的集成，每个学习器要尽量不同，如何做到不同。一个方法是由训练集产生多个不同的子集，在每个子集上训练学习器。如5000个样本，用5个学习器分别学习1000个样本集。如此产生5个不同的模型。但是如此一来，每个模型的性能会有所下降，同时，集成学习的一个优势是每个学习器并不需要具有很强的性能。</p>
<h1 id="从数据中采样"><a href="#从数据中采样" class="headerlink" title="从数据中采样"></a>从数据中采样</h1><p>但是，“好而不同”毕竟每个学习器要“好”。所以根据每个学习器只使用数据的一部分，产生两种采样方式：</p>
<ul>
<li>有放回抽样 自助采样（Bootstrap Sampling）</li>
<li>无放回抽样</li>
</ul>
<p>自助采样：假设原始数据集由m个样本，对于第一个学习器，随机采样一个样本，放入采样集中，后把该样本放回原数据集。如此采样m次便得到含有m个样本的子集来训练学习器<code>#1</code>。对于其他学习器，采用同样的方式得到训练集。如此得到的不同子集中一定存在重复的元素。最后基于每一个子集训练学习器，后集成。此过程成为<code>Bagging</code>。</p>
<p>对于无放回抽样，就如上述所述，5000个样本是数据集，若分给5个学习器，每个得到1000个样本；10 个学习器，每个得到500个样本。这种方法成为<code>Pasting</code>。其局限性很显然，学习器个数与其子集样本数成反比。</p>
<p>Bagging常用。例：<br>所使用数据集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = datasets.make_moons(n_samples=<span class="number">1000</span>, noise=<span class="number">0.2</span>, random_state=<span class="number">111</span>)</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=<span class="number">111</span>)</span><br></pre></td></tr></table></figure>

<p>使用决策树为基学习器，设置<code>5</code>个，采样为放回采样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier</span><br><span class="line"></span><br><span class="line">bagg = BaggingClassifier(DecisionTreeClassifier(),</span><br><span class="line">                         n_estimators=<span class="number">5</span>, max_samples=<span class="number">100</span>, bootstrap=<span class="literal">True</span>)</span><br><span class="line">bagg.fit(x_train, y_train)</span><br><span class="line">print(bagg.score(x_test, y_test))</span><br></pre></td></tr></table></figure>

<p>测试集的正确率为：94.4%</p>
<p>设置<code>500</code>个基学习器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bagg2 = BaggingClassifier(DecisionTreeClassifier(),</span><br><span class="line">                         n_estimators=<span class="number">500</span>, max_samples=x_train.shape[<span class="number">0</span>], bootstrap=<span class="literal">True</span>)</span><br><span class="line">bagg2.fit(x_train, y_train)</span><br><span class="line">print(bagg2.score(x_test, y_test))</span><br></pre></td></tr></table></figure>

<p>测试集准确率： 96.0%</p>
<h1 id="Out-of-bag-Estimate（OOB）"><a href="#Out-of-bag-Estimate（OOB）" class="headerlink" title="Out-of-bag Estimate（OOB）"></a>Out-of-bag Estimate（OOB）</h1><p>可以计算，<font color="red">通过自助采样，原始数据集中大约有36.8%的样本未出现在每个学习器的样本子集中。所以对于Bagging，天然的，在原始数据集中就有测试集了</font>，即那剩下的原始数据集中的36.7%。</p>
<p>使用sklearn 中的<code>oob_score_</code> 实现<code>oob</code>：<br><font color="red">在放回采样过程中，记录那些样本没有被取到，这些未被取到的作为验证集或测试集</font>，这个过程由oob_score=True 实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bagg3 = BaggingClassifier(DecisionTreeClassifier(),</span><br><span class="line">                          n_estimators=<span class="number">500</span>, max_samples=x.shape[<span class="number">0</span>],</span><br><span class="line">                          bootstrap=<span class="literal">True</span>, oob_score=<span class="literal">True</span>)</span><br><span class="line">bagg3.fit(x, y)</span><br><span class="line">print(bagg3.oob_score_)</span><br></pre></td></tr></table></figure>

<p>结果0.958。</p>
<h1 id="多核心并行"><a href="#多核心并行" class="headerlink" title="多核心并行"></a>多核心并行</h1><p>由于每个学习器没有相互影响，所以所有学习器可以同时学习：<br>指定<code>n_jobs</code>的值，当其为<code>-1</code>时，表示使用计算机所有物理核心：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并行执行，使用所有核心</span></span><br><span class="line">bagg4 = BaggingClassifier(DecisionTreeClassifier(),</span><br><span class="line">                          n_estimators=<span class="number">500</span>, max_samples=x.shape[<span class="number">0</span>],</span><br><span class="line">                          bootstrap=<span class="literal">True</span>,</span><br><span class="line">                          oob_score=<span class="literal">True</span>,</span><br><span class="line">                          n_jobs=<span class="number">-1</span>)</span><br><span class="line">start2 = clock()</span><br><span class="line">bagg4.fit(x, y)</span><br><span class="line">end2 = clock()</span><br><span class="line">print(bagg4.oob_score_)</span><br><span class="line">print(end2 - start2)</span><br></pre></td></tr></table></figure>
<p>计时得到最终执行时间：0.1591450000000001<br>而使用一个核心的执行时间为：0.6764169999999998</p>
<h1 id="更多采样方式"><a href="#更多采样方式" class="headerlink" title="更多采样方式"></a>更多采样方式</h1><p><font color="red">当数据集的特征较多时，可是对特征进行随机采样</font>：<code>Random Subspaces</code>。只在列上随机采样。如下左图。<br><br>另一种采样方式，既对样本随机采样，又对特征的随机采样：<code>Random Patches</code>。既在行又在列上随机采样。如下右图：</p>
<div align="center"><img src="/2019/08/20/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-ensemble-learning-%E4%BA%8C/sampling.png" width="600"></div>
<div align="center">左Radom Subspaces & 右Random Patches</div>

<p>既然有对样本数量的自助采样（bootstrap sampling），也有对样本特征的自助采样。如此得到的特征为<code>bootstrap features</code>：</p>
<ul>
<li><p>Random Subspaces</p>
<p>  只对特征进行随机采样，将学习机的<code>bootstrap_features</code>参数置为<code>True</code>：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭样数量的随机采样</span></span><br><span class="line">random_subspaces_bag = BaggingClassifier(DecisionTreeClassifier(),</span><br><span class="line">                                        n_estimators=<span class="number">500</span>,</span><br><span class="line">                                        max_samples=x.shape[<span class="number">0</span>],  <span class="comment"># 所有行</span></span><br><span class="line">                                        max_features=<span class="number">1</span>,</span><br><span class="line">                                        bootstrap=<span class="literal">True</span>,</span><br><span class="line">                                        bootstrap_features=<span class="literal">True</span>,  <span class="comment"># 一部分列</span></span><br><span class="line">                                        oob_score=<span class="literal">True</span>,</span><br><span class="line">                                        n_jobs=<span class="number">-1</span>)</span><br><span class="line">start3 = clock()</span><br><span class="line">random_subspaces_bag.fit(x, y)</span><br><span class="line">end3 = clock()</span><br><span class="line">print(random_subspaces_bag.oob_score_)</span><br><span class="line">print(end3 - start3)</span><br></pre></td></tr></table></figure>
<p>  结果为： 0.835<br>  运行时间：0.1876460000000002</p>
</li>
</ul>
<ul>
<li><p>Random Patches，</p>
<p>  既对样本数据量采样，又对特征进行采样。因为原始数据只有2个特征，所以此处只采样一个特征。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## random patches 既有样本数的随机采样， 又有特征的随机采样：</span></span><br><span class="line">random_patches_bag = BaggingClassifier(DecisionTreeClassifier(),</span><br><span class="line">                                        n_estimators=<span class="number">500</span>,</span><br><span class="line">                                        max_samples=<span class="number">200</span>,  <span class="comment"># 一部分行</span></span><br><span class="line">                                        max_features=<span class="number">1</span>,</span><br><span class="line">                                        bootstrap=<span class="literal">True</span>,</span><br><span class="line">                                        bootstrap_features=<span class="literal">True</span>,  <span class="comment"># 一部分列</span></span><br><span class="line">                                        oob_score=<span class="literal">True</span>,</span><br><span class="line">                                        n_jobs=<span class="number">-1</span>)</span><br><span class="line">start3 = clock()</span><br><span class="line">random_patches_bag.fit(x, y)</span><br><span class="line">end3 = clock()</span><br><span class="line">print(random_patches_bag.oob_score_)</span><br><span class="line">print(end3 - start3)</span><br></pre></td></tr></table></figure>
<p>  结果为：0.897<br>  运行时间： 0.16168400000000016</p>
<p>  对于图像信息，<font color="red">除了pooling采样操作，还可以使用这两种采样操作</font>。</p>
</li>
</ul>
<p><font color="gree" size="5">敲黑板</font></p>
<pre><code>”好而不同“是集成学习的核心。
”不同“的实现方式之一是”采样“：对样本数量采样，对样本特征采样。
即，使用一部分数据训练基学习器。</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/20/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-ensemble-learning-%E4%BA%8C/" data-id="ckatsrgtl006mxqfz51xi2dww" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-集成学习-ensemble-learning-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/20/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-ensemble-learning-%E4%B8%80/" class="article-date">
  <time datetime="2019-08-20T14:28:32.000Z" itemprop="datePublished">2019-08-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Machine-Learning/">Machine Learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/20/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-ensemble-learning-%E4%B8%80/">集成学习(ensemble-learning)-(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>类似，生病了找多名专家从不同方面一起确诊。</li>
<li>集成学习将多个学习器进行结合，通常可以获得比单一的学习器更优的泛化性能。</li>
<li>集成学习可以得带3中不同结果：提升性能，不起作用，起负作用。</li>
<li>所以要想获得好的集成结果，每个学习器应该“好而不同”，即每个学习器要有一定的准确性，同时，每个学习器各不相同。即“多样性”。</li>
<li>实际上，如何产生“好而不同”的基学习器，是集成学习的核心。</li>
</ul>
<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><p>使用数据集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y = datasets.make_moons(n_samples=<span class="number">500</span>, noise=<span class="number">0.2</span>, random_state=<span class="number">321</span>)</span><br></pre></td></tr></table></figure>

<p>构建三个基学习器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1） 使用逻辑回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">log = LogisticRegression()</span><br><span class="line">log.fit(x_train, y_train)</span><br><span class="line">print(log.score(x_test, y_test))   <span class="comment">#  0.896</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2) 使用SVM</span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">svm = SVC()</span><br><span class="line">svm.fit(x_train, y_train)</span><br><span class="line">print(svm.score(x_test, y_test))   <span class="comment">#  0.952</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3) 使用决策树分类</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">tree = DecisionTreeClassifier()</span><br><span class="line">tree.fit(x_train, y_train)</span><br><span class="line">print(tree.score(x_test, y_test))  <span class="comment">#  0.944</span></span><br></pre></td></tr></table></figure>

<p>结果分别为 0.896, 0.952, 0.944.</p>
<p>投票操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># voting</span></span><br><span class="line">y_pre1 = log.predict(x_test)</span><br><span class="line">y_pre2 = svm.predict(x_test)</span><br><span class="line">y_pre3 = tree.predict(x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 少数服从多数</span></span><br><span class="line"><span class="comment"># 对于三个模型的预测值，至少2个模型判断它为1，我才认为它是1：</span></span><br><span class="line">y_p = np.asarray((y_pre1 + y_pre2 + y_pre3) &gt;= <span class="number">2</span>, dtype=int)</span><br><span class="line">print(y_pre1[:<span class="number">10</span>])   <span class="comment">#  [1 1 1 1 1 0 1 0 0 0]</span></span><br><span class="line">print(y_pre2[:<span class="number">10</span>])   <span class="comment">#  [1 1 1 1 1 0 1 0 0 1]</span></span><br><span class="line">print(y_pre3[:<span class="number">10</span>])   <span class="comment">#  [1 1 1 1 1 0 1 0 0 1]</span></span><br><span class="line">print(y_p[:<span class="number">10</span>])      <span class="comment">#  [1 1 1 1 1 0 1 0 0 1]</span></span><br></pre></td></tr></table></figure>

<p>判断集成效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line">acc = accuracy_score(y_test, y_p)</span><br><span class="line">print(acc)     <span class="comment">#  0.96</span></span><br></pre></td></tr></table></figure>

<p>最终集成性能是0.96。</p>
<h2 id="Hard-voting"><a href="#Hard-voting" class="headerlink" title="Hard voting"></a>Hard voting</h2><p>hard voting 即少数服从多数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> VotingClassifier</span><br><span class="line"></span><br><span class="line">voting = VotingClassifier(estimators=[</span><br><span class="line">    (<span class="string">'log'</span>, LogisticRegression()),</span><br><span class="line">    (<span class="string">'svm'</span>, SVC()),</span><br><span class="line">    (<span class="string">'tree'</span>, DecisionTreeClassifier())</span><br><span class="line">], voting=<span class="string">'hard'</span>)</span><br><span class="line"></span><br><span class="line">voting.fit(x_train, y_train)</span><br><span class="line">print(voting.score(x_test, y_test))    <span class="comment">#  0.96</span></span><br></pre></td></tr></table></figure>

<p>实际中，<font color="red">通常把基学习器调参到最优，后再集成</font>。</p>
<h2 id="Soft-voting"><a href="#Soft-voting" class="headerlink" title="Soft voting"></a>Soft voting</h2><p>hard voting 其实是“少数服从多数”，而 soft voting <font color="red">带权投票</font>，如歌唱的专业评审团的投票权重就大。如：</p>
<p>5个学习器把同一个样本分为A类或B类的概率分别如下：</p>
<pre><code>            A类    B类
学习器#0   99.0%  1.0%
学习器#1   49.0%  51.0%
学习器#2   43.0%  57.0%
学习器#3   98.0%  2.0%
学习器#4   34.0%  64.0%</code></pre><p>如果使用hard voting 该样本最终本分为B类。</p>
<p>但是，显然学习器<code>#0</code>和<code>#3</code>有很大的把握认为该样本属于A类，而其他三个学习器并没有很确定该样本的类别。所以“少数服从多数”不合适。使用Soft voting 计算<br>属于A类：(99.0%+49.0%+43.0%+98.0%+34.0%) / 5 = 64.6%. <br>属于B类：(1.0%+51.0%+57.0%+2.0%+64.0%) / 5 = 35.0%.<br> 所以该样本应该被分类为A。</p>
<p><font color="red">使用 Soft voting 的基学习器要求都应该估计概率</font>，即可以调用 predict_proba 函数。SVM模型把probability设为true，便可以进行概率估计。调用VotingClassifier时指明voting方式为soft即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> VotingClassifier</span><br><span class="line">voting2 = VotingClassifier(estimators=[</span><br><span class="line">    (<span class="string">'log'</span>, LogisticRegression()),</span><br><span class="line">    (<span class="string">'svm'</span>, SVC(probability=<span class="literal">True</span>)),</span><br><span class="line">    (<span class="string">'tree'</span>, DecisionTreeClassifier())</span><br><span class="line">], voting=<span class="string">'soft'</span>)</span><br><span class="line"></span><br><span class="line">voting2.fit(x_train, y_train)</span><br><span class="line">print(voting2.score(x_test, y_test))   <span class="comment">#  0.976</span></span><br></pre></td></tr></table></figure>

<p>所以，当基学习器可以求出样本概率估计时，Soft voting 比 hard voting 性能优。 </p>
<p><font color="green" size="5">敲黑板</font>理解当前问题，才能找到已有方法的不足，才能找到更合适的方法。就如本文表达的用Soft voting 替代已有的Hard voting。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/20/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0-ensemble-learning-%E4%B8%80/" data-id="ckatsrgti006dxqfz76k8gph2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-回顾决策树-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/20/%E5%9B%9E%E9%A1%BE%E5%86%B3%E7%AD%96%E6%A0%91-%E4%B8%80/" class="article-date">
  <time datetime="2019-08-19T16:00:11.000Z" itemprop="datePublished">2019-08-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Machine-Learning/">Machine Learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/20/%E5%9B%9E%E9%A1%BE%E5%86%B3%E7%AD%96%E6%A0%91-%E4%B8%80/">回顾决策树(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>决策树是非参数学习算法</li>
<li>天然解决多分类问题</li>
<li>有很好的可解释性</li>
<li><font color="red">关键问题是使用哪个特征做为根节点</font></li>
<li>对于连续值的特征，在哪个值上做划分</li>
</ul>
<h1 id="离散数据集"><a href="#离散数据集" class="headerlink" title="离散数据集"></a>离散数据集</h1><p>使用iris数据集，调用sklearn的Decision Tree 模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只是用数据2个特征</span></span><br><span class="line">x = iris.data[:, <span class="number">2</span>:]</span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line">tree_clf = DecisionTreeClassifier(max_depth=<span class="number">2</span>, criterion=<span class="string">"entropy"</span>)</span><br><span class="line">tree_clf.fit(x, y)</span><br><span class="line"></span><br><span class="line">plot_decision_boundary(tree_clf, axis=[<span class="number">0.5</span>, <span class="number">7.5</span>, <span class="number">0</span>, <span class="number">3</span>])</span><br><span class="line">plt.scatter(x[y == <span class="number">0</span>, <span class="number">0</span>], x[y == <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">plt.scatter(x[y == <span class="number">2</span>, <span class="number">0</span>], x[y == <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">plt.scatter(x[y == <span class="number">1</span>, <span class="number">0</span>], x[y == <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<div align="center"><img src="/2019/08/20/%E5%9B%9E%E9%A1%BE%E5%86%B3%E7%AD%96%E6%A0%91-%E4%B8%80/tree1.png" width="500"></div>
<div align="center">图 深度为2的决策树 </div>

<p>划分后使得系统的<font color="red">熵</font>（即不确定性）降低。所以对于一个划分，如果划分后的系统信息熵比其他划分后的熵都要小，则当前就是用这个划分。根据这个原理，可以就特征为连续值的数据集进行划分：</p>
<h1 id="连续值的数据集"><a href="#连续值的数据集" class="headerlink" title="连续值的数据集"></a>连续值的数据集</h1><p>已知特征d，和value， 对x进行划分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(x, y, d, value)</span>:</span></span><br><span class="line">    index_a = (x[:, d] &lt;= value)</span><br><span class="line">    index_b = (x[:, d] &gt; value)</span><br><span class="line">    <span class="keyword">return</span> x[index_a], x[index_b], y[index_a], y[index_b]</span><br></pre></td></tr></table></figure>

<p>传入label列表，求此时的系统信息熵：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_entropy</span><span class="params">(y)</span>:</span></span><br><span class="line">    <span class="comment"># counter 为字典，[类别，这个类别所含样本数]</span></span><br><span class="line">    counter = Counter(y)  </span><br><span class="line">    res = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> counter.values():</span><br><span class="line">        p = num / len(y)</span><br><span class="line">        res += -p * log2(p)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>定义一次划分，即，划分算法：搜索找到使得熵最小的特征d和value：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_split</span><span class="params">(x, y)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始值最大</span></span><br><span class="line">    best_entropy = float(<span class="string">'inf'</span>)  </span><br><span class="line">    <span class="comment"># best_e_l, best_e_r = -1, -1</span></span><br><span class="line">    <span class="comment"># 初始化d 和 value</span></span><br><span class="line">    best_d, best_v = <span class="number">-1</span>, <span class="number">-1</span>   </span><br><span class="line">    <span class="comment"># 在x 的所有维度（特征）搜索d：</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> range(x.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="comment"># 在特征d的哪个值上划分：先排序，后找相邻的样本在特征d上的中间值是多少</span></span><br><span class="line">        sorted_index = np.argsort(x[:, d])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(x)):  <span class="comment"># 遍历所有样本</span></span><br><span class="line">            <span class="keyword">if</span> x[sorted_index[i<span class="number">-1</span>], d] != x[sorted_index[i], d]:</span><br><span class="line">                v = (x[sorted_index[i<span class="number">-1</span>], d] + x[sorted_index[i], d]) / <span class="number">2</span></span><br><span class="line">                <span class="comment"># 有了 d 和 v， split：</span></span><br><span class="line">                x_l, x_r, y_l, y_r = split(x, y, d, v) </span><br><span class="line">                <span class="comment"># 此时系统熵是多少</span></span><br><span class="line">                e = cal_entropy(y_l) + cal_entropy(y_r)</span><br><span class="line">                <span class="comment"># e_l = cal_entropy(y_l)</span></span><br><span class="line">                <span class="comment"># e_r = cal_entropy(y_r)</span></span><br><span class="line">                <span class="comment"># 判断新的熵e是否小于best_entropy，更新best_entropy</span></span><br><span class="line">                <span class="keyword">if</span> e &lt; best_entropy:</span><br><span class="line">                    best_entropy, best_v, best_d = e, v, d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> best_entropy, best_d, best_v</span><br></pre></td></tr></table></figure>

<p>调用函数得第一次划分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次划分：</span></span><br><span class="line">best_entropy, best_d, best_v = try_split(x, y)</span><br><span class="line">x1_l, x1_r, y1_l, y1_r = split(x, y, best_d, best_v)</span><br><span class="line"></span><br><span class="line">print(cal_entropy(y1_l))  <span class="comment"># 0.0  </span></span><br><span class="line">print(cal_entropy(y1_r))  <span class="comment"># 1.0</span></span><br></pre></td></tr></table></figure>

<p>左子树的熵为0，右子树的熵大于0，所以对右子树进行第二次划分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于右边再次划分：</span></span><br><span class="line">best2_entropy, best2_d, best2_v = try_split(x1_r, y1_r)</span><br><span class="line">x2_l, x2_r, y2_l, y2_r = split(x1_r, y1_r, best2_d, best2_v)</span><br><span class="line"></span><br><span class="line">print(cal_entropy(y2_l))  <span class="comment"># 0.44506485705083865</span></span><br><span class="line">print(cal_entropy(y2_r))  <span class="comment"># 0.15109697051711368</span></span><br></pre></td></tr></table></figure>

<p>可以继续深入划分。</p>
<p>由于数据集各个特征值是连续的，所以，上述过程是：<font color="red">遍历找到所划分的特征，这个特征中遍历的所有样本，排序后求相邻两个样本的均值作为这个特征的具体划分值</font>，时间复杂度为O(mxn)，即样本个数乘以特征个数。</p>
<p>对于各个特征值为离散的，使用<font color="red">信息增益</font>来找到消除不确定性最强的特征。每次都找信息增益最大的属性作为下一个划分属性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/20/%E5%9B%9E%E9%A1%BE%E5%86%B3%E7%AD%96%E6%A0%91-%E4%B8%80/" data-id="ckatsrgt20055xqfza3mq1kig" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/11/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CUDA/">CUDA</a><span class="category-list-count">35</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Caffe/">Caffe</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Deep-Learning/">Deep Learning</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linear-Algebra/">Linear Algebra</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/">Machine Learning</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Reinforcement-Learning/">Reinforcement Learning</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Utility/">Utility</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%85%E5%BD%92%E7%B1%BB/">待归类</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a><span class="tag-list-count">50</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BST/" rel="tag">BST</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CUDA/" rel="tag">CUDA</a><span class="tag-list-count">33</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Caffe/" rel="tag">Caffe</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test-Analysis/" rel="tag">Test Analysis</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithms/" style="font-size: 20px;">Algorithms</a> <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/CUDA/" style="font-size: 18px;">CUDA</a> <a href="/tags/Caffe/" style="font-size: 16px;">Caffe</a> <a href="/tags/Test-Analysis/" style="font-size: 14px;">Test Analysis</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 12px;">二分查找</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 10px;">递归</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">26</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">38</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/01/">January 1970</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/17/caffe-%E5%9C%A8%E6%96%B0%E6%A0%B7%E6%9C%AC%E4%B8%8A%E4%BD%BF%E7%94%A8%E8%AE%AD%E7%BB%83%E5%A5%BD%E7%9A%84%E6%A8%A1%E5%9E%8B/">caffe-在新样本上使用训练好的模型</a>
          </li>
        
          <li>
            <a href="/2020/06/16/LeetCode-BST%E7%9B%B8%E5%85%B3/">LeetCode-BST相关</a>
          </li>
        
          <li>
            <a href="/2020/06/15/LeetCode-top-k/">LeetCode-top-k</a>
          </li>
        
          <li>
            <a href="/2020/06/13/LeetCode-153-%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E5%80%BC/">LeetCode-153-找到最小值</a>
          </li>
        
          <li>
            <a href="/2020/06/12/LeetCode-34-find-positions-of-elements/">LeetCode-34-find-positions-of-elements</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Junhui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>