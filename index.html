<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Junhui&#39;s Journal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Junhui&#39;s Journal">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Junhui&#39;s Journal">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Junhui">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Junhui&#39;s Journal" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junhui&#39;s Journal</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-安装使用MinGW-Cmake在windows" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/19/%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8MinGW-Cmake%E5%9C%A8windows/" class="article-date">
  <time datetime="2020-01-19T07:34:42.000Z" itemprop="datePublished">2020-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Utility/">Utility</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/19/%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8MinGW-Cmake%E5%9C%A8windows/">安装使用MinGW Cmake在windows</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Windows中不能直接使用gcc，g++编译器，即使使用CLion，也同样需要配置toolchain。除了使用Virtual Studio 之外，还有相对轻量级的工具，比如MinGW 和 Cygwin。</p>
<ul>
<li><p>安装cmake</p>
<p>  并且把其安装目录的<code>bin</code>目录添加到系统路径中。</p>
<p>  安装CMake后，CMake Documentation存在于安装目录中。其中，阅读CMake Tutorial，里边有CMake的使用细节。或者阅读<a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html" target="_blank" rel="noopener">在线文档</a>。 </p>
</li>
<li><p>安装MinGW</p>
<p>  从这里（<a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/seh/）" target="_blank" rel="noopener">https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/seh/）</a><br>  直接下载，免安装。解压到某个位置，进入<code>bin</code>目录，可以看到<code>gcc.exe</code> 和 <code>g++.exe</code>。等其他组件。</p>
<p>  将这个<code>bin</code>目录的路径加入到系统环境变量中。</p>
<p>  额外一步：进入mingw的<code>bin</code>目录，找到<code>mingw32-make.exe</code>，将其复制一份并且重命名为<code>make.exe</code>。如此便可以使用<code>make</code>命令代替<code>mingw32-make</code>了，</p>
</li>
<li><p>vim</p>
<p>  如果习惯使用vim，安装vim后，也要将其<code>bin</code>目录加入到环境变量。</p>
</li>
<li><p>重启机器使生效</p>
</li>
<li><p>测试</p>
<p>  在命令行中：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br><span class="line">g++ --version</span><br><span class="line">gcc --version</span><br><span class="line">mingw32-make --version</span><br><span class="line">vim --version</span><br></pre></td></tr></table></figure>
<p>  应该返回正确内容。</p>
</li>
<li><p>使用</p>
<p>  创建project，编辑CMakeFiles.txt。project结构与在<a href="https://ashburnlee.github.io/2019/07/29/cmake%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E5%8F%8ACMakeLists-txt%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">Linux下使用cmake</a>是一样的。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">cd test</span><br><span class="line">vim main.cpp</span><br><span class="line">vim CMakeFiles.txt</span><br></pre></td></tr></table></figure>

<p>  编译执行：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G &quot;MinGW Makefiles&quot; ..</span><br><span class="line">make</span><br><span class="line">.\test.exe</span><br></pre></td></tr></table></figure>

<p>  其中<code>cmake</code>如果报错，将目录下的已存在的CMakeCache.txt删去，从新执行即可。<br>  应该可以返回期望结果。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/19/%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8MinGW-Cmake%E5%9C%A8windows/" data-id="ck5kpv8zg00007mfz4zgu9l77" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CUDA-优化优先级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/17/CUDA-%E4%BC%98%E5%8C%96%E4%BC%98%E5%85%88%E7%BA%A7/" class="article-date">
  <time datetime="2020-01-17T12:49:36.000Z" itemprop="datePublished">2020-01-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CUDA/">CUDA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/17/CUDA-%E4%BC%98%E5%8C%96%E4%BC%98%E5%85%88%E7%BA%A7/">CUDA-优化优先级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="高优先级："><a href="#高优先级：" class="headerlink" title="高优先级："></a>高优先级：</h2><ul>
<li><p>为最大化开发者的效率，使用程序分析工具来找到程序最耗时的部分，找到效率瓶颈。</p>
</li>
<li><p>最大化地利用CUDA， 首先想办法把原程序中的串行代码并行化。</p>
</li>
<li><p>使用程序使用的有效带宽最为测量性能和优化效果的指标。</p>
<ul>
<li><p>理论带宽</p>
<p>  理论带宽可以从硬件的商品指标计算得到。比如NVIDIA Tesla V100 使用 HBM2 (double data rate) RAM 时钟频率是 877 MHz。存储器位宽为 4096-bit-wide。</p>
<p>  通过上述指标可以计算这个显卡的理论带宽：</p>
<p>  <code>( 0.877 × 10^9 × ( 4096 / 8 ) × 2 ) ÷ 10^9 = 898 ⁢ GB/s ⁡</code></p>
<p>  <code>(0.877 × 10^9)</code>表示把时钟频率转化成Hz。 <code>(4096 / 8) × 2)</code>将位宽单位转化成字节， 后乘以2，由于RAM是double data rate。最后除以 <code>10^9</code> 将最终单位转化为<code>GB/s</code>。</p>
</li>
<li><p>实际带宽</p>
<p>  实际带宽通过程序的实际执行，通过下面的公式得到：</p>
<p>  <code>实际带宽 = ( ( Br + Bw ) ÷ 10^9 ) ÷ time</code> </p>
<p>  结果的单位是<code>GB/s</code>。<code>Br</code>表示每个kernel读取的字节数，<code>Bw</code>表示每个kernel写入的字节数。</p>
<p>  比如，一个程序要计算一个2048*2048的矩阵拷贝，整个过程的带宽：</p>
<p>  <code>实际带宽 = ( (  2048^2 × 4 × 2 ) ÷ 10^9 ) ÷ time</code> </p>
<p>  其中乘以4 表示矩阵每个元素的类型是float（4字节）， 乘以2是因为由读写两个过程。最后除以 <code>10^9</code> 将最终单位转化为<code>GB/s</code>。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>尽可能不使用PCIe，步进行Device和Host间的数据传输。数据传输很可能抵消掉并行带来的 性能提升。 </p>
<p>  中间数据应在Device内存中创建，销毁，由设备操作。此外，由于与每个传输相关联的开销，将许多小的传输批处理为一个较大的传输要比分别进行每个传输好得多。</p>
<p>  此外，当使用<code>pinned memory</code>时，Device和Host间的带宽更高。</p>
</li>
<li><p>尽可能确保Global memory的访问时，地址是连续的。记住，连续的threads访问连续的地址，效率是最高的。</p>
</li>
<li><p>尽量少用Global memory，尽量多的使用Shared memory。</p>
<p>  内存指令（Memory instructions）包括读取或写入shared，local或Global内存的任何指令。当访问未缓存的local或Global内存时，内存延迟有数百个时钟周期。 </p>
<p>  下边这个例子，的赋值运算符，由很高的吞吐量，但是从Global的读操作，会由上百个时钟周期的延迟。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__shared__ <span class="keyword">float</span> shared[<span class="number">32</span>];</span><br><span class="line">__device__ <span class="keyword">float</span> device[<span class="number">32</span>]; </span><br><span class="line">shared[threadIdx.x] = device[threadIdx.x];</span><br></pre></td></tr></table></figure>

<p>  如果在等待Global内存访问完成的同时，可以发出足够的独立算术指令，则线程调度程序（thread scheduler）可以隐藏大部分全局内存延迟。但是，最好尽可能避免访问全局内存。这种操作称为<code>Overlap</code></p>
<p>  总之，能不用Global memory就尽量不使用。</p>
</li>
<li><p>在一个warp中，避免出现分支，就是说，避免Divergence。 </p>
</li>
</ul>
<h2 id="中优先级"><a href="#中优先级" class="headerlink" title="中优先级"></a>中优先级</h2><ul>
<li><p>使用Shared内存以避免从Global内存进行冗余传输。见使用Shared memory对矩阵相乘进行的优化。</p>
</li>
<li><p>为每个线程保持足够的寄存器占用率。CUDA有个工具来计算资源占用率：<code>CUDA Occupancy Calculator</code></p>
</li>
<li><p>对于kernel的配置，每个block中的线程数应该是32 的倍数，CUDA中32是个特别的数字，一个warp由32 个线程，Shared memory被划分成32个banks。</p>
</li>
<li><p>在loop中，对于循环计数器，由于循环计数器的值通常都是正的，因此可能会尝试将其声明为无符号的。但是，为了获得更好的性能，应该将它们声明为signed。 </p>
</li>
<li><p>当速度超过精度时，使用快速的数学库。</p>
<p>  CUDA支持两种数学库，两种数学库通过名字区分：<code>__functionName()</code>和<code>functionName()</code>。</p>
<ul>
<li><code>__functionName()</code>运算时，直接映射到硬件层。快，但是精度低。</li>
<li><code>functionName()</code>慢，但是精度高。</li>
</ul>
</li>
<li><p>尽可能的使用更快，更专的数学库，而不是更慢，更通用的数学库。 <a href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#math-libraries" target="_blank" rel="noopener">这里</a></p>
</li>
</ul>
<h2 id="低优先级"><a href="#低优先级" class="headerlink" title="低优先级"></a>低优先级</h2><ul>
<li><p>Use zero-copy operations on integrated GPUs for CUDA Toolkit version 2.2 and later. </p>
</li>
<li><p>使用移位运算来避免昂贵的出发和取模运算。 </p>
<p>  Integer division and modulo operations are particularly costly and should be avoided or replaced with bitwise operations whenever possible: If n is a power of 2, ( i / n ) is equivalent to ( i ≫ log2 n ) and ( i % n ) is equivalent to ( i &amp; n - 1 ). </p>
</li>
<li><p>避免将双精度数自动转换为浮点数。</p>
<p>  The compiler must on occasion insert conversion instructions, introducing additional execution cycles. This is the case for:</p>
<ul>
<li><p>Functions operating on <code>char</code> or <code>short</code> whose operands generally need to be converted to an <code>int</code></p>
</li>
<li><p>Double-precision floating-point constants (defined without any type suffix) used as input to single-precision floating-point computations</p>
<p>The latter case can be avoided by using single-precision floating-point constants, defined with an <code>f</code> suffix such as <code>3.141592653589793f</code>, <code>1.0f</code>, <code>0.5f</code>.</p>
<p>For single-precision code, use of the float type and the single-precision math functions are highly recommended.</p>
<p>It should also be noted that the CUDA math library’s complementary error function, <code>erfcf()</code>, is particularly fast with full single-precision accuracy. </p>
</li>
</ul>
</li>
<li><p>让编译器很容易使用分支预测代替（in lieu of）循环或控制语句。</p>
<p>  Sometimes, the compiler may 循环展开 unroll loops or optimize out <code>if</code> or <code>switch</code> statements by using branch predication instead. In these cases, no warp can ever diverge. The programmer can also control loop unrolling using <code>#pragma unroll</code>.</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/17/CUDA-%E4%BC%98%E5%8C%96%E4%BC%98%E5%85%88%E7%BA%A7/" data-id="ck5i8gz2j0000osfz3c24d4t3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CUDA-Memory-Optimization-Local-Memory" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/15/CUDA-Memory-Optimization-Local-Memory/" class="article-date">
  <time datetime="2020-01-14T18:08:56.000Z" itemprop="datePublished">2020-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CUDA/">CUDA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/15/CUDA-Memory-Optimization-Local-Memory/">CUDA-Memory Optimization-Local Memory</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Local-Memory"><a href="#Local-Memory" class="headerlink" title="Local Memory"></a>Local Memory</h2><p>Local memory 的命周期是一个thread，它存在与Global memory中，所以对Local memory的访存是低效的。</p>
<p>Local memory 是存储自动变量的。通常自动变量是较复杂的structures 或者数组，这些对象都会消耗太多的这个线程的寄存器。当nvcc编译器发现没有足够的寄存器空间来保存变量时，就会将变量放进Local memory中。</p>
<p>有个技巧，如果一个kernel函数中需要使用数组，而且数组的长度是固定的，为了避免使用Local memory，将这个数组拆成单个的变量，这些变量会被存储到Registers中（当然是当Registers的个数足够时）。</p>
<h2 id="Constant-Memory"><a href="#Constant-Memory" class="headerlink" title="Constant Memory"></a>Constant Memory</h2><p>在Device中共有64KB大小的Constant memory。</p>
<p>如果一个warp中的所有threads同一个Constant memory，此时的访存可以和Registers一样快。</p>
<h2 id="Registers"><a href="#Registers" class="headerlink" title="Registers"></a>Registers</h2><p>通常，访问寄存器每一条指令都不会消耗额外的时钟周期，但由于寄存器的读写依赖关系和寄存器内存bank冲突，可能会出现延迟。</p>
<p>编译器和硬件线程调度程序将尽可能优化调度指令，以避免寄存器bank冲突。应用程序无法直接控制这些银行冲突。这些开发者不受控制。</p>
<p>当没有足够的寄存器可用分配给指定任务时，就会出现寄存器压力。尽管每个多处理器都包含数千个32位寄存器但它们都是在并发线程之间分配的。为了防止编译器分配太多寄存器，使用<code>-maxrregcount=N</code>编译器命令行选项（nvcc）或启动边界内核定义限定符来控制每个线程分配的寄存器的最大数量。</p>
<h2 id="Allocation"><a href="#Allocation" class="headerlink" title="Allocation"></a>Allocation</h2><p>使用cudaMallo() 和cudaFree()在Device上申请, 和回收空间是很耗时的操作，所以程序应该尽可能<font color="green">重复利用</font>已分配好的空间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/15/CUDA-Memory-Optimization-Local-Memory/" data-id="ck5e8k2x5000013fz3hk1dsh2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CUDA-Memory-Optimization-Shared-Memory" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/15/CUDA-Memory-Optimization-Shared-Memory/" class="article-date">
  <time datetime="2020-01-14T17:24:41.000Z" itemprop="datePublished">2020-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CUDA/">CUDA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/15/CUDA-Memory-Optimization-Shared-Memory/">CUDA-Memory Optimization-Shared Memory</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Shared-Memory"><a href="#Shared-Memory" class="headerlink" title="Shared Memory"></a>Shared Memory</h1><p>Shared Memory 的特点：</p>
<ul>
<li>on-chip</li>
<li>高带宽，低延时，相较于local 和 global memory</li>
<li>在线程间没有bank冲突</li>
<li>线程可通过shared memory 来进行协作。</li>
</ul>
<p>Shared Memory 的快速访问。通常将<font color="green">经常要访问的数据</font>放入shared memory，来减少访存的次数Shared Memory。</p>
<p>为了在并发访问中，实现高的内存带宽，shared memory被分成大小相等的块，<font color="green" size="4">banks</font>，这些banks可以被同时访问。所以任何对n个不同banks进行访存，这些访存是同时的。这就实现了高带宽。</p>
<p>再深入一点，shared memory 被划分为banks，一个bank对外有一个<font color="green">接口</font>，使得每个周期只相应这个bank中的一个地址。所以对于同一个bank的不同地址的并发访问将导致bank conflict。如下图中的<code>threads a</code>和<code>threads b</code>，同时访问<code>bank 1</code>，冲突了。冲突了怎么办，冲突的访存会被排队串行执行。</p>
<div align="center"><img src="/2020/01/15/CUDA-Memory-Optimization-Shared-Memory/bank.png" width="800"></div>

<p>这就是shared memory 架构的设计特点。</p>
<p>关于bank conflict：</p>
<ul>
<li><p>一个Warp中的所有（多个）threads访问不同的banks，无冲突。如图中<code>thread c</code>与<code>thread a</code>不冲突，<code>thread c</code>与<code>thread b</code>也不冲突。</p>
</li>
<li><p>一个Warp中所有（多个）的threads访问同一个地址，这是<font color="green">广播</font>，无冲突。这个地址所在的bank只相应这个地址，所以可以同时访问。[In this case, multiple broadcasts from different banks are coalesced into a single multicast from the requested shared memory locations to the threads. ]</p>
</li>
<li><p>关于bank conflict，一个Warp有32个threads，一个bank中的地址也是32，所以bank conflicts 可能发生在同一个warp中的任何线程。</p>
</li>
</ul>
<p><font color="green"></font></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/15/CUDA-Memory-Optimization-Shared-Memory/" data-id="ck5e6gyov0000kgfzer18hqiy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CUDA-APOD-Strong-Scaling-Weak-Scaling" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/14/CUDA-APOD-Strong-Scaling-Weak-Scaling/" class="article-date">
  <time datetime="2020-01-14T11:52:36.000Z" itemprop="datePublished">2020-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CUDA/">CUDA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/14/CUDA-APOD-Strong-Scaling-Weak-Scaling/">CUDA-APOD Strong-Scaling Weak-Scaling</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>读书笔记来自<a href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/" target="_blank" rel="noopener">这里</a></p>
<h1 id="APOD"><a href="#APOD" class="headerlink" title="APOD"></a>APOD</h1><ul>
<li><p><code>APOD</code> 表示Assess，Parallelize, Optimize, Deploy。是Nvidia官方提出的CUDA应用程序的周期性设计模式，目的很明确，让开发者快速找到程序中可以并行的部分，尽可能地加速计算。</p>
<ol>
<li><p>Assess 作为循环设计的入口，评估程序中最耗时的代码部分。</p>
</li>
<li><p>Parallelize 根据原始代码，调用现有的GPU优化库（如<code>cuBLAS</code>，<code>cuFFT</code>或<code>Thrust</code>），也可以简单地添加一些预处理器指令作为并行化编译器的提示。</p>
</li>
<li><p>Optimize 有很多方法，可以从很多角度，比如 overlapping data transfers， fine-tuning floating-point operation sequences 等等。这一步一定要用可用的优化工具。</p>
</li>
<li><p>Deploy 经过初步优化后，保证正确性，在有限时间内得到一个较好的结果。而不是将所有可能优化都实现。</p>
<p>根据具体任务和产品，迭代4步骤。尽可能的得到好的性能提升。</p>
</li>
</ol>
</li>
<li><p>建立优化优先级</p>
<p>  在执行优化前要建立优化优先级。</p>
<p>  高优化优先级是一些优化，这些优化对于大部分CUDA程序而言可以显著提升性能。低优化优先级是一些小的优化，这些优化可能只适用于某些特定的情况下。</p>
<p>  先处理高优先级的优化，后解决低优先级的优化。这保证了在有限时间内提供足有的结果，并且避免了过早优化（premature optimization）。 </p>
<p>  常见高优先级：</p>
<ol>
<li>用profiler工具找到最耗时的部分</li>
<li>并行处理可以并行的串行部分</li>
</ol>
</li>
</ul>
<h1 id="Host-和-Device的不同"><a href="#Host-和-Device的不同" class="headerlink" title="Host 和 Device的不同"></a>Host 和 Device的不同</h1><p>同时含有CPU和GPU的计算系统称作是异构计算系统（Heterogeneous Computing）。为了有效是哟个CUDA，有必要知道Host和Device 的不同。</p>
<ul>
<li><p>线程资源<br>  Host上的流水线可以支持有限数量的并发线程。比如，具有2个32核芯处理器的服务器只能同时运行64个线程（如果CPU支持同时多线程，那么可同时运行的线程数为64的倍数，如128，192）。</p>
<p>  相比之下，CUDA设备上最基本的并行执行单元包含32个线程（一个warp）。现代NVIDIA GPU可以在多处理器上同时支持最多2048个活动线程。如果一个GPU上有80个多处理器（SM），这表示可以有超过160000个并发活动线程。</p>
</li>
<li><p>线程本身<br>  CPU上的线程通常是重量级实体。操作系统必须用其他线程交换CPU执行通道上的线程，以提供多线程功能。因此，上下文切换（当两个线程被交换时）是缓慢而昂贵的。</p>
<p>  相比之下，GPU上的线程是轻量级。在一个典型的系统中，数千个线程排队等待工作。如果GPU要等待一个warp，它只需在另一个warp上开始执行工作。因为单独的<font color="green">寄存器</font>被分配给所有活动线程，所以在GPU线程之间切换时<font color="green">不需要交换寄存器或其他状态</font>。资源一直分配给每个线程，直到它完成执行。</p>
<p>  简而言之，CPU内核目的是最小化每次一小部分线程的等待时间，而GPU则被设计成处理大量并发、轻量级线程以最大化吞吐量。</p>
</li>
<li><p>RAM<br>  Host由CPU和系统内存构成，Device由GPU和显卡上的存储器构成。所以说，Host和Device有各自的RAM。</p>
</li>
</ul>
<p>这些是硬件层面就并行角度看的不同。总之在这样的异构系统中Host做串行工作，Device做并行工作。</p>
<h1 id="Profiling"><a href="#Profiling" class="headerlink" title="Profiling"></a>Profiling</h1><p>目的是找到程序中最耗时函数。有很多Profiler工具，比如<code>gprof</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -O2 -g -pg myprog.c</span><br><span class="line">$ gprof .&#x2F;a.out &gt; profile.txt</span><br><span class="line">Each sample counts as 0.01 seconds.</span><br><span class="line">  %   cumulative   self              self     total           </span><br><span class="line"> time   seconds   seconds    calls  ms&#x2F;call  ms&#x2F;call  name    </span><br><span class="line"> 33.34      0.02     0.02     7208     0.00     0.00  genTimeStep</span><br><span class="line"> 16.67      0.03     0.01      240     0.04     0.12  calcStats</span><br><span class="line"> 16.67      0.04     0.01        8     1.25     1.25  calcSummaryData</span><br><span class="line"> 16.67      0.05     0.01        7     1.43     1.43  write</span><br><span class="line"> 16.67      0.06     0.01                             mcount</span><br><span class="line">  0.00      0.06     0.00      236     0.00     0.00  tzset</span><br><span class="line">  0.00      0.06     0.00      192     0.00     0.00  tolower</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>其中<code>genTimeStep</code>函数是最耗时的。所以是我们优化对象</p>
<h1 id="Strong-Scaling-amp-Weak-Scaling"><a href="#Strong-Scaling-amp-Weak-Scaling" class="headerlink" title="Strong Scaling &amp; Weak Scaling"></a>Strong Scaling &amp; Weak Scaling</h1><p>这是两类不同的问题，还有两者的混合问题。</p>
<p>了解这里的目的是啥，是为我们的加速设置一个期望值，并且计划一个增强并行化的策略。</p>
<ol>
<li><p>Strong scaling 表示待解决的<font color="green">问题总体大小</font>是固定的，当使用更多的处理单元时，解决该问题的时间会相应地减少。</p>
<p> 对应的测量加速公式是<code>Amdahl&#39;s Law</code>。</p>
</li>
<li><p>Weak scaling 表示<font color="green">每个处理单元（处理器）内所解决的问题大小</font>是固定的，随着处理器数量的增加，问题的总量也会变大。</p>
<p> 对应测量加速的公式是<code>Gustafson&#39;s Law</code>。</p>
</li>
</ol>
<p>公式理解看<a href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/#understanding-scaling" target="_blank" rel="noopener">这里</a></p>
<h1 id="得到正确结果是所有计算的目的"><a href="#得到正确结果是所有计算的目的" class="headerlink" title="得到正确结果是所有计算的目的"></a>得到正确结果是所有计算的目的</h1><p>一个并行系统可能遇到的关于结果正确性的问题，这些问题在一个串行系统中是不存在的：线程问题，浮点计算带来的问题，CPU和GPU的不同计算方式带来的问题。</p>
<p><font color="green"></font></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/14/CUDA-APOD-Strong-Scaling-Weak-Scaling/" data-id="ck5dtul18000084fzd9qs2w8i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Computer-Composition" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/13/Computer-Composition/" class="article-date">
  <time datetime="2020-01-13T07:24:48.000Z" itemprop="datePublished">2020-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hardware/">Hardware</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/13/Computer-Composition/">Computer Composition</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为什么出现计算机。计算机是发展出来的。从电子管到晶体管到集成电路到超大规模集成电路，到未来的生物计算机，量子计算机。</p>
<p>早期计算机只含有固定用途的程序，这导致了，如果要改变工作内容，即程序，就需要重新设计结构电路。在没有通用计算机的当时，重新设计电路就很低效率。所以有了冯诺依曼的思想：</p>
<p>把程序存储起来，并且设计通用电路。<font color="green">当需要运行某个程序时，将程序和数据放入存储器中，把程序翻译成电路能理解的语言，让通用电路执行逻辑</font>。这就是冯诺依曼思想的核心 “<font color="green">存储程序指令，设计通用电路</font>”。</p>
<p>所以可以总结冯诺依曼体系是将<font color="green">程序指令</font>和<font color="green">数据</font>一起放入存储器的计算机设计概念。也就是说，用户只需要输入不同的程序被数据，就可以改变计算机的操作。</p>
<p>具体说就是，创造通用的指令集结构，将程序转化成一串指令的集合。指令作为一种特殊的静态数据，这使得一台计算机可以改变运行内容，而不用重新设计电路。</p>
<p>这是冯诺依曼的贡献。</p>
<p>冯诺依曼体系的基本组件：   </p>
<ol>
<li>存储器。存储运行时的程序和数据</li>
<li>程序计数器PC。执行到哪一步，下一步执行什么。能长期记忆程序数据中间结果以及最终结果</li>
<li>运算器。具备算术，逻辑运算和数据传送等数据加工处理能力</li>
<li>I/O设备。能把所需程序和数据，传送至计算机中。能将计算结果传入，输出给用户</li>
</ol>
<p>冯诺依曼体系的瓶颈：CPU和存储器速率之间的问题无法调和，CPU运算快，存储器速度慢。</p>
<p>所以有了现代计算机体系架构。但也是在冯诺依曼体系上改进的。为了解决上述瓶颈，将存储器加入到CPU中组成了现代的CPU。</p>
<p>所以现代计算机架构的核心，是以存储器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/13/Computer-Composition/" data-id="ck5du4qdy0000lefz4hfs526h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hardware/" rel="tag">hardware</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Trouble-Shooting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/13/Trouble-Shooting/" class="article-date">
  <time datetime="2020-01-12T17:49:49.000Z" itemprop="datePublished">2020-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Utility/">Utility</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/13/Trouble-Shooting/">Trouble-Shooting</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="查看所连接WiFi及psswrd"><a href="#查看所连接WiFi及psswrd" class="headerlink" title="查看所连接WiFi及psswrd"></a>查看所连接WiFi及psswrd</h2><ol>
<li><p>查看所有链接过的WiFi： </p>
<p> <code>$ cd /etc/NetworkManager/system-connections</code><br> <code>$ ls</code></p>
</li>
<li><p>选择所查看WiFi,显示配置文件：</p>
<p> <code>$ sudo vim TP-LINK_DBBB</code></p>
</li>
<li><p>对应密码在<code>wifi-security</code>字段的<code>psk</code>处</p>
</li>
</ol>
<h2 id="为应用创建快捷方式-如firefox"><a href="#为应用创建快捷方式-如firefox" class="headerlink" title="为应用创建快捷方式 如firefox"></a>为应用创建快捷方式 如firefox</h2><ol>
<li><p>下载firefox</p>
</li>
<li><p><code>$ tar -xvf firefox-70.0.1.tar.bz2</code> 解压</p>
</li>
<li><p><code>$ mv firefox /opt</code> 将解压后文件放入opt</p>
</li>
<li><p><code>$ cd /usr/share/applications</code></p>
</li>
<li><p><code>$ sudo touch firefox.desktop</code> 创建桌面图标文件</p>
</li>
<li><p><code>$ sudo vim firefox.desktop</code> 编辑文件</p>
<pre><code>[Desktop Entry]
Name=Firefox
Comment=this is firefox
Exec=/opt/firefox/firefox
Icon=/opt/firefox/chrome/default/icons/default128.png
Terminal=false
Type=Application
Categories=Application;Network;</code></pre><p> <code>Exec</code>是Firefox可执行文件的路径；<code>Icon</code>是Firefox应用图标路径</p>
</li>
<li><p><code>icon</code>加入了application 列表，便可以快速访问了</p>
</li>
</ol>
<h2 id="apt-install-fail"><a href="#apt-install-fail" class="headerlink" title="apt install fail"></a>apt install fail</h2><p>Linux 中<code>sudo apt install ...</code>时关于<code>could not get lock /var/lib/dpkg/lock -open(11:Resource temorarily unavailable)</code>的解决方案：</p>
<ul>
<li><p>第一步：找到所有含有“apt”的进程：</p>
<p>  <code>$ ps -A | grep apt</code></p>
</li>
<li><p>第二步：删除所有你含”apt”的进程：</p>
<p>  <code>$ sudo kill -9 进程ID</code></p>
</li>
</ul>
<h2 id="更新activation-key-windows"><a href="#更新activation-key-windows" class="headerlink" title="更新activation key(windows)"></a>更新activation key(windows)</h2><ul>
<li><p>卸载之前的key</p>
<p>  <code>&gt; slmgr.vbs /upk</code></p>
</li>
<li><p>安装新的key</p>
<p>  <code>&gt; slmgr /ipk XXXXX-XXXXX-XXXXX-XXXXX-XXXXX</code></p>
</li>
<li><p>设置计算机秘钥管理地址</p>
<p>  <code>&gt; slmgr /XXX.XXX.XXX</code></p>
</li>
<li><p>激活</p>
<p>  <code>&gt; slmgr /ato</code></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/13/Trouble-Shooting/" data-id="ck5bbuoh6002da2fzdz00ey6c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linear-Algebra-看待矩阵的视角" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/03/Linear-Algebra-%E7%9C%8B%E5%BE%85%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A7%86%E8%A7%92/" class="article-date">
  <time datetime="2020-01-03T06:58:28.000Z" itemprop="datePublished">2020-01-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linear-Algebra/">Linear Algebra</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/03/Linear-Algebra-%E7%9C%8B%E5%BE%85%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A7%86%E8%A7%92/">Linear Algebra-看待矩阵的视角</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>记录两种看待矩阵的重要视角，对于推理, 证明和理解线性代数其他概念都十分重要。</p>
<ul>
<li>列向量 坐标系或空间</li>
<li>行向量 函数或线性方程组</li>
</ul>
<h2 id="列视角"><a href="#列视角" class="headerlink" title="列视角"></a>列视角</h2><p>两矩阵相乘，将左边的方阵<code>A</code>看做是<font color="red">坐标系或空间</font>，右边的矩阵<code>B</code>是一个列向量的集合，每一个列向量表示在空间A的表式，而相乘的结果是在这个维度的空间中的标准正交基下的同一个列向量的表示。如</p>
<p>看个例子：</p>
<div align="center"><img src="/2020/01/03/Linear-Algebra-%E7%9C%8B%E5%BE%85%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A7%86%E8%A7%92/col.jpg" width="700"></div>


<p>把矩阵<code>A</code>看做是由列向量构成的，<code>a</code>，<code>b</code> 是两个列向量经过A变换得到的结果。<code>c</code> 是将两个列向量放在一起，构成了矩阵<code>B</code>，矩阵<code>B</code>中每个列向量经过<code>A</code>变换的结果。</p>
<p>结果是相同的。向量trans([2,3]) 是向量trans([7,7])在空间A中的表达，</p>
<h2 id="行视角"><a href="#行视角" class="headerlink" title="行视角"></a>行视角</h2><p>还可以将A看作是一个<font color="red">函数或线性方程组</font>. 右边的向量或矩阵是操作对象。 </p>
<p>看个例子：</p>
<div align="center"><img src="/2020/01/03/Linear-Algebra-%E7%9C%8B%E5%BE%85%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A7%86%E8%A7%92/row.jpg" width="700"></div>

<p>把矩阵<code>A</code>看做是由行向量构成，<code>e</code>，<code>f</code> 是分别操作两个列向量。<code>g</code> 是将两个列向量放到一起，一起处理。</p>
<p>结果相同，可以看出<code>B</code>中的列向量彼此间是无关的，都经过<code>A</code>相同的变换。</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>证明矩阵对角化中一个结论：</p>
<p>如果可以将<code>A</code>分解成<code>P*D*(P逆)</code>. 那么有<code>D</code>和<code>P</code>可以分别为：</p>
<div align="center"><img src="/2020/01/03/Linear-Algebra-%E7%9C%8B%E5%BE%85%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A7%86%E8%A7%92/PD.jpg" width="700"></div>

<p>其中<code>lambda</code>为<code>A</code>所对应的所有特征值，<code>u</code>是对应<code>lambda</code>的特征向量。(<code>P</code> 中的<code>u</code>向量竖着写)。</p>
<p>现在问题是，如何证明：如果<code>D</code>，<code>P</code>为上述矩阵，<code>A</code>有<code>n</code>个线性无关的特征向量，那么有：</p>
<center>A=P*D*(P逆)</center>

<p>证明<code>A=P*D*(P逆)</code>， 就是证明<code>AP=PD</code>，观察等号左右：</p>
<div align="center"><img src="/2020/01/03/Linear-Algebra-%E7%9C%8B%E5%BE%85%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A7%86%E8%A7%92/APPD.jpg" width="700"></div>

<p>左右相等，证毕。</p>
<p>表达式<code>i</code>中<code>A</code>为一个函数，操作与右边每一个列向量。但并没有展开，因为根据特征值特征向量的定义，可以将<code>A</code>用<code>lambda</code>替换。</p>
<p>而表达式<code>ii</code>的过程，就是将左边矩阵每一列当成一个列向量考虑，实际上，这个矩阵就是由列向量构成，所以自然而然的将这个矩阵用类向量的视角看待。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/03/Linear-Algebra-%E7%9C%8B%E5%BE%85%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A7%86%E8%A7%92/" data-id="ck5c9ovpf0000r4fzhslccvfp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-汇总ShortCuts" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/01/%E6%B1%87%E6%80%BBShortCuts/" class="article-date">
  <time datetime="2019-12-31T18:14:44.000Z" itemprop="datePublished">2020-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Utility/">Utility</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/01/%E6%B1%87%E6%80%BBShortCuts/">汇总ShortCuts</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>记录Linux平台及其上常用软件的快捷键。提升效率</p>
<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><p><code>Fn+left/right</code>: 在文本编辑时，移动cursor与行首/行尾<br><code>ctrl+left/right</code>: 文本编辑时，以单词为单位移动cursor<br>上边移动cursor时按住<code>shift</code>: 选中cursor走过的内容</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><code>Alt + F4</code>: close current window<br><code>Alt + PrtSc</code>: take <font color="gree" size="3">screen shot</font> on current window<br><code>Alt + F7</code>: move current window<br><code>Alt + F8</code>: use arrow to adjust the size of current window<br><code>Alt + arrows</code>: move out or move in a directory\<br><code>Win + D</code> : show desk</p>
<p><code>$ make clean</code>: 清理编译内容<br><code>$ make all -j4</code>: 使用4个线程编译<br><code>$ cp -r foldername ./</code>: 将foldername中所有内容复制到 当期那目录<br><code>$ rm -t foldername</code>: 删除foldername<font color="gree" size="3">及其中所有内容</font>.<br><code>$ systemctl suspend</code>: suspend mode，保存当前工作内容与内存，按任意键唤醒<br><code>$ systemctl hybernate</code>:  也是睡眠，保存当前工作内容，但要按电源键唤醒</p>
<p><code>$ sudo apt-get install -f</code>: ?<br><code>$ sudo apt-get update</code>: ?<br><code>$ sudo apt-get upgrade</code>: ?</p>
<p><code>$ Libreoffice FILENAME.odt</code>: open .odt file</p>
<p><code>$ ls | wc -l</code>: the number of files in current path<br><code>$ ls -l | grep ^- | wc -l</code>: the number of files in current directory<br><code>$ ls -l | grep ^d | wc -l</code>: the number of directories in current directory</p>
<p><code>$ mv &#39;ls | head -1000&#39; ../</code>: move first 1000 files from current to upper level<br><code>$ find /opt/opencv/ -name &quot;imgproc.hpp&quot;</code>: find file in a directory<br><code>$ sudo dpkg -i FILENAME.deb</code> : install .deb file<br><code>$ dpkg --list</code>: show installed software in system<br><code>$ sudo apt-get --purge remove (name)</code> :packages uninstall</p>
<p><code>$ df -lhT</code> :info about <font color="gree" size="3">disk</font><br><code>$ tar -zcvf 压缩包名.tar.gz 源文件</code>: 压缩.tar.gz</p>
<p><code>$ git clone URL</code> : GitHub url to current directory<br><code>$ git add FILENAME</code>: 向remote添加新文件FILENAME <br><code>$ git commit -m &quot;massage&quot;</code>: make a commitment about that change<br><code>$ git push</code>: 将本地的改变推入remote<br><code>$ git pull</code>: 更新本地repository</p>
<p><code>$ ipython trust filename.ipynb</code>: trust this notebook</p>
<p><code>$ source activate tensorflow</code>: activate tensor <font color="gree" size="3">environment</font><br><code>$ source deactivate</code>: deactive that environment</p>
<p><code>$ which/whereis/type package</code>: show <font color="gree" size="3">where</font> is that package</p>
<p><code>$ export PS1=’:&gt; ’</code>    change the prompt(shorten prompt when it is too long)<br><code>:&gt; bash</code>    change back</p>
<p><code>$ xdg-open .</code>   : open the current directory in terminal<br><code>$ sudo apt-get install alacarte</code>: 删除Linux中invalid app icon</p>
<h2 id="Chrome-amp-Firefox"><a href="#Chrome-amp-Firefox" class="headerlink" title="Chrome &amp; Firefox"></a>Chrome &amp; Firefox</h2><p><code>Ctrl + Tab</code> or <code>Ctrl + PgDn</code>: Jump to next open tab<br><code>Ctrl + Shift + Tab</code> or <code>Ctrl + PgUp</code>: Jump to the previous open tab<br><code>Ctrl + t</code>: New tab<br><code>Ctrl + w</code>: close current tab<br><code>Ctrl + n</code>: new windows</p>
<h2 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h2><p><code>ctrl + a</code>:移动光标到头<br><code>ctrl + e</code>:移动光标到尾<br><code>ctrl + u</code>:删除光标所在行<br><code>ctrl + k</code>:<br><code>ctrl + r</code>:历史中搜索<br><code>!xxx</code>: 调用最后一个以xxx开头的命令（当命令较长时）<br><code>export PS1=&quot;--&gt;&quot;</code>: 缩短命令行</p>
<h2 id="Quake-Terminal"><a href="#Quake-Terminal" class="headerlink" title="Quake Terminal"></a>Quake Terminal</h2><p><code>ctrl+shift+t</code>: new tab <br><code>ctrl+shift+w</code>: close tab<br><code>ctrl+page up</code>: go to previous tab<br><code>ctrl+page down</code>: go to next tab</p>
<h2 id="Ipython-notebook-非Edit模式下"><a href="#Ipython-notebook-非Edit模式下" class="headerlink" title="Ipython notebook (非Edit模式下)"></a>Ipython notebook (非Edit模式下)</h2><p><code>b</code>: add cell below<br><code>a</code>: add cell above<br><code>1</code>: change cell to head 1<br><code>2</code>: change cell to head 2<br><code>Esc</code>: change to command mode<br><code>Enter</code>: change to edit mode<br><code>d+d</code>: delete cell<br><code>Shift+l</code>: show/close line numbers</p>
<h2 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h2><p><code>ctrl+b</code>: pre-fix P<br><code>ctrl+b arrows</code>: move around windows<br><code>ctrl+b %</code>: split window l&amp;r<br><code>ctrl+b ”</code>: split window u&amp;d<br><code>ctrl+b x</code>: kill this split-screen<br><code>ctrl+b &amp;</code>: kill this window<br><code>kill-server</code> : kill all sessions</p>
<p>For more info check <a href="http://cenalulu.github.io/linux/tmux/" target="_blank" rel="noopener">here</a></p>
<h2 id="Intellij"><a href="#Intellij" class="headerlink" title="Intellij"></a>Intellij</h2><p><code>ctrl+shift+F7</code>:for a specific variable, highlight them<br><code>F3</code>: navigate among these variables.<br><code>ctrl+w</code>: select word<br><code>Esc</code>: quit highlights.</p>
<h2 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h2><p><code>ctrl+shift+-</code>：折叠<br><code>ctrl+shift++</code>：展开</p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><code>$ Docker(rosslee:zhen0miaod)</code>:<br><code>$ sudo docker login</code>: login my docker hub account</p>
<p><code>$ sudo docker images -a</code>: show all downloaded images<br><code>$ sudo docker rmi &lt;name|id&gt;</code>: delete downloaded image<br><code>$ sudo docker rmi $(docker images -a -q)</code> : remove all images</p>
<p><code>$ sudo docker ps -a</code>: list all containers<br><code>$ sudo docker rm &lt;name|id&gt;</code>: remove containe</p>
<h2 id="VS-2013-代码调试"><a href="#VS-2013-代码调试" class="headerlink" title="VS 2013 代码调试"></a>VS 2013 代码调试</h2><p>设置断点 -&gt; 按<code>F5</code>开始调试 -&gt; 在菜单栏中点击<code>degug</code> -&gt; <code>Windows</code> -&gt; <code>autos</code>。如此便可以看到每个变量的值随着调试的过程动态改变。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/01/%E6%B1%87%E6%80%BBShortCuts/" data-id="ck5bbuohe002ma2fz7ss33qo7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux安装cuDNN" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/31/Linux%E5%AE%89%E8%A3%85cuDNN/" class="article-date">
  <time datetime="2019-12-31T08:15:54.000Z" itemprop="datePublished">2019-12-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Utility/">Utility</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/31/Linux%E5%AE%89%E8%A3%85cuDNN/">Linux安装cuDNN</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>假设CUDA已经成功安装，先确定CUDA的版本</p>
<p>  <code>cat /usr/local/cuda/version.txt</code> </p>
</li>
<li><p>进入cudnn官网，用户登录，在cudnn下载处根据Linux机器上的CUDA版本选择对应的cudnn版本</p>
<ol>
<li><p>去<a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">nvidia cuDNN home page</a></p>
</li>
<li><p>点击下载</p>
</li>
<li><p>用户登录，完成问卷，提交</p>
</li>
<li><p>接受条款</p>
</li>
<li><p>选择与机器CUDA版本对应的cuDNN版本下载tar文件和Sample Code：</p>
<p> cuDNN Library for Linux<br> cuDNN Code Samples and User Guide for Ubuntu16.04 (Deb)</p>
</li>
</ol>
</li>
<li><p>使用tar文件安装</p>
<ol>
<li><p>转到tar文件所在目录</p>
</li>
<li><p>解压</p>
<p> <code>$ tar -xzvf cudnn-10.2-linux-x64-v7.6.5.32.tgz</code></p>
</li>
<li><p>复制文件到已安装的CUDA Toolkit目录，并且修改权限</p>
<p> <code>$ sudo cp cuda/include/cudnn.h /usr/local/cuda/include</code><br> <code>$ sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64</code><br> <code>$ sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*</code></p>
</li>
</ol>
</li>
<li><p>为了测试安装成功否，安装samples code和用户指南：</p>
<p>  <code>$ sudo dpkg -i libcudnn7-doc_7.6.5.32-1+cuda10.2_amd64.deb</code></p>
</li>
<li><p>测试</p>
<ol>
<li><p>把Samples Code 复制到可写的目录下<code>$HOME</code></p>
</li>
<li><p>进入这个可写目录</p>
<p> <code>$ cd  $HOME/cudnn_samples_v7/mnistCUDNN</code></p>
</li>
<li><p>编译 mnistCUDNN 实例</p>
<p> <code>$ make clean &amp;&amp; make</code></p>
</li>
<li><p>运行可执行文件</p>
<p> <code>$ ./mnistCUDNN</code></p>
<p> 如果可以返回如下，表示安装成功：</p>
<p> <code>Test passed!</code></p>
</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/31/Linux%E5%AE%89%E8%A3%85cuDNN/" data-id="ck5bbuoh10027a2fz49pf04lp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CUDA/">CUDA</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hardware/">Hardware</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linear-Algebra/">Linear Algebra</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Utility/">Utility</a><span class="category-list-count">9</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CUDA/" rel="tag">CUDA</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hardware/" rel="tag">hardware</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithms/" style="font-size: 15px;">Algorithms</a> <a href="/tags/CUDA/" style="font-size: 20px;">CUDA</a> <a href="/tags/hardware/" style="font-size: 10px;">hardware</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/01/">January 1970</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/19/%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8MinGW-Cmake%E5%9C%A8windows/">安装使用MinGW Cmake在windows</a>
          </li>
        
          <li>
            <a href="/2020/01/17/CUDA-%E4%BC%98%E5%8C%96%E4%BC%98%E5%85%88%E7%BA%A7/">CUDA-优化优先级</a>
          </li>
        
          <li>
            <a href="/2020/01/15/CUDA-Memory-Optimization-Local-Memory/">CUDA-Memory Optimization-Local Memory</a>
          </li>
        
          <li>
            <a href="/2020/01/15/CUDA-Memory-Optimization-Shared-Memory/">CUDA-Memory Optimization-Shared Memory</a>
          </li>
        
          <li>
            <a href="/2020/01/14/CUDA-APOD-Strong-Scaling-Weak-Scaling/">CUDA-APOD Strong-Scaling Weak-Scaling</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Junhui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>