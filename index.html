<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Junhui&#39;s Journal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Junhui&#39;s Journal">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Junhui&#39;s Journal">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Junhui">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Junhui&#39;s Journal" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junhui&#39;s Journal</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CUDA-线程-warp-延时隐藏" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/19/CUDA-%E7%BA%BF%E7%A8%8B-warp-%E5%BB%B6%E6%97%B6%E9%9A%90%E8%97%8F/" class="article-date">
  <time datetime="2020-07-19T08:31:43.000Z" itemprop="datePublished">2020-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CUDA/">CUDA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/19/CUDA-%E7%BA%BF%E7%A8%8B-warp-%E5%BB%B6%E6%97%B6%E9%9A%90%E8%97%8F/">CUDA-线程-warp-延时隐藏</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h1><p>一个线程包括程序代码，程序执行当前点，变量数值和数据结构。线程的执行是串行的。CUDA启动kernel后，启动大量线程，以充分利用数据的并行性。</p>
<p>CPU中的线程生成和调度需要上千的时钟周期，相比GPU只需要很少的时钟周期。更具体说，在一个Warp中的线程的切换几乎是没有开销的，因为线程的上下文直接存储在物理空间中。</p>
<h1 id="线程是如何实现的"><a href="#线程是如何实现的" class="headerlink" title="线程是如何实现的"></a>线程是如何实现的</h1><p>线程是啥，在上面说过了。程序的代码存储在主存中，寄存器PC记录程序执行点，寄存器IR存储当前需要执行的指令，寄存器和主存记录变量值和数据结构。</p>
<p>同CPU一样，GPU也提供上下文切换功能，多个线程以轮的方式共享处理单元，通过保存和恢复PC值，寄存器和存储器的内容，可以暂停一个线程的执行，并在稍后正确地恢复这个线程。</p>
<p>GPU的每个SM提供多个执行单元SP，他们共享一个PC和IR（存在与共享的控制单元中），如此以来同一时间，所有的线程执行形同的指令（这个指令就是IR中所存储内容）。</p>
<h1 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h1><p><code>SIMD</code>系统中，所有的并行处理单元在任何时候都执行相同的指令。因为是<code>单指令</code>。</p>
<p>CUDA采用的是<code>SPMD</code>，单程序多数据的执行形式，但是在一个SM内部其实是<code>SIMD</code>执行warp中的所有线程，单指令多数据。这涉及到warp的工作原理。</p>
<h1 id="warp与延时隐藏"><a href="#warp与延时隐藏" class="headerlink" title="warp与延时隐藏"></a>warp与延时隐藏</h1><p>一个Block中的线程被进一步分为32个为一个<code>warp</code>。由于<code>单指令</code>的定义，任何时刻一个warp中的所有线程只能取一条指令执行（IR中的指令）。在硬件结构中，每个SM有一个<code>取指/分派</code>单元，由这个单元来向warp中的线程提供所要执行的指令。warp中每个线程的数据不同，但执行时间都相同。</p>
<p>一个SM中的使用线程数要多于SP数量，SM中硬件只能执行所有warp的一部分，这样做的目的是提高长延时操作的效率，达到延时隐藏的目的。具体说：<font color="red">当一个warp的一条指令需要等待一个长延时的操作时，这个warp将不会被SP选中执行，这个SP会去执行不需要等待的warp，从而达到隐藏等待时间的目的</font>。所以当由足够多的warp时，硬件可以随时找到可悲执行的warp，如此变充分利用硬件资源。warp的被选择是零开销的。<code>零开销的线程调度</code>。在warp的调度机制下，长延迟的操作被其他warp的指令执行隐藏，即<code>延时隐藏</code>。</p>
<p>这也是为什么GPU不像CPU一样引入大量的缓存和分支预测，为了将更多的芯片面积作为浮点数的计算资源。</p>
<p>Warp中的线程访问Global memory时，做好的访问方式是<code>coalesced access</code>即连续访问，如果不是连续访问，则会由于<code>Cache miss</code>增加移动数据的开销。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/19/CUDA-%E7%BA%BF%E7%A8%8B-warp-%E5%BB%B6%E6%97%B6%E9%9A%90%E8%97%8F/" data-id="ckcsttzgg00003yfz2j602yx9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CUDA/" rel="tag">CUDA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-Trie-search-regular-expression" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/LeetCode-Trie-search-regular-expression/" class="article-date">
  <time datetime="2020-07-14T07:37:29.000Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/LeetCode-Trie-search-regular-expression/">LeetCode-Trie-search regular expression</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>设计一个数据结构，并且实现两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void addWord(word)</span><br><span class="line">bool search(word)</span><br></pre></td></tr></table></figure>

<p>其中word中孩子包含26个字母，而需要查找的pattern是26个字母和’.’，’.’可以匹配任何一个字母，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addWord(&quot;bad&quot;)</span><br><span class="line">addWord(&quot;dad&quot;)</span><br><span class="line"></span><br><span class="line">search(&quot;pad&quot;) -&gt; false</span><br><span class="line">search(&quot;bad&quot;) -&gt; true</span><br><span class="line">search(&quot;.ad&quot;) -&gt; true</span><br><span class="line">search(&quot;b..&quot;) -&gt; true</span><br></pre></td></tr></table></figure>

<h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> is_word;</span><br><span class="line">    TrieNode* next[<span class="number">26</span>];</span><br><span class="line">    TrieNode(<span class="keyword">bool</span> b=<span class="literal">false</span>)&#123;</span><br><span class="line">        is_word = b;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"><span class="comment">/// 后续遍历，销毁Trie</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(TrieNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;next[i] != <span class="literal">nullptr</span>)</span><br><span class="line">                clear(root-&gt;next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/// 递归实现匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search_</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* word, TrieNode* root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 遍历word中每一个字符</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; word[i]&amp;&amp;root; i++)&#123;</span><br><span class="line">            <span class="comment">// 如果当前字符　是26个字母，指针向下移动即可</span></span><br><span class="line">			<span class="keyword">if</span> (word[i] != <span class="string">'.'</span>)&#123;</span><br><span class="line">				root　=　root-&gt;next[word[i]-<span class="string">'a'</span>];</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 如果当前字符是'.'，</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">				TrieNode* node = root;</span><br><span class="line">                <span class="comment">// 遍历这个结点next所有域，</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">					root = node-&gt;next[j];</span><br><span class="line">					<span class="keyword">if</span> (search_( word+i+<span class="number">1</span>, root))&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root &amp;&amp; root-&gt;is_word;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WordDictionary() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    ~WordDictionary()&#123;</span><br><span class="line">        clear(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode* tmp = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;next[word[i]-<span class="string">'a'</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">                tmp-&gt;next[word[i]-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            tmp = tmp-&gt;next[word[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;is_word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/// 匹配入口</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> search_(word.c_str() ,root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>体会递归函数：<code>search_()</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/LeetCode-Trie-search-regular-expression/" data-id="ckcsttzgm00013yfzfnqa53x3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-Trie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/12/LeetCode-Trie/" class="article-date">
  <time datetime="2020-07-12T08:18:42.000Z" itemprop="datePublished">2020-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/12/LeetCode-Trie/">LeetCode-Trie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Trie是用来存储和查找大量string的带有结点和边的树型结构。对于字母string来讲，每个结点最多有26个子节点，如此构成一棵多叉树。这棵树的每一条从root的下一个结点到任意结点都是一个string。</p>
<p>Trie的结点可以如下定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> is_word;</span><br><span class="line"></span><br><span class="line">    TrieNode(<span class="keyword">bool</span> b = <span class="literal">false</span>)&#123;</span><br><span class="line">        is_word = b;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p><code>memset(next, 0, sizeof(next))</code>表示在<code>next</code>地址，从头开始将<code>sizeof(next)</code>个字节设置为<code>0</code>（<code>0</code>在此其实是<code>nullptr</code>，表示初始化不指向任何地址。）</p>
</li>
<li><p><code>memset(next, 0, sizeof(next))</code>等价于：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">    next[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 手动将所有next指针域置为空。</p>
</li>
<li><p>所有<code>next</code>结点的<code>is_word</code>默认为<code>false</code>。</p>
</li>
<li><p><font color="red">指针指向一个结点的首地址，所以一个结点的成员不同，首地址不同</font>。</p>
</li>
</ol>
<p>每个结点有26个子节点和一个bool型的成员。bool成员表示从root到当前结点的上一个结点形成的路径，这条路径表示的string是否存在于Trie中的。当为True时，这条路径表示的string存在于Trie，False则为不存在。看下图。</p>
<p>有了结点，可以构造Trie。开辟root空间即可，之后便可以向其中保存指定string，在其中搜索指定string。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Trie START</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Trie()&#123; root = <span class="keyword">new</span> TrieNode(); &#125;</span><br><span class="line">	~Trie()&#123; clear(root); &#125;</span><br></pre></td></tr></table></figure>
<p>初始化一个Trie，构造一个Trie结点作为root。</p>
<p>Trie的成员方法：</p>
<p>向Trie中添加string。只要遍历整个string，若没有当前字母，则新建一个结点；否则，自自由指针向下移动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// tmp为自由指针，</span></span><br><span class="line">       TrieNode* tmp = root;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(tmp-&gt;next[word[i] - <span class="string">'a'</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">               tmp-&gt;next[word[i] - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">           tmp = tmp-&gt;next[word[i]-<span class="string">'a'</span>];</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">// 将单词结尾设为true，表示这条路径是一个单词</span></span><br><span class="line">       tmp-&gt;is_word = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p><code>tmp-&gt;next[word[i] - &#39;a&#39;] = new TrieNode();</code>智力只是开辟了空间，并没有向其中写入当前的字母，<font color="red">这里是使用26个不同 的位置来唯一标识每一个字母。如果字母‘b’出现，那么next的第二个位置（next[word[i] - ‘a’]）将指向一个新的<code>TrieNode</code>结点，</font>当然也可以使用其他TrieNode的实现方式，比如将26个字符作为<code>key</code>，将其子节点设为<code>value</code>，这种字典类型。下图是个例假设只有abc三个字符，将string <code>bac</code>插入Trie的过程：</p>
 <div align="center"><img src="/2020/07/12/LeetCode-Trie/trie.png" width="500"></div>

 <div align="center">将“bac”插入Trie</div>
</li>
<li><p><code>is_word</code>默认是<code>false</code>，但一个单词写入trie结束后，手动将最后一个字母的下一个结点的<code>is_word</code>置为<code>true</code>。</p>
</li>
</ol>
<p>在trie中搜索一个string：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// tmp指向单词的最后一个字母结点</span></span><br><span class="line">       TrieNode* tmp = find_string(word);</span><br><span class="line">	<span class="comment">// 如果tmp（这个单词的最后一个字母）不是空且tmp的bool为true，</span></span><br><span class="line">	<span class="comment">// 表示由完整的这个单词</span></span><br><span class="line">       <span class="keyword">if</span>(tmp != <span class="literal">nullptr</span> &amp;&amp; (tmp-&gt;is_word))</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在trie中搜索一个前缀。与<code>search</code>方法唯一的区别是，不论tmp的<code>is_word</code>是否为true，即prefix是否是一个完整的单词，都就算找到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">startWith</span><span class="params">(<span class="built_in">string</span> prifix)</span> </span>&#123;</span><br><span class="line">       TrieNode* tmp = find_string(prifix);</span><br><span class="line">       <span class="keyword">if</span>(tmp != <span class="literal">nullptr</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从Trie 中删除一个已经存在的word。只需要将这个word末尾结点的<code>is_word</code>置位false即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="built_in">string</span> word)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (search(word))&#123;</span><br><span class="line">		TrieNode* tmp = root;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.size();i++)&#123;</span><br><span class="line">			tmp = tmp-&gt;next[word[i]-<span class="string">'a'</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		tmp-&gt;is_word = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Trie对象的头：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	TrieNode* root;</span><br></pre></td></tr></table></figure>

<p>找到word的最后一个字母的结点:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TrieNode* <span class="title">find_string</span><span class="params">(<span class="built_in">string</span> word)</span></span>&#123;</span><br><span class="line">       TrieNode* tmp = root;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(tmp-&gt;next[word[i] - <span class="string">'a'</span>] != <span class="literal">nullptr</span>)</span><br><span class="line">               tmp = tmp -&gt; next[word[i] - <span class="string">'a'</span>];</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               tmp = <span class="literal">nullptr</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tmp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历 释放Trie</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(TrieNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[i] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                clear(root-&gt;next[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/// Trie END</span></span><br></pre></td></tr></table></figure>

<p><font color="gree" size="6">敲黑板</font>：<code>TrieNode</code>结点的定义与链表结点定义，树结点定义相同。都会有若干自身类型的指针，且这些指针初始化为nullptr，表示指针不保存任何地址。当其中某个指针要指向一个新的结点时：<code>tmp-&gt;next[word[i] - &#39;a&#39;] = new TrieNode()</code>，先开辟一个结点空间，后将其地址存入指针。如此，由结点构成的链就形成了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/12/LeetCode-Trie/" data-id="ckcivyhhh00041pfzfiszg5jt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-BST-找前驱与后继结点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/11/LeetCode-BST-%E6%89%BE%E5%89%8D%E9%A9%B1%E4%B8%8E%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9/" class="article-date">
  <time datetime="2020-07-11T12:52:30.000Z" itemprop="datePublished">2020-07-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/11/LeetCode-BST-%E6%89%BE%E5%89%8D%E9%A9%B1%E4%B8%8E%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9/">LeetCode-BST 找前驱与后继结点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>描述：<br>加入构造了一BST： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     6</span><br><span class="line"> / \    /\</span><br><span class="line">1   3  5  7</span><br></pre></td></tr></table></figure>

<p>现在要找到每个结点的前驱和后继结点。</p>
<p>思路：</p>
<p>可以将树的所有结点有序存储，后对于这个有序的数组操作。这里给出递归的思路。</p>
<ol>
<li><p>对于前驱结点。</p>
<p> 第一步，首先搜索目标结点，即谁的前驱。这个过程是<code>左-&gt;中-&gt;右</code>中序遍历，过程中记录target结点属于第几大的结点，将结果保存到<code>count</code>中。</p>
<p> 第二步。重新<code>左-&gt;中-&gt;右</code>中序遍历，找到第<code>count-1</code>大的结点，即第一个比target小的结点。</p>
</li>
<li><p>对于后继结点。</p>
<p> 第一步，首先搜索目标结点，即谁的后驱。这个过程是<code>左-&gt;中-&gt;右</code>中序遍历，过程中记录target结点属于第几大的结点，将结果保存到<code>count</code>中。</p>
<p> 第二步。重新<code>左-&gt;中-&gt;右</code>中序遍历，找到第<code>count+1</code>大的结点，即第一个比target大的结点。</p>
</li>
</ol>
<p>实现过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sol_successor_predecessor</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/// 前驱结点的入口函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">predecessor</span><span class="params">(TreeNode* root, <span class="keyword">const</span> TreeNode* <span class="keyword">const</span> target, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 遍历的count_</span></span><br><span class="line">		inOrder(root, target, count);</span><br><span class="line">        <span class="comment">// 搜索第count_-1的结点</span></span><br><span class="line">		predecessor_(root, target);</span><br><span class="line">		<span class="keyword">if</span> (res_)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"predecessor node: "</span>&lt;&lt;res_-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"predecessor node: nullptr"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">		count_=<span class="number">0</span>;</span><br><span class="line">		res_=<span class="literal">nullptr</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/// 后继结点的入口函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">successor</span><span class="params">(TreeNode* root, <span class="keyword">const</span> TreeNode* <span class="keyword">const</span> target, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 遍历的count_</span></span><br><span class="line">		inOrder(root, target, count);</span><br><span class="line">        <span class="comment">// 搜索第count_+1的结点</span></span><br><span class="line">		successor_(root, target);</span><br><span class="line">		<span class="keyword">if</span> (res_)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"successor node: "</span>&lt;&lt;res_-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"successor node: nullptr"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">		count_=<span class="number">0</span>;</span><br><span class="line">		res_=<span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> count_ = <span class="number">0</span>;</span><br><span class="line">	TreeNode* res_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// find the predecessor when count_ decreased to 1</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">predecessor_</span><span class="params">(TreeNode* root, <span class="keyword">const</span> TreeNode* <span class="keyword">const</span> target)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root!=<span class="literal">nullptr</span> )&#123;</span><br><span class="line">            predecessor_(root-&gt;left, target);  </span><br><span class="line">			count_--; </span><br><span class="line">            <span class="comment">// 直到count_ 减掉count_-1个数后，找到前驱结点</span></span><br><span class="line">			<span class="keyword">if</span> (count_ == <span class="number">1</span>)&#123;</span><br><span class="line">				res_ = root;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            predecessor_(root-&gt;right, target);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/// find the successor when count_ decreased to -1</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">successor_</span><span class="params">(TreeNode* root, <span class="keyword">const</span> TreeNode* <span class="keyword">const</span> target)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root!=<span class="literal">nullptr</span> )&#123;</span><br><span class="line">            successor_(root-&gt;left, target);  </span><br><span class="line">			count_--; </span><br><span class="line">            <span class="comment">// 直到count_ 减掉count_+1个数后，找到后继结点</span></span><br><span class="line">			<span class="keyword">if</span> ( count_ == <span class="number">-1</span>)&#123;</span><br><span class="line">				res_ = root;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            successor_(root-&gt;right, target);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// traverse to find the target node, and keep counting</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, <span class="keyword">const</span> TreeNode* <span class="keyword">const</span> target, <span class="keyword">int</span>&amp; count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            inOrder(root-&gt;left, target, count);  </span><br><span class="line">			count++;</span><br><span class="line">			<span class="keyword">if</span> (root-&gt;val == target-&gt;val)&#123;</span><br><span class="line">                <span class="comment">// 记录target结点是第几大的结点</span></span><br><span class="line">				count_ = count;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;  </span><br><span class="line">            inOrder(root-&gt;right, target, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>过程如注释。测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 后续遍历 用于销毁Tree</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroyTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root)&#123;</span><br><span class="line">		destroyTree(root-&gt;left);</span><br><span class="line">		destroyTree(root-&gt;right);</span><br><span class="line">		<span class="keyword">delete</span> root;</span><br><span class="line">		root = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">	TreeNode* root = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">	TreeNode* node1 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">	TreeNode* node2 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">	TreeNode* node3 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">	TreeNode* node4 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">	TreeNode* node5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">	TreeNode* node6 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// create a tree</span></span><br><span class="line">	root-&gt;left = node1;</span><br><span class="line">	root-&gt;right = node2;</span><br><span class="line"></span><br><span class="line">	node1-&gt;left = node3;</span><br><span class="line">	node1-&gt;right = node4;</span><br><span class="line"></span><br><span class="line">	node2-&gt;left = node5;</span><br><span class="line">	node2-&gt;right = node6;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// create a vector</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;TreeNode*&gt; treeVec = &#123;node3,node1,node4,root,node5, </span><br><span class="line">								node2, node6&#125;;</span><br><span class="line">	Sol_successor_predecessor sol;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> item: treeVec)&#123;</span><br><span class="line">		sol.predecessor(root, item, <span class="number">0</span>);</span><br><span class="line">		sol.successor(root, item, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/// 销毁</span></span><br><span class="line">    destroyTree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">target node: <span class="number">1</span></span><br><span class="line">predecessor node: <span class="literal">nullptr</span></span><br><span class="line">successor node: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">target node: <span class="number">2</span></span><br><span class="line">predecessor node: <span class="number">1</span></span><br><span class="line">successor node: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">target node: <span class="number">3</span></span><br><span class="line">predecessor node: <span class="number">2</span></span><br><span class="line">successor node: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">target node: <span class="number">4</span></span><br><span class="line">predecessor node: <span class="number">3</span></span><br><span class="line">successor node: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">target node: <span class="number">5</span></span><br><span class="line">predecessor node: <span class="number">4</span></span><br><span class="line">successor node: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">target node: <span class="number">6</span></span><br><span class="line">predecessor node: <span class="number">5</span></span><br><span class="line">successor node: <span class="number">7</span></span><br><span class="line"></span><br><span class="line">target node: <span class="number">7</span></span><br><span class="line">predecessor node: <span class="number">6</span></span><br><span class="line">successor node: <span class="literal">nullptr</span></span><br></pre></td></tr></table></figure>

<p>结果正确。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/11/LeetCode-BST-%E6%89%BE%E5%89%8D%E9%A9%B1%E4%B8%8E%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9/" data-id="ckcivyhhh00031pfzh7jm7rho" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CUDA-并行Radix-Sort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/08/CUDA-%E5%B9%B6%E8%A1%8CRadix-Sort/" class="article-date">
  <time datetime="2020-07-08T05:42:56.000Z" itemprop="datePublished">2020-07-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CUDA/">CUDA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/08/CUDA-%E5%B9%B6%E8%A1%8CRadix-Sort/">CUDA-并行Radix Sort</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="啥是Radix-Sorting"><a href="#啥是Radix-Sorting" class="headerlink" title="啥是Radix Sorting"></a>啥是Radix Sorting</h1><h1 id="Radix-Sorting-CPU-版本"><a href="#Radix-Sorting-CPU-版本" class="headerlink" title="Radix Sorting CPU 版本"></a>Radix Sorting CPU 版本</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_ELEM 100</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_sort</span><span class="params">(<span class="keyword">int32_t</span>* <span class="keyword">const</span> data, <span class="keyword">const</span> <span class="keyword">int32_t</span> num_elements)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int32_t</span> cpu_tmp_0[NUM_ELEM];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int32_t</span> cpu_tmp_1[NUM_ELEM];</span><br><span class="line">    <span class="comment">// for every bits of an element</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int32_t</span> bit=<span class="number">0</span>; bit&lt;<span class="number">32</span>; bit++) &#123;</span><br><span class="line">		<span class="keyword">int32_t</span> base_cnt_0 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int32_t</span> base_cnt_1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for every elements</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span>; i&lt;num_elements; i++)&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int32_t</span> d = data[i];</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int32_t</span> bit_mask = (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">			<span class="keyword">if</span> ( (d &amp; bit_mask) &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">				cpu_tmp_1[base_cnt_1] = d;</span><br><span class="line">				base_cnt_1++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				cpu_tmp_0[base_cnt_0] = d;</span><br><span class="line">				base_cnt_0++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Copy data back to source - first the ZERO list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span>; i&lt;base_cnt_0; i++)&#123;</span><br><span class="line">			data[i] = cpu_tmp_0[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Copy data back to source - then the ONE list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span>; i&lt;base_cnt_1; i++)&#123;</span><br><span class="line">			data[base_cnt_0+i] = cpu_tmp_1[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述过程没有办法并行，但是可以将Radix排序作为基本算子，将待处理的数组分成若干段，段与段之间并行执行Radix排序，之后调用Merge，将所有段（每一段都是有序的）并行归于成一段。这就是基本平行排序思路。</p>
<p>有了这个并行思路，对于排序算子，就可以使用任何可行的排序方法了。</p>
<p>先实现CPU的对多个有序数组的Merge操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并多个有序的子序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_arrays</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* src_array, </span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">int</span>* <span class="keyword">const</span> dest_array,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">const</span> <span class="keyword">int</span> num_lists, </span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">const</span> <span class="keyword">int</span> num_elements)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> num_element_per_list = (num_elements/num_lists);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> list_indexes[<span class="number">5</span>]; <span class="comment">// 分成5段</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;num_lists; l++)&#123;</span><br><span class="line">		list_indexes[l] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num_elements; i++)&#123;</span><br><span class="line">		dest_array[i] = find_min(src_array, </span><br><span class="line">								list_indexes,</span><br><span class="line">								num_lists,</span><br><span class="line">								num_element_per_list);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有段（子序列），找到当前所有段段首的最小值，写入目标数组的对应位置。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* src_array,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">int</span>* <span class="keyword">const</span> list_indexes,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">const</span> <span class="keyword">int</span> num_lists,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">const</span> <span class="keyword">int</span> num_elements_per_list)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> min_val = INT_MAX;</span><br><span class="line">	<span class="keyword">int</span> min_idx = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// Iterate over each of the lists</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num_lists; i++)&#123;</span><br><span class="line">	<span class="comment">// If the current list has already been emptied</span></span><br><span class="line">	<span class="comment">// then ignore it</span></span><br><span class="line">		<span class="keyword">if</span> (list_indexes[i] &lt; num_elements_per_list)&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int</span> src_idx = list_indexes[i] + num_elements_per_list * i;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int</span> data = src_array[src_idx];</span><br><span class="line">			<span class="keyword">if</span> (data &lt;= min_val)&#123;</span><br><span class="line">				min_val = data;</span><br><span class="line">				min_idx = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	list_indexes[min_idx]++;</span><br><span class="line">	<span class="keyword">return</span> min_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 共有15个元素，分成5段，每一段都有序。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = &#123;	<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,</span><br><span class="line">						<span class="number">1</span>,<span class="number">90</span>,<span class="number">91</span>,</span><br><span class="line">						<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,</span><br><span class="line">						<span class="number">10</span>,<span class="number">11</span>,<span class="number">13</span>,</span><br><span class="line">						<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Radix-Sorting-GPU-版本"><a href="#Radix-Sorting-GPU-版本" class="headerlink" title="Radix Sorting GPU 版本"></a>Radix Sorting GPU 版本</h1><p>这个在Thrust库中有相应实现。</p>
<p><font color="green" size="6">敲黑板</font>：每一个数与其二进制对应，Radix排序方法对二进制做判断，而在源数上做操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/08/CUDA-%E5%B9%B6%E8%A1%8CRadix-Sort/" data-id="ckcivyhh900001pfz70snajpi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CUDA/" rel="tag">CUDA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-判断链表是否相交" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/02/LeetCode-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/" class="article-date">
  <time datetime="2020-07-02T01:12:08.000Z" itemprop="datePublished">2020-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/02/LeetCode-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/">LeetCode-判断链表是否相交</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>描述：两个链表，均没有环，判断这两个链表是否相交。</p>
<p>关键要知道：链表中一个结点的唯一标识是它的地址。若两个结点的地址相同，表示这是同一个结点。</p>
<p>给出结点的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(<span class="number">0</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="方法一-遍历"><a href="#方法一-遍历" class="headerlink" title="方法一 遍历"></a>方法一 遍历</h1><p>对于相交的情况像字母“Y”，即只要有一个结点开始相同，那么之后的结点都相同。这种情况下，只要有相交，那么两个链表的最后一个结点一定相同。所以，分别遍历两个链表，记录尾结点，判断为节点是否是同一个结点。</p>
<p>时间复杂度是O(M+N)，空间复杂度是O(1)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLists1</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>&#123;</span><br><span class="line">    ListNode* dhead1 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head1);</span><br><span class="line">    ListNode* dhead2 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head2);</span><br><span class="line">    ListNode* cur1 = dhead1;</span><br><span class="line">    ListNode* cur2 = dhead2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur1-&gt;next)&#123;</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2-&gt;next)&#123;</span><br><span class="line">        cur2 = cur2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur1==cur2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，由于链表结点的定义，指出，一个结点只有一个next指针域，所以不会出现像字母“X”的相交情况。</p>
<h1 id="方法二-连接两个链表"><a href="#方法二-连接两个链表" class="headerlink" title="方法二 连接两个链表"></a>方法二 连接两个链表</h1><p>可以将链表1的尾接到链表2的头，此时遍历链表1，如果遍历指针走到了链表的结尾，即<code>nullptr</code>，表示新的链表中没有环，原链表不相交；若有环，则原链表相交。</p>
<p>时间复杂度是O(M+N)，空间复杂度是O(1)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLists2</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head1 || !head2 ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ListNode* dhead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head1);</span><br><span class="line">    </span><br><span class="line">    ListNode* needle = dhead;</span><br><span class="line">    <span class="comment">// move needle to the end of head1</span></span><br><span class="line">    <span class="keyword">while</span> (needle-&gt;next)&#123;</span><br><span class="line">        needle = needle-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// link the tail of head1 to the head of head2;</span></span><br><span class="line">    needle-&gt;next = head2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if there exists a loop</span></span><br><span class="line">    <span class="keyword">return</span> hasCycle(head1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>hasCycle()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; slow)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast) fast = fast-&gt;next;</span><br><span class="line">        <span class="comment">// 先判断移动后的fast是否非空</span></span><br><span class="line">        <span class="keyword">if</span> (fast &amp;&amp; fast==slow)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法三-使用查找表"><a href="#方法三-使用查找表" class="headerlink" title="方法三 使用查找表"></a>方法三 使用查找表</h1><p>将head1的结点放入set，然后对于head2中每个结点，在set中find()，如果能找到，则表示由公共的结点，交叉；否则不交叉。</p>
<p>时间复杂度：O(max(M,N)), 空间复杂度：O(M)。需要M的空间创造查找表set。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLists3</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;ListNode*&gt; st;</span><br><span class="line">    ListNode* cur = head1;</span><br><span class="line">    <span class="comment">// 将head1的结点放入set</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        st.insert(cur);</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head2;</span><br><span class="line">    <span class="comment">// 从head2中，对每个结点在set中find，</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span> (st.find(cur)!=st.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在如果进一步要求出相交的结点是哪个，如何求？</p>
<p>方法一不适用，方法二，可以修改为带环的链表求环的入口，看笔记<a href="https://ashburnlee.github.io/2020/06/23/LeetCode-%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">LeetCode-链表相关</a>的<code>#142</code>。</p>
<p>方法三，只需要将查找表改为顺序存储，即可，如此找到的公共结点就是第一个在查找表中找到的结点。</p>
<p><font color="gree" size="5">强调</font>：链表中一个结点的唯一标识是它的地址。当打印一个<code>ListNode* head</code>时，打印的是head中的内容，即一个结点对象的地址。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/02/LeetCode-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/" data-id="ckc4dw37x0000oafz60e0hnna" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cpp-静态内存-栈内存-动态内存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/01/cpp-%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98-%E6%A0%88%E5%86%85%E5%AD%98-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" class="article-date">
  <time datetime="2020-06-30T21:11:47.000Z" itemprop="datePublished">2020-07-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/01/cpp-%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98-%E6%A0%88%E5%86%85%E5%AD%98-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">cpp-静态内存-栈内存-动态内存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一个cpp程序会使用到的内存类型有：</p>
<ol>
<li>静态内存：用来保存局部static变量，类中static变量，任何函数外的全局变量。</li>
<li>栈内存（stack）：保存定义在函数内的非static变量。</li>
<li>动态内存（heap）：存储动态分配的对象。但是使用完后，调用着必须显式地将空间释放。通常使用<code>new</code>和<code>delete</code>关键字。</li>
</ol>
<p>动态内存使用时，<code>new</code>在动态内存中分配空间并且返回一个指向该空间的指针（两件事）。<code>delete</code>时，接受一个动态对象的指针，销毁该指针所指向的对象，并释放空间。</p>
<p>但是在正确的时间释放空间有时是很困难的，为了可以安全的使用动态内存，标准库提供了智能指针：<code>shared_ptr</code>和<code>unique_ptr</code>。</p>
<p>多个<code>shared_ptr</code>能共享一个对象；而一个<code>unique_ptr</code>只能独享一个对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/01/cpp-%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98-%E6%A0%88%E5%86%85%E5%AD%98-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" data-id="ckc2s7hgg0000plfz8hn9blkr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-比特币-以太坊-区块链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/30/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%8C%BA%E5%9D%97%E9%93%BE/" class="article-date">
  <time datetime="2020-06-30T02:05:51.000Z" itemprop="datePublished">2020-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%85%E5%BD%92%E7%B1%BB/">待归类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/30/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%8C%BA%E5%9D%97%E9%93%BE/">比特币-以太坊-区块链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本笔记内容来自卓克讲座及讨论内容。</p>
<h2 id="比特币的目"><a href="#比特币的目" class="headerlink" title="比特币的目"></a>比特币的目</h2><p>比特币的目的是生成一个任何人都不能更改的<font color="orange">账本</font>，这个账本在分布式系统中的每一个结点都保存一份，并且同步更新。账本可以是一条交易记录，比如：我向李三转账100个比特币。这个动作，在相应的软件上会做3件事：</p>
<ol>
<li>将“我向李三转账100个比特币”作为<code>原始信息</code>，对其做一次SHA-256运算，得到的结果是一个<code>原哈希值</code>。</li>
<li>用我自己的私钥给上一个结果（原哈希值）加密，得到加密后的<code>密哈希</code>。</li>
<li>将<code>原始信息</code>，<code>公钥</code>（我自己的私钥对应的公钥），<code>密哈希</code>，3项内容广播到网络中。</li>
</ol>
<div align="center"><img src="/2020/06/30/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%8C%BA%E5%9D%97%E9%93%BE/graph1.png" width="500"></div>

<p>之后图中三个矩形框的内容就被广播到网络中。</p>
<p>对任何内容进行<font color="orange">SHA-256运算</font>都能生成唯一的256bit的二进制数，没有办法从这个二进制数推出原始信息，所以SHA-256函数特别用于对比两条信息是否相同。比如我完成向李三转账100个比特币之后，别人就可以对纸条交易信息用SHA-256函数进行验证，如果结果与我给出的原哈希值相同，则表示这条信息是没哟被篡改过的。</p>
<p>使用公钥私钥的方式是非对称加密，那么对称加密有什么不好呢。</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>加入我要向李三发一条信息：315，对他加密，方法是每一位加2，得到加密后的信息537,537在网络中传播，到达李三后，用我俩约定的加密解密方式只需要每一位减2，得到原始信息315。此过程中的“2”称为对称钥匙。</p>
<p>对称钥匙的缺点是，我不论是以什么样的方式告知李三，钥匙<font color="orange">最少需要一次的传递</font>。这个传递过程可以被监听。所以有了非对称加密技术。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>1978年新的加密技术出现了。加密解密使用不同的两把钥匙，使用其中任何一个加密，那么另一个就可用来解密。非对称加密技术是通过一种很巧妙的且不可逆的数学运算的，成对存在。两把钥匙中，一把永远保留在自己手中，且只有自己知道，这个叫私钥，另一个公开给他人的称为公钥。</p>
<h2 id="公钥私钥-加密-amp-签名"><a href="#公钥私钥-加密-amp-签名" class="headerlink" title="公钥私钥-加密&amp;签名"></a>公钥私钥-加密&amp;签名</h2><p>私钥公钥有两个功能：</p>
<ol>
<li><font color="orange">加密信息</font>。当他人要给我发送加密消息，只要查询我的公钥，用公钥加密后发给我，我收到后送我的私钥解密，就可以获取原消息。整个过程没有任何钥匙的传递。所以这种方式由很强的安全性。</li>
<li><font color="orange">签名</font>。此时对钥匙的使用是反着来的。当我要想他人证明这条消息确实是我发出的，我需要先使用私钥加密，后将加密后的信息广播出去，他人使用我的公钥解开就可以了。若解开了，则证明该信息是由我发出。</li>
</ol>
<p>回顾一下，SHA-256函数的作用是为了确认原文是否被修改过，公钥私钥是用来确认交易信息签名的。到此，这个交易的加密信息和公钥就被传播出去了。</p>
<p>那交易记录为什么要被加密呢？如果没有加密，那么同一条消息可以由任何人写出，如何判断对比哪一个才是我的呢，由我授权的呢。所以需要私钥加密，后别人用公钥解密判断是否是我授权的。经过这一过程，这个交易（区块）就有<font color="orange">可能成为</font>链上的新区块。注意是“有可能成为”。</p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>矿工验证若干条交易信息，按照一定格式打包后，得到的称作区块。一个区块包括头部和交易部分。</p>
<h2 id="矿工做验证"><a href="#矿工做验证" class="headerlink" title="矿工做验证"></a>矿工做验证</h2><p>交易的加密信息和公钥就被传播出去了之后，需要验证，这些人使用客户端软件验证，他们被称为<font color="orange">矿工</font>。当矿工从网络中获得我广播的3条信息后，矿工根据其做下面两件事：</p>
<div align="center"><img src="/2020/06/30/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%8C%BA%E5%9D%97%E9%93%BE/graph3.png" width="500"></div>

<p>如果<code>原哈希==解哈希</code>，表示这个区块的信息没有被篡改，是经过我签名的。到此，这个交易就有可能成为区块链上的新区块。</p>
<p>矿工验证的过程是竞争让自己打包的交易信息成为区块挂在区块链的结尾。为什么这里需要竞争？【物理位置不同，搜索到的交易信息也不同】全世界的矿工即使都打包好了自己的区块，相互区块之间的差别是很大的，那哪一个才有资格称为幸运儿呢，这需要一项额外的（无意义的）工作来证明：<font color="orange">工作量证明</font>。</p>
<p>这里猜测一下，添加到链上的区块不是关注其原始交易是什么，而是看这个区块的前若干位是否都是零。其实互不相干的多条交易信息<font color="orange">相对于同一个时间是无序的</font>，所以两条不同交易信息谁在前谁在后，对于区块链没有关系，反正所有历史信息都会被记录。所以添加区块的资格就需要工作量证明。</p>
<h2 id="添加新区块的资格"><a href="#添加新区块的资格" class="headerlink" title="添加新区块的资格"></a>添加新区块的资格</h2><p>工作量证明：将打包的区块看做一个字符串，在其末尾添加一个随机数，最后对这个字符串执行SHA-256操作，已经知道SHA-256操作的结果是一个长度为256的二进制数。谁先计算出的结果中的前72位都是零，那么谁就有资格将自己的区块添加到链尾。成功提交这个区块的人，系统会奖励其若干个比特币，这个奖励是逐渐减半的，等差数列计算一下就知道，总的比特币数量为2100万个。</p>
<h2 id="最长链，主链"><a href="#最长链，主链" class="headerlink" title="最长链，主链"></a>最长链，主链</h2><p>比特币协议中只承认最长链，所以如果在某个结点出现了分支，那么哪一个分支最先出现下一个区块，表示这个支链就会更长，它将作为从此之后的<font color="orange">主链</font>，而另一个分支的交易会作为无效，比特币退回。</p>
<p>有了这个规则，即使一个区块被人篡改，对主链也不会有影响。因为所有算力都在主链上，那个被篡改的支链，只能确保自己的推进速度超过主链的推进速度，才有可能在未来某个时间成为新的主链，但显然一个人的算力对抗其他所有算力，是赢不了的。所以，篡改无效。</p>
<h2 id="当前区块包含了全部交易历史信息的特"><a href="#当前区块包含了全部交易历史信息的特" class="headerlink" title="当前区块包含了全部交易历史信息的特"></a>当前区块包含了全部交易历史信息的特</h2><p>一个区块包含两部分，头部和交易信息，其中头部包括上一个区块的信息，具体是上一个区块的SHA-256函数值。如此递归，容易知道，链中的每一个区块都含有其上一个区块的信息。所以说任何一个区块都含有这个区块之前整条链的所有信息。</p>
<h2 id="比特币有很多问题"><a href="#比特币有很多问题" class="headerlink" title="比特币有很多问题"></a>比特币有很多问题</h2><p>根据上述描述，可以发现比特币的问题：</p>
<ol>
<li>竞争获得添加新块的资格是靠算力裁决（工作量证明）的，而这个计算简单且没有实际意义的，损耗硬件算力和电能。</li>
<li>这个网络的交易频率太低，只有7笔交易每秒钟，VISA可以每秒钟处理千笔交易。比特币作为交易的属性太不明显。</li>
<li>区块链是在一个分布式系统中构建的，但是整个链都需要完整复制到每一个结点，并保持同步，所以存储，带宽成了大问题。其实这个系统的性能是由系统中性能最差的结点决定。</li>
<li>比特币意义不大，只是因为它是第一个出现的相关概念，外加大众的炒币，使其价格高，却极不稳定。</li>
</ol>
<h2 id="区块链诞生"><a href="#区块链诞生" class="headerlink" title="区块链诞生"></a>区块链诞生</h2><p>行业黑话，给交易打包，叫<font color="orange">块</font>，将块连接成<font color="orange">链</font>。两者结合实现支付和账本功能，叫区块链。（这个区块链上流通的货币是比特币）</p>
<h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><p>对比特币改进的虚拟币由很多种，其中技术改进最大的是以太坊。以太坊中实现了许多比特币中没有的特性和功能。</p>
<h2 id="以太坊vs比特币"><a href="#以太坊vs比特币" class="headerlink" title="以太坊vs比特币"></a>以太坊vs比特币</h2><p>主要有两点不同：</p>
<ol>
<li>以太坊有两种账户：普通账户和合约账户。普通账户可以主动发起交易；合约账户不能主动发起交易，但是可以回应普通账户执行交易。比特币系统中保存的是不可更改的交易历史，而以太坊中除了不可更改的历史交易，还有一些不可更改的执行程序。</li>
<li>比特币是采用工作量证明来裁决，而以太坊是采用<font color="orange">权益证明</font>裁决。就是谁拥有的虚拟币多，谁打包成块后提交的成功率高。</li>
</ol>
<p>以太坊对应的区块链被称为“智能合约”，不可更改，分布式存储，等待执行。其实并不智能，智能是可以自动选择最优方案的。</p>
<h2 id="DAO案件"><a href="#DAO案件" class="headerlink" title="DAO案件"></a>DAO案件</h2><p>以太坊对应的区块链上哪个时候有漏洞，如果要打补丁，会重新产生一条新的主链，这是个大改动，而且碰到漏洞的概率很小。所以没有及时打补丁。直到黑客动手，偷走了5%的以太坊，价值5000万美元。又因为区块链是一个分布式系统（去中心系统，像最常接触的操作系统，都是中心化的，有漏洞，打补丁后重新发布新的版本就好），偷盗行为不能被禁止。幸好代码中有一条“28天后才能提现”的规定，最终90%的人同意将被盗后的主链设为无效，但10%的人由于在事件发生后合法地赚到了钱，而反对。所以之后以太坊被分为ETH和ETC两种，两个主链。</p>
<p>没有绝对安全的系统。</p>
<h2 id="区块链的缺点"><a href="#区块链的缺点" class="headerlink" title="区块链的缺点"></a>区块链的缺点</h2><ol>
<li>虽是分布式，但算力没有提升。一般的分布式系统是为了提高计算效率，而区块链的分布式系统，并没有增加计算效率。</li>
<li>存储低效。上万个结点要长时间保持同步，每个结点存储完整的区块链。</li>
</ol>
<p>所以从计算机科学的角度讲，区块链设计精妙，但效率地，浪费资源的缺点是注定的。</p>
<h2 id="区块链的应用落地太困难"><a href="#区块链的应用落地太困难" class="headerlink" title="区块链的应用落地太困难"></a>区块链的应用落地太困难</h2><p>一个应用是支付宝的“相互宝”，使用了区块链的技术，但民众真正使用它更多的是因为对支付宝的品牌信任。想象一下，如果不是支付宝，而是一个不知名的公司，大众还会考虑吗。</p>
<p>另外的应用是虚拟币交易所。</p>
<p>从无到有的创新在区块链上太难了。其中一个原因就是，创造区块链历史的都是一些挑战既有秩序的人，而这个级别的创新在中国不太可能出现。</p>
<h2 id="中国的创新是对现有技术的延伸"><a href="#中国的创新是对现有技术的延伸" class="headerlink" title="中国的创新是对现有技术的延伸"></a>中国的创新是对现有技术的延伸</h2><p>回顾中国的互联网发展，正是通过中国的工程师在已有的技术上延伸而发展来的。一旦区块链技术在一个应用领域落地，在中国普及起来将会是很快的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/30/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%8C%BA%E5%9D%97%E9%93%BE/" data-id="ckc1ak2si0000ejfz211o915f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-优先队列相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/30/LeetCode-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2020-06-29T21:46:22.000Z" itemprop="datePublished">2020-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/30/LeetCode-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3/">LeetCode-优先队列相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>STL中priority—queue的定义，需要给出元素类型，容器类型，比较函数。其中比较函数可以由lambda函数，或struct定义。最常使用的操作有<code>push(), top(), pop()</code>。</p>
<h1 id="347-Top-K-freqent-elements"><a href="#347-Top-K-freqent-elements" class="headerlink" title="347 Top-K freqent elements"></a>347 Top-K freqent elements</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)&#123;</span><br><span class="line">	<span class="comment">// 1) build a map:</span></span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;mp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> item: nums)&#123;</span><br><span class="line">		mp[item]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2) build a heap: make_pair&lt;frequent, value&gt;</span></span><br><span class="line">	<span class="keyword">auto</span> Comp = [](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">	&#125;;</span><br><span class="line">	priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(Comp)&gt; pq(Comp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> itr=mp.begin(); itr!=mp.end(); itr++)&#123;</span><br><span class="line">		pq.push(make_pair(itr-&gt;second, itr-&gt;first));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3) push top k of heap to 'res'</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">		res.push_back(pq.top().second);</span><br><span class="line">		pq.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如测试用例：{1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,4,4,4,5,6,7,8} 返回频数最大的前3个元素2,3,1。</p>
<h1 id="692-Top-K-freqent-words"><a href="#692-Top-K-freqent-words" class="headerlink" title="692 Top-K freqent words"></a>692 Top-K freqent words</h1><p>同上一个问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 1) build a map</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item: words)</span><br><span class="line">        mp[item]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2) build a Max heap</span></span><br><span class="line">    <span class="comment">// 2.1) use lambda func and pass lambda to 'pq'</span></span><br><span class="line">    <span class="keyword">auto</span> comp = [](pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&amp; a, pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first&lt;b.first || (a.first==b.first &amp;&amp; a.second&gt;b.second);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt;, <span class="keyword">decltype</span>(comp)&gt; pq(comp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2) declare container &amp;&amp; the element type</span></span><br><span class="line">    <span class="comment">// priority_queue&lt;pair&lt;int,string&gt;, vector&lt;pair&lt;int, string&gt;&gt;, Comp&gt; pq;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> itr=mp.begin(); itr!=mp.end(); itr++)</span><br><span class="line">        pq.push(make_pair(itr-&gt;second, itr-&gt;first));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) push top k words to 'res'</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mp.size();i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pq.top().second&lt;&lt;<span class="string">": "</span>&lt;&lt;pq.top().first&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        res.push_back(pq.top().second);</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Comp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&amp; a, pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&amp; b)</span></span></span><br><span class="line">        return a.first&lt;b.first || (a.first==b.first &amp;&amp; a.second&gt;b.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/30/LeetCode-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3/" data-id="ckc11odiq0000wkfzhvvx5pi4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-caffe-工具箱" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/28/caffe-%E5%B7%A5%E5%85%B7%E7%AE%B1/" class="article-date">
  <time datetime="2020-06-28T01:42:00.000Z" itemprop="datePublished">2020-06-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Caffe/">Caffe</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/28/caffe-%E5%B7%A5%E5%85%B7%E7%AE%B1/">caffe-工具箱</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="caffe使用工具"><a href="#caffe使用工具" class="headerlink" title="caffe使用工具"></a>caffe使用工具</h1><p>caffe 编译后生成动态链接库 <code>libcaffe.so</code>。使用caffe时，在main.cpp中调用相应API，编译时包含对应的头文件，链接时加入 <code>libcaffe.so</code>。如此才是一个完整的caffe应用。</p>
<p>在tools/中就是一些调用<code>libcaffe.so</code>的工具源码。</p>
<p>前面提到过，caffe.bin工具由4个功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./caffe.bin train           <span class="comment">#train or finetune a model</span></span><br><span class="line">./caffe.bin <span class="built_in">test</span>            <span class="comment">#score a model</span></span><br><span class="line">./caffe.bin device_query    <span class="comment">#show GPU diagnostic information</span></span><br><span class="line">./caffe.bin time            <span class="comment">#benchmark model execution time</span></span><br></pre></td></tr></table></figure>

<p>从<code>tools/caffe.cpp</code>中看看是如何实现传递不同的参数，执行不同的功能。</p>
<p>首先定义一个caffe命令注册表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*BrewFunction)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;caffe::<span class="built_in">string</span>, BrewFunction&gt; BrewMap;</span><br><span class="line">BrewMap g_brew_map;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RegisterBrewFunction(func) \</span></span><br><span class="line"><span class="keyword">namespace</span> &#123; \</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">Registerer_</span>##<span class="title">func</span> &#123;</span> \</span><br><span class="line">    <span class="keyword">public</span>: <span class="comment">/* NOLINT */</span> \</span><br><span class="line">        __Registerer_#<span class="meta">#func() &#123; \</span></span><br><span class="line">    g_brew_map[<span class="meta">#func] = &amp;func; \</span></span><br><span class="line">    &#125; \</span><br><span class="line">&#125;; \</span><br><span class="line">__Registerer_#<span class="meta">#func g_registerer_##func; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="device-query命令："><a href="#device-query命令：" class="headerlink" title="device_query命令："></a>device_query命令：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Querying GPUs "</span> &lt;&lt; FLAGS_gpu;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gpus;</span><br><span class="line">    get_gpus(&amp;gpus);  <span class="comment">// TODO </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gpus.size(); ++i) &#123;</span><br><span class="line">        caffe::Caffe::SetDevice(gpus[i]);</span><br><span class="line">        caffe::Caffe::DeviceQuery();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">RegisterBrewFunction(device_query);</span><br></pre></td></tr></table></figure>

<h2 id="train命令"><a href="#train命令" class="headerlink" title="train命令"></a>train命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">train</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">RegisterBrewFunction(train);</span><br></pre></td></tr></table></figure>

<h2 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">RegisterBrewFunction(test);</span><br></pre></td></tr></table></figure>

<h2 id="time命令"><a href="#time命令" class="headerlink" title="time命令"></a>time命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">time</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">RegisterBrewFunction(time);</span><br></pre></td></tr></table></figure>

<p>上述将4条命令加入注册表。</p>
<p>从注册表中取对应的命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> BrewFunction <span class="title">GetBrewFunction</span><span class="params">(<span class="keyword">const</span> caffe::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_brew_map.count(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> g_brew_map[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从main函数中调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    gflags::SetUsageMessage(<span class="string">"command line brew\n"</span></span><br><span class="line">        <span class="string">"usage: caffe &lt;command&gt; &lt;args&gt;\n\n"</span></span><br><span class="line">        <span class="string">"commands:\n"</span></span><br><span class="line">        <span class="string">"  train           train or finetune a model\n"</span></span><br><span class="line">        <span class="string">"  test            score a model\n"</span></span><br><span class="line">        <span class="string">"  device_query    show GPU diagnostic information\n"</span></span><br><span class="line">        <span class="string">"  time            benchmark model execution time"</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> GetBrewFunction(caffe::<span class="built_in">string</span>(argv[<span class="number">1</span>]))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上实现了在caffe.bin工具中执行不同的命令。</p>
<p>还有其他工具：特征提取，图像格式转换，计算图像均值，等等。</p>
<h1 id="编写自己的工具"><a href="#编写自己的工具" class="headerlink" title="编写自己的工具"></a>编写自己的工具</h1><p>编写自己的工具帮助理解 caffe 框架和操作。</p>
<h1 id="caffe中的GPU实现"><a href="#caffe中的GPU实现" class="headerlink" title="caffe中的GPU实现"></a>caffe中的GPU实现</h1><p>其实caffe不需要手动编写CUDA程序，而是直接使用<code>cuBLAS</code>实现数学计算，相当于CPU端的<code>OpenBLAS</code>和<code>MKL</code>计算库。</p>
<p>上述是从数学计算角度，而对于DL中常见算子，如卷积，下采样等，在<code>cuDNN</code>中都已实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/28/caffe-%E5%B7%A5%E5%85%B7%E7%AE%B1/" data-id="ckc02u6ia0000s0fz5l378eik" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Caffe/" rel="tag">Caffe</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CUDA/">CUDA</a><span class="category-list-count">37</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Caffe/">Caffe</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Deep-Learning/">Deep Learning</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">30</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linear-Algebra/">Linear Algebra</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/">Machine Learning</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Reinforcement-Learning/">Reinforcement Learning</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Utility/">Utility</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%85%E5%BD%92%E7%B1%BB/">待归类</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a><span class="tag-list-count">57</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CUDA/" rel="tag">CUDA</a><span class="tag-list-count">35</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Caffe/" rel="tag">Caffe</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test-Analysis/" rel="tag">Test Analysis</a><span class="tag-list-count">6</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithms/" style="font-size: 20px;">Algorithms</a> <a href="/tags/CUDA/" style="font-size: 16.67px;">CUDA</a> <a href="/tags/Caffe/" style="font-size: 13.33px;">Caffe</a> <a href="/tags/Test-Analysis/" style="font-size: 10px;">Test Analysis</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">31</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">38</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/01/">January 1970</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/19/CUDA-%E7%BA%BF%E7%A8%8B-warp-%E5%BB%B6%E6%97%B6%E9%9A%90%E8%97%8F/">CUDA-线程-warp-延时隐藏</a>
          </li>
        
          <li>
            <a href="/2020/07/14/LeetCode-Trie-search-regular-expression/">LeetCode-Trie-search regular expression</a>
          </li>
        
          <li>
            <a href="/2020/07/12/LeetCode-Trie/">LeetCode-Trie</a>
          </li>
        
          <li>
            <a href="/2020/07/11/LeetCode-BST-%E6%89%BE%E5%89%8D%E9%A9%B1%E4%B8%8E%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9/">LeetCode-BST 找前驱与后继结点</a>
          </li>
        
          <li>
            <a href="/2020/07/08/CUDA-%E5%B9%B6%E8%A1%8CRadix-Sort/">CUDA-并行Radix Sort</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Junhui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>