<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Junhui&#39;s Journal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Junhui&#39;s Journal">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Junhui&#39;s Journal">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Junhui">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Junhui&#39;s Journal" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Junhui&#39;s Journal</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-LeetCode-Trie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/12/LeetCode-Trie/" class="article-date">
  <time datetime="2020-07-12T08:18:42.000Z" itemprop="datePublished">2020-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/12/LeetCode-Trie/">LeetCode-Trie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Trie是用来存储和查找大量string的带有结点和边的树型结构。对于字母string来讲，每个结点最多有26个子节点，如此构成一棵多叉树。这棵树的每一条从root的下一个结点到任意结点都是一个string。</p>
<p>Trie的结点可以如下定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> is_word;</span><br><span class="line">    TrieNode(<span class="keyword">bool</span> b = <span class="literal">false</span>)&#123;</span><br><span class="line">        is_word = b;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><code>memset(next, 0, sizeof(next))</code>表示在next地址，从头开始将<code>sizeof(next)</code>个字节设置为0。</li>
<li>所有next结点的is_word默认为false。</li>
</ol>
<p>每个结点有26个子节点和一个bool型的成员。bool成员表示从root下一个结点到当前结点形成的路径，这条路径表示的string是否存在于Trie中的。当为True时，这条路径表示的string存在于Trie，False则为不存在。</p>
<p>有了结点，可以构造Trie。开辟root空间即可，之后便可以向其中保存指定string，在其中搜索指定string。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Trie START</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Trie()&#123; root = <span class="keyword">new</span> TrieNode(); &#125;</span><br><span class="line">	~Trie()&#123; clear(root); &#125;</span><br></pre></td></tr></table></figure>
<p>初始化一个Trie解释构造一个Trie结点作为root，这里的root结点相当于链表的dummyHead结点。不保存数据，只是表示Trie的开始。</p>
<p>Trie的成员方法：</p>
<p>向Trie中添加string。只要遍历整个string，若没有当前字母，则新建一个结点；否则，自自由指针向下移动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// tmp为自由指针，</span></span><br><span class="line">       TrieNode* tmp = root;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(tmp-&gt;next[word[i] - <span class="string">'a'</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">               tmp-&gt;next[word[i] - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">           tmp = tmp-&gt;next[word[i]-<span class="string">'a'</span>];</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">// 将单词结尾设为true，表示这条路径是一个单词</span></span><br><span class="line">       tmp-&gt;is_word = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><code>tmp-&gt;next[word[i] - &#39;a&#39;] = new TrieNode();</code>智力只是开辟了空间，并没有向其中写入当前的字母，<font color="red">这里是使用26个不同 的位置来唯一标识每一个字母。</font>当然也可以使用其他TrieNode的实现方式，比如将26个字符作为<code>key</code>，将其子节点设为<code>value</code>，这种字典类型。</li>
<li><code>is_word</code>默认是<code>false</code>，但一个单词写入trie结束后，手动将其置为<code>true</code>。</li>
</ol>
<p>在trie中搜索一个string：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// tmp指向单词的最后一个字母结点</span></span><br><span class="line">       TrieNode* tmp = find_string(word);</span><br><span class="line">	<span class="comment">// 如果tmp（这个单词的最后一个字母）不是空且tmp的bool为true，</span></span><br><span class="line">	<span class="comment">// 表示由完整的这个单词</span></span><br><span class="line">       <span class="keyword">if</span>(tmp != <span class="literal">nullptr</span> &amp;&amp; (tmp-&gt;is_word))</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在trie中搜索一个前缀。与<code>search</code>方法唯一的区别是，不论tmp的<code>is_word</code>是否为true，即prefix是否是一个完整的单词，都就算找到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">startWith</span><span class="params">(<span class="built_in">string</span> prifix)</span> </span>&#123;</span><br><span class="line">       TrieNode* tmp = find_string(prifix);</span><br><span class="line">       <span class="keyword">if</span>(tmp != <span class="literal">nullptr</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>Trie对象的头：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	TrieNode* root;</span><br></pre></td></tr></table></figure>

<p>找到word的最后一个字母的结点:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TrieNode* <span class="title">find_string</span><span class="params">(<span class="built_in">string</span> word)</span></span>&#123;</span><br><span class="line">       TrieNode* tmp = root;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(tmp-&gt;next[word[i] - <span class="string">'a'</span>] != <span class="literal">nullptr</span>)</span><br><span class="line">               tmp = tmp -&gt; next[word[i] - <span class="string">'a'</span>];</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               tmp = <span class="literal">nullptr</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tmp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历 释放Trie</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(TrieNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next[i] != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                clear(root-&gt;next[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/// Trie END</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/12/LeetCode-Trie/" data-id="ckcivyhhh00041pfzfiszg5jt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-BST-找前驱与后继结点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/11/LeetCode-BST-%E6%89%BE%E5%89%8D%E9%A9%B1%E4%B8%8E%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9/" class="article-date">
  <time datetime="2020-07-11T12:52:30.000Z" itemprop="datePublished">2020-07-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/11/LeetCode-BST-%E6%89%BE%E5%89%8D%E9%A9%B1%E4%B8%8E%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9/">LeetCode-BST 找前驱与后继结点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>描述：<br>加入构造了一BST： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     6</span><br><span class="line"> / \    /\</span><br><span class="line">1   3  5  7</span><br></pre></td></tr></table></figure>

<p>现在要找到每个结点的前驱和后继结点。</p>
<p>思路：</p>
<p>可以将树的所有结点有序存储，后对于这个有序的数组操作。这里给出递归的思路。</p>
<ol>
<li><p>对于前驱结点。</p>
<p> 第一步，首先搜索目标结点，即谁的前驱。这个过程是<code>左-&gt;中-&gt;右</code>中序遍历，过程中记录target结点属于第几大的结点，将结果保存到<code>count</code>中。</p>
<p> 第二步。重新<code>左-&gt;中-&gt;右</code>中序遍历，找到第<code>count-1</code>大的结点，即第一个比target小的结点。</p>
</li>
<li><p>对于后继结点。</p>
<p> 第一步，首先搜索目标结点，即谁的后驱。这个过程是<code>左-&gt;中-&gt;右</code>中序遍历，过程中记录target结点属于第几大的结点，将结果保存到<code>count</code>中。</p>
<p> 第二步。重新<code>左-&gt;中-&gt;右</code>中序遍历，找到第<code>count+1</code>大的结点，即第一个比target大的结点。</p>
</li>
</ol>
<p>实现过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sol_successor_predecessor</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/// 前驱结点的入口函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">predecessor</span><span class="params">(TreeNode* root, <span class="keyword">const</span> TreeNode* <span class="keyword">const</span> target, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 遍历的count_</span></span><br><span class="line">		inOrder(root, target, count);</span><br><span class="line">        <span class="comment">// 搜索第count_-1的结点</span></span><br><span class="line">		predecessor_(root, target);</span><br><span class="line">		<span class="keyword">if</span> (res_)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"predecessor node: "</span>&lt;&lt;res_-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"predecessor node: nullptr"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">		count_=<span class="number">0</span>;</span><br><span class="line">		res_=<span class="literal">nullptr</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/// 后继结点的入口函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">successor</span><span class="params">(TreeNode* root, <span class="keyword">const</span> TreeNode* <span class="keyword">const</span> target, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 遍历的count_</span></span><br><span class="line">		inOrder(root, target, count);</span><br><span class="line">        <span class="comment">// 搜索第count_+1的结点</span></span><br><span class="line">		successor_(root, target);</span><br><span class="line">		<span class="keyword">if</span> (res_)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"successor node: "</span>&lt;&lt;res_-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"successor node: nullptr"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">		count_=<span class="number">0</span>;</span><br><span class="line">		res_=<span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> count_ = <span class="number">0</span>;</span><br><span class="line">	TreeNode* res_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// find the predecessor when count_ decreased to 1</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">predecessor_</span><span class="params">(TreeNode* root, <span class="keyword">const</span> TreeNode* <span class="keyword">const</span> target)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root!=<span class="literal">nullptr</span> )&#123;</span><br><span class="line">            predecessor_(root-&gt;left, target);  </span><br><span class="line">			count_--; </span><br><span class="line">            <span class="comment">// 直到count_ 减掉count_-1个数后，找到前驱结点</span></span><br><span class="line">			<span class="keyword">if</span> (count_ == <span class="number">1</span>)&#123;</span><br><span class="line">				res_ = root;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            predecessor_(root-&gt;right, target);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/// find the successor when count_ decreased to -1</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">successor_</span><span class="params">(TreeNode* root, <span class="keyword">const</span> TreeNode* <span class="keyword">const</span> target)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root!=<span class="literal">nullptr</span> )&#123;</span><br><span class="line">            successor_(root-&gt;left, target);  </span><br><span class="line">			count_--; </span><br><span class="line">            <span class="comment">// 直到count_ 减掉count_+1个数后，找到后继结点</span></span><br><span class="line">			<span class="keyword">if</span> ( count_ == <span class="number">-1</span>)&#123;</span><br><span class="line">				res_ = root;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            successor_(root-&gt;right, target);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// traverse to find the target node, and keep counting</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, <span class="keyword">const</span> TreeNode* <span class="keyword">const</span> target, <span class="keyword">int</span>&amp; count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            inOrder(root-&gt;left, target, count);  </span><br><span class="line">			count++;</span><br><span class="line">			<span class="keyword">if</span> (root-&gt;val == target-&gt;val)&#123;</span><br><span class="line">                <span class="comment">// 记录target结点是第几大的结点</span></span><br><span class="line">				count_ = count;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;  </span><br><span class="line">            inOrder(root-&gt;right, target, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>过程如注释。测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 后续遍历 用于销毁Tree</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroyTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root)&#123;</span><br><span class="line">		destroyTree(root-&gt;left);</span><br><span class="line">		destroyTree(root-&gt;right);</span><br><span class="line">		<span class="keyword">delete</span> root;</span><br><span class="line">		root = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">	TreeNode* root = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">	TreeNode* node1 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">	TreeNode* node2 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">	TreeNode* node3 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">	TreeNode* node4 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">	TreeNode* node5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">	TreeNode* node6 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// create a tree</span></span><br><span class="line">	root-&gt;left = node1;</span><br><span class="line">	root-&gt;right = node2;</span><br><span class="line"></span><br><span class="line">	node1-&gt;left = node3;</span><br><span class="line">	node1-&gt;right = node4;</span><br><span class="line"></span><br><span class="line">	node2-&gt;left = node5;</span><br><span class="line">	node2-&gt;right = node6;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// create a vector</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;TreeNode*&gt; treeVec = &#123;node3,node1,node4,root,node5, </span><br><span class="line">								node2, node6&#125;;</span><br><span class="line">	Sol_successor_predecessor sol;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> item: treeVec)&#123;</span><br><span class="line">		sol.predecessor(root, item, <span class="number">0</span>);</span><br><span class="line">		sol.successor(root, item, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/// 销毁</span></span><br><span class="line">    destroyTree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">target node: <span class="number">1</span></span><br><span class="line">predecessor node: <span class="literal">nullptr</span></span><br><span class="line">successor node: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">target node: <span class="number">2</span></span><br><span class="line">predecessor node: <span class="number">1</span></span><br><span class="line">successor node: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">target node: <span class="number">3</span></span><br><span class="line">predecessor node: <span class="number">2</span></span><br><span class="line">successor node: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">target node: <span class="number">4</span></span><br><span class="line">predecessor node: <span class="number">3</span></span><br><span class="line">successor node: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">target node: <span class="number">5</span></span><br><span class="line">predecessor node: <span class="number">4</span></span><br><span class="line">successor node: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">target node: <span class="number">6</span></span><br><span class="line">predecessor node: <span class="number">5</span></span><br><span class="line">successor node: <span class="number">7</span></span><br><span class="line"></span><br><span class="line">target node: <span class="number">7</span></span><br><span class="line">predecessor node: <span class="number">6</span></span><br><span class="line">successor node: <span class="literal">nullptr</span></span><br></pre></td></tr></table></figure>

<p>结果正确。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/11/LeetCode-BST-%E6%89%BE%E5%89%8D%E9%A9%B1%E4%B8%8E%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9/" data-id="ckcivyhhh00031pfzh7jm7rho" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CUDA-并行Radix-Sort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/08/CUDA-%E5%B9%B6%E8%A1%8CRadix-Sort/" class="article-date">
  <time datetime="2020-07-08T05:42:56.000Z" itemprop="datePublished">2020-07-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CUDA/">CUDA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/08/CUDA-%E5%B9%B6%E8%A1%8CRadix-Sort/">CUDA-并行Radix Sort</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="啥是Radix-Sorting"><a href="#啥是Radix-Sorting" class="headerlink" title="啥是Radix Sorting"></a>啥是Radix Sorting</h1><h1 id="Radix-Sorting-CPU-版本"><a href="#Radix-Sorting-CPU-版本" class="headerlink" title="Radix Sorting CPU 版本"></a>Radix Sorting CPU 版本</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_ELEM 100</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_sort</span><span class="params">(<span class="keyword">int32_t</span>* <span class="keyword">const</span> data, <span class="keyword">const</span> <span class="keyword">int32_t</span> num_elements)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int32_t</span> cpu_tmp_0[NUM_ELEM];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int32_t</span> cpu_tmp_1[NUM_ELEM];</span><br><span class="line">    <span class="comment">// for every bits of an element</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int32_t</span> bit=<span class="number">0</span>; bit&lt;<span class="number">32</span>; bit++) &#123;</span><br><span class="line">		<span class="keyword">int32_t</span> base_cnt_0 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int32_t</span> base_cnt_1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for every elements</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span>; i&lt;num_elements; i++)&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int32_t</span> d = data[i];</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int32_t</span> bit_mask = (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">			<span class="keyword">if</span> ( (d &amp; bit_mask) &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">				cpu_tmp_1[base_cnt_1] = d;</span><br><span class="line">				base_cnt_1++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				cpu_tmp_0[base_cnt_0] = d;</span><br><span class="line">				base_cnt_0++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Copy data back to source - first the ZERO list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span>; i&lt;base_cnt_0; i++)&#123;</span><br><span class="line">			data[i] = cpu_tmp_0[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Copy data back to source - then the ONE list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span>; i&lt;base_cnt_1; i++)&#123;</span><br><span class="line">			data[base_cnt_0+i] = cpu_tmp_1[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述过程没有办法并行，但是可以将Radix排序作为基本算子，将待处理的数组分成若干段，段与段之间并行执行Radix排序，之后调用Merge，将所有段（每一段都是有序的）并行归于成一段。这就是基本平行排序思路。</p>
<p>有了这个并行思路，对于排序算子，就可以使用任何可行的排序方法了。</p>
<p>先实现CPU的对多个有序数组的Merge操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并多个有序的子序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_arrays</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* src_array, </span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">int</span>* <span class="keyword">const</span> dest_array,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">const</span> <span class="keyword">int</span> num_lists, </span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">const</span> <span class="keyword">int</span> num_elements)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> num_element_per_list = (num_elements/num_lists);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> list_indexes[<span class="number">5</span>]; <span class="comment">// 分成5段</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;num_lists; l++)&#123;</span><br><span class="line">		list_indexes[l] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num_elements; i++)&#123;</span><br><span class="line">		dest_array[i] = find_min(src_array, </span><br><span class="line">								list_indexes,</span><br><span class="line">								num_lists,</span><br><span class="line">								num_element_per_list);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有段（子序列），找到当前所有段段首的最小值，写入目标数组的对应位置。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* src_array,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">int</span>* <span class="keyword">const</span> list_indexes,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">const</span> <span class="keyword">int</span> num_lists,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">const</span> <span class="keyword">int</span> num_elements_per_list)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> min_val = INT_MAX;</span><br><span class="line">	<span class="keyword">int</span> min_idx = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// Iterate over each of the lists</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num_lists; i++)&#123;</span><br><span class="line">	<span class="comment">// If the current list has already been emptied</span></span><br><span class="line">	<span class="comment">// then ignore it</span></span><br><span class="line">		<span class="keyword">if</span> (list_indexes[i] &lt; num_elements_per_list)&#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int</span> src_idx = list_indexes[i] + num_elements_per_list * i;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">int</span> data = src_array[src_idx];</span><br><span class="line">			<span class="keyword">if</span> (data &lt;= min_val)&#123;</span><br><span class="line">				min_val = data;</span><br><span class="line">				min_idx = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	list_indexes[min_idx]++;</span><br><span class="line">	<span class="keyword">return</span> min_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 共有15个元素，分成5段，每一段都有序。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = &#123;	<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,</span><br><span class="line">						<span class="number">1</span>,<span class="number">90</span>,<span class="number">91</span>,</span><br><span class="line">						<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,</span><br><span class="line">						<span class="number">10</span>,<span class="number">11</span>,<span class="number">13</span>,</span><br><span class="line">						<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Radix-Sorting-GPU-版本"><a href="#Radix-Sorting-GPU-版本" class="headerlink" title="Radix Sorting GPU 版本"></a>Radix Sorting GPU 版本</h1><p>这个在Thrust库中有相应实现。</p>
<p><font color="green" size="6">敲黑板</font>：每一个数与其二进制对应，Radix排序方法对二进制做判断，而在源数上做操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/08/CUDA-%E5%B9%B6%E8%A1%8CRadix-Sort/" data-id="ckcivyhh900001pfz70snajpi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CUDA/" rel="tag">CUDA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-判断链表是否相交" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/02/LeetCode-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/" class="article-date">
  <time datetime="2020-07-02T01:12:08.000Z" itemprop="datePublished">2020-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/02/LeetCode-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/">LeetCode-判断链表是否相交</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>描述：两个链表，均没有环，判断这两个链表是否相交。</p>
<p>关键要知道：链表中一个结点的唯一标识是它的地址。若两个结点的地址相同，表示这是同一个结点。</p>
<p>给出结点的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(<span class="number">0</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="方法一-遍历"><a href="#方法一-遍历" class="headerlink" title="方法一 遍历"></a>方法一 遍历</h1><p>对于相交的情况像字母“Y”，即只要有一个结点开始相同，那么之后的结点都相同。这种情况下，只要有相交，那么两个链表的最后一个结点一定相同。所以，分别遍历两个链表，记录尾结点，判断为节点是否是同一个结点。</p>
<p>时间复杂度是O(M+N)，空间复杂度是O(1)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLists1</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>&#123;</span><br><span class="line">    ListNode* dhead1 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head1);</span><br><span class="line">    ListNode* dhead2 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head2);</span><br><span class="line">    ListNode* cur1 = dhead1;</span><br><span class="line">    ListNode* cur2 = dhead2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur1-&gt;next)&#123;</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2-&gt;next)&#123;</span><br><span class="line">        cur2 = cur2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur1==cur2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，由于链表结点的定义，指出，一个结点只有一个next指针域，所以不会出现像字母“X”的相交情况。</p>
<h1 id="方法二-连接两个链表"><a href="#方法二-连接两个链表" class="headerlink" title="方法二 连接两个链表"></a>方法二 连接两个链表</h1><p>可以将链表1的尾接到链表2的头，此时遍历链表1，如果遍历指针走到了链表的结尾，即<code>nullptr</code>，表示新的链表中没有环，原链表不相交；若有环，则原链表相交。</p>
<p>时间复杂度是O(M+N)，空间复杂度是O(1)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLists2</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head1 || !head2 ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ListNode* dhead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head1);</span><br><span class="line">    </span><br><span class="line">    ListNode* needle = dhead;</span><br><span class="line">    <span class="comment">// move needle to the end of head1</span></span><br><span class="line">    <span class="keyword">while</span> (needle-&gt;next)&#123;</span><br><span class="line">        needle = needle-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// link the tail of head1 to the head of head2;</span></span><br><span class="line">    needle-&gt;next = head2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if there exists a loop</span></span><br><span class="line">    <span class="keyword">return</span> hasCycle(head1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>hasCycle()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; slow)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast) fast = fast-&gt;next;</span><br><span class="line">        <span class="comment">// 先判断移动后的fast是否非空</span></span><br><span class="line">        <span class="keyword">if</span> (fast &amp;&amp; fast==slow)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法三-使用查找表"><a href="#方法三-使用查找表" class="headerlink" title="方法三 使用查找表"></a>方法三 使用查找表</h1><p>将head1的结点放入set，然后对于head2中每个结点，在set中find()，如果能找到，则表示由公共的结点，交叉；否则不交叉。</p>
<p>时间复杂度：O(max(M,N)), 空间复杂度：O(M)。需要M的空间创造查找表set。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">crossLists3</span><span class="params">(ListNode* head1, ListNode* head2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;ListNode*&gt; st;</span><br><span class="line">    ListNode* cur = head1;</span><br><span class="line">    <span class="comment">// 将head1的结点放入set</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        st.insert(cur);</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head2;</span><br><span class="line">    <span class="comment">// 从head2中，对每个结点在set中find，</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span> (st.find(cur)!=st.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在如果进一步要求出相交的结点是哪个，如何求？</p>
<p>方法一不适用，方法二，可以修改为带环的链表求环的入口，看笔记<a href="https://ashburnlee.github.io/2020/06/23/LeetCode-%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">LeetCode-链表相关</a>的<code>#142</code>。</p>
<p>方法三，只需要将查找表改为顺序存储，即可，如此找到的公共结点就是第一个在查找表中找到的结点。</p>
<p><font color="gree" size="5">强调</font>：链表中一个结点的唯一标识是它的地址。当打印一个<code>ListNode* head</code>时，打印的是head中的内容，即一个结点对象的地址。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/02/LeetCode-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/" data-id="ckc4dw37x0000oafz60e0hnna" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cpp-静态内存-栈内存-动态内存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/01/cpp-%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98-%E6%A0%88%E5%86%85%E5%AD%98-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" class="article-date">
  <time datetime="2020-06-30T21:11:47.000Z" itemprop="datePublished">2020-07-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/01/cpp-%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98-%E6%A0%88%E5%86%85%E5%AD%98-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">cpp-静态内存-栈内存-动态内存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一个cpp程序会使用到的内存类型有：</p>
<ol>
<li>静态内存：用来保存局部static变量，类中static变量，任何函数外的全局变量。</li>
<li>栈内存（stack）：保存定义在函数内的非static变量。</li>
<li>动态内存（heap）：存储动态分配的对象。但是使用完后，调用着必须显式地将空间释放。通常使用<code>new</code>和<code>delete</code>关键字。</li>
</ol>
<p>动态内存使用时，<code>new</code>在动态内存中分配空间并且返回一个指向该空间的指针（两件事）。<code>delete</code>时，接受一个动态对象的指针，销毁该指针所指向的对象，并释放空间。</p>
<p>但是在正确的时间释放空间有时是很困难的，为了可以安全的使用动态内存，标准库提供了智能指针：<code>shared_ptr</code>和<code>unique_ptr</code>。</p>
<p>多个<code>shared_ptr</code>能共享一个对象；而一个<code>unique_ptr</code>只能独享一个对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/01/cpp-%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98-%E6%A0%88%E5%86%85%E5%AD%98-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" data-id="ckc2s7hgg0000plfz8hn9blkr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-比特币-以太坊-区块链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/30/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%8C%BA%E5%9D%97%E9%93%BE/" class="article-date">
  <time datetime="2020-06-30T02:05:51.000Z" itemprop="datePublished">2020-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%85%E5%BD%92%E7%B1%BB/">待归类</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/30/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%8C%BA%E5%9D%97%E9%93%BE/">比特币-以太坊-区块链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本笔记内容来自卓克讲座及讨论内容。</p>
<h2 id="比特币的目"><a href="#比特币的目" class="headerlink" title="比特币的目"></a>比特币的目</h2><p>比特币的目的是生成一个任何人都不能更改的<font color="orange">账本</font>，这个账本在分布式系统中的每一个结点都保存一份，并且同步更新。账本可以是一条交易记录，比如：我向李三转账100个比特币。这个动作，在相应的软件上会做3件事：</p>
<ol>
<li>将“我向李三转账100个比特币”作为<code>原始信息</code>，对其做一次SHA-256运算，得到的结果是一个<code>原哈希值</code>。</li>
<li>用我自己的私钥给上一个结果（原哈希值）加密，得到加密后的<code>密哈希</code>。</li>
<li>将<code>原始信息</code>，<code>公钥</code>（我自己的私钥对应的公钥），<code>密哈希</code>，3项内容广播到网络中。</li>
</ol>
<div align="center"><img src="/2020/06/30/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%8C%BA%E5%9D%97%E9%93%BE/graph1.png" width="500"></div>

<p>之后图中三个矩形框的内容就被广播到网络中。</p>
<p>对任何内容进行<font color="orange">SHA-256运算</font>都能生成唯一的256bit的二进制数，没有办法从这个二进制数推出原始信息，所以SHA-256函数特别用于对比两条信息是否相同。比如我完成向李三转账100个比特币之后，别人就可以对纸条交易信息用SHA-256函数进行验证，如果结果与我给出的原哈希值相同，则表示这条信息是没哟被篡改过的。</p>
<p>使用公钥私钥的方式是非对称加密，那么对称加密有什么不好呢。</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>加入我要向李三发一条信息：315，对他加密，方法是每一位加2，得到加密后的信息537,537在网络中传播，到达李三后，用我俩约定的加密解密方式只需要每一位减2，得到原始信息315。此过程中的“2”称为对称钥匙。</p>
<p>对称钥匙的缺点是，我不论是以什么样的方式告知李三，钥匙<font color="orange">最少需要一次的传递</font>。这个传递过程可以被监听。所以有了非对称加密技术。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>1978年新的加密技术出现了。加密解密使用不同的两把钥匙，使用其中任何一个加密，那么另一个就可用来解密。非对称加密技术是通过一种很巧妙的且不可逆的数学运算的，成对存在。两把钥匙中，一把永远保留在自己手中，且只有自己知道，这个叫私钥，另一个公开给他人的称为公钥。</p>
<h2 id="公钥私钥-加密-amp-签名"><a href="#公钥私钥-加密-amp-签名" class="headerlink" title="公钥私钥-加密&amp;签名"></a>公钥私钥-加密&amp;签名</h2><p>私钥公钥有两个功能：</p>
<ol>
<li><font color="orange">加密信息</font>。当他人要给我发送加密消息，只要查询我的公钥，用公钥加密后发给我，我收到后送我的私钥解密，就可以获取原消息。整个过程没有任何钥匙的传递。所以这种方式由很强的安全性。</li>
<li><font color="orange">签名</font>。此时对钥匙的使用是反着来的。当我要想他人证明这条消息确实是我发出的，我需要先使用私钥加密，后将加密后的信息广播出去，他人使用我的公钥解开就可以了。若解开了，则证明该信息是由我发出。</li>
</ol>
<p>回顾一下，SHA-256函数的作用是为了确认原文是否被修改过，公钥私钥是用来确认交易信息签名的。到此，这个交易的加密信息和公钥就被传播出去了。</p>
<p>那交易记录为什么要被加密呢？如果没有加密，那么同一条消息可以由任何人写出，如何判断对比哪一个才是我的呢，由我授权的呢。所以需要私钥加密，后别人用公钥解密判断是否是我授权的。经过这一过程，这个交易（区块）就有<font color="orange">可能成为</font>链上的新区块。注意是“有可能成为”。</p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>矿工验证若干条交易信息，按照一定格式打包后，得到的称作区块。一个区块包括头部和交易部分。</p>
<h2 id="矿工做验证"><a href="#矿工做验证" class="headerlink" title="矿工做验证"></a>矿工做验证</h2><p>交易的加密信息和公钥就被传播出去了之后，需要验证，这些人使用客户端软件验证，他们被称为<font color="orange">矿工</font>。当矿工从网络中获得我广播的3条信息后，矿工根据其做下面两件事：</p>
<div align="center"><img src="/2020/06/30/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%8C%BA%E5%9D%97%E9%93%BE/graph3.png" width="500"></div>

<p>如果<code>原哈希==解哈希</code>，表示这个区块的信息没有被篡改，是经过我签名的。到此，这个交易就有可能成为区块链上的新区块。</p>
<p>矿工验证的过程是竞争让自己打包的交易信息成为区块挂在区块链的结尾。为什么这里需要竞争？【物理位置不同，搜索到的交易信息也不同】全世界的矿工即使都打包好了自己的区块，相互区块之间的差别是很大的，那哪一个才有资格称为幸运儿呢，这需要一项额外的（无意义的）工作来证明：<font color="orange">工作量证明</font>。</p>
<p>这里猜测一下，添加到链上的区块不是关注其原始交易是什么，而是看这个区块的前若干位是否都是零。其实互不相干的多条交易信息<font color="orange">相对于同一个时间是无序的</font>，所以两条不同交易信息谁在前谁在后，对于区块链没有关系，反正所有历史信息都会被记录。所以添加区块的资格就需要工作量证明。</p>
<h2 id="添加新区块的资格"><a href="#添加新区块的资格" class="headerlink" title="添加新区块的资格"></a>添加新区块的资格</h2><p>工作量证明：将打包的区块看做一个字符串，在其末尾添加一个随机数，最后对这个字符串执行SHA-256操作，已经知道SHA-256操作的结果是一个长度为256的二进制数。谁先计算出的结果中的前72位都是零，那么谁就有资格将自己的区块添加到链尾。成功提交这个区块的人，系统会奖励其若干个比特币，这个奖励是逐渐减半的，等差数列计算一下就知道，总的比特币数量为2100万个。</p>
<h2 id="最长链，主链"><a href="#最长链，主链" class="headerlink" title="最长链，主链"></a>最长链，主链</h2><p>比特币协议中只承认最长链，所以如果在某个结点出现了分支，那么哪一个分支最先出现下一个区块，表示这个支链就会更长，它将作为从此之后的<font color="orange">主链</font>，而另一个分支的交易会作为无效，比特币退回。</p>
<p>有了这个规则，即使一个区块被人篡改，对主链也不会有影响。因为所有算力都在主链上，那个被篡改的支链，只能确保自己的推进速度超过主链的推进速度，才有可能在未来某个时间成为新的主链，但显然一个人的算力对抗其他所有算力，是赢不了的。所以，篡改无效。</p>
<h2 id="当前区块包含了全部交易历史信息的特"><a href="#当前区块包含了全部交易历史信息的特" class="headerlink" title="当前区块包含了全部交易历史信息的特"></a>当前区块包含了全部交易历史信息的特</h2><p>一个区块包含两部分，头部和交易信息，其中头部包括上一个区块的信息，具体是上一个区块的SHA-256函数值。如此递归，容易知道，链中的每一个区块都含有其上一个区块的信息。所以说任何一个区块都含有这个区块之前整条链的所有信息。</p>
<h2 id="比特币有很多问题"><a href="#比特币有很多问题" class="headerlink" title="比特币有很多问题"></a>比特币有很多问题</h2><p>根据上述描述，可以发现比特币的问题：</p>
<ol>
<li>竞争获得添加新块的资格是靠算力裁决（工作量证明）的，而这个计算简单且没有实际意义的，损耗硬件算力和电能。</li>
<li>这个网络的交易频率太低，只有7笔交易每秒钟，VISA可以每秒钟处理千笔交易。比特币作为交易的属性太不明显。</li>
<li>区块链是在一个分布式系统中构建的，但是整个链都需要完整复制到每一个结点，并保持同步，所以存储，带宽成了大问题。其实这个系统的性能是由系统中性能最差的结点决定。</li>
<li>比特币意义不大，只是因为它是第一个出现的相关概念，外加大众的炒币，使其价格高，却极不稳定。</li>
</ol>
<h2 id="区块链诞生"><a href="#区块链诞生" class="headerlink" title="区块链诞生"></a>区块链诞生</h2><p>行业黑话，给交易打包，叫<font color="orange">块</font>，将块连接成<font color="orange">链</font>。两者结合实现支付和账本功能，叫区块链。（这个区块链上流通的货币是比特币）</p>
<h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><p>对比特币改进的虚拟币由很多种，其中技术改进最大的是以太坊。以太坊中实现了许多比特币中没有的特性和功能。</p>
<h2 id="以太坊vs比特币"><a href="#以太坊vs比特币" class="headerlink" title="以太坊vs比特币"></a>以太坊vs比特币</h2><p>主要有两点不同：</p>
<ol>
<li>以太坊有两种账户：普通账户和合约账户。普通账户可以主动发起交易；合约账户不能主动发起交易，但是可以回应普通账户执行交易。比特币系统中保存的是不可更改的交易历史，而以太坊中除了不可更改的历史交易，还有一些不可更改的执行程序。</li>
<li>比特币是采用工作量证明来裁决，而以太坊是采用<font color="orange">权益证明</font>裁决。就是谁拥有的虚拟币多，谁打包成块后提交的成功率高。</li>
</ol>
<p>以太坊对应的区块链被称为“智能合约”，不可更改，分布式存储，等待执行。其实并不智能，智能是可以自动选择最优方案的。</p>
<h2 id="DAO案件"><a href="#DAO案件" class="headerlink" title="DAO案件"></a>DAO案件</h2><p>以太坊对应的区块链上哪个时候有漏洞，如果要打补丁，会重新产生一条新的主链，这是个大改动，而且碰到漏洞的概率很小。所以没有及时打补丁。直到黑客动手，偷走了5%的以太坊，价值5000万美元。又因为区块链是一个分布式系统（去中心系统，像最常接触的操作系统，都是中心化的，有漏洞，打补丁后重新发布新的版本就好），偷盗行为不能被禁止。幸好代码中有一条“28天后才能提现”的规定，最终90%的人同意将被盗后的主链设为无效，但10%的人由于在事件发生后合法地赚到了钱，而反对。所以之后以太坊被分为ETH和ETC两种，两个主链。</p>
<p>没有绝对安全的系统。</p>
<h2 id="区块链的缺点"><a href="#区块链的缺点" class="headerlink" title="区块链的缺点"></a>区块链的缺点</h2><ol>
<li>虽是分布式，但算力没有提升。一般的分布式系统是为了提高计算效率，而区块链的分布式系统，并没有增加计算效率。</li>
<li>存储低效。上万个结点要长时间保持同步，每个结点存储完整的区块链。</li>
</ol>
<p>所以从计算机科学的角度讲，区块链设计精妙，但效率地，浪费资源的缺点是注定的。</p>
<h2 id="区块链的应用落地太困难"><a href="#区块链的应用落地太困难" class="headerlink" title="区块链的应用落地太困难"></a>区块链的应用落地太困难</h2><p>一个应用是支付宝的“相互宝”，使用了区块链的技术，但民众真正使用它更多的是因为对支付宝的品牌信任。想象一下，如果不是支付宝，而是一个不知名的公司，大众还会考虑吗。</p>
<p>另外的应用是虚拟币交易所。</p>
<p>从无到有的创新在区块链上太难了。其中一个原因就是，创造区块链历史的都是一些挑战既有秩序的人，而这个级别的创新在中国不太可能出现。</p>
<h2 id="中国的创新是对现有技术的延伸"><a href="#中国的创新是对现有技术的延伸" class="headerlink" title="中国的创新是对现有技术的延伸"></a>中国的创新是对现有技术的延伸</h2><p>回顾中国的互联网发展，正是通过中国的工程师在已有的技术上延伸而发展来的。一旦区块链技术在一个应用领域落地，在中国普及起来将会是很快的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/30/%E6%AF%94%E7%89%B9%E5%B8%81-%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E5%8C%BA%E5%9D%97%E9%93%BE/" data-id="ckc1ak2si0000ejfz211o915f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-优先队列相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/30/LeetCode-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2020-06-29T21:46:22.000Z" itemprop="datePublished">2020-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/30/LeetCode-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3/">LeetCode-优先队列相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>STL中priority—queue的定义，需要给出元素类型，容器类型，比较函数。其中比较函数可以由lambda函数，或struct定义。最常使用的操作有<code>push(), top(), pop()</code>。</p>
<h1 id="347-Top-K-freqent-elements"><a href="#347-Top-K-freqent-elements" class="headerlink" title="347 Top-K freqent elements"></a>347 Top-K freqent elements</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)&#123;</span><br><span class="line">	<span class="comment">// 1) build a map:</span></span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;mp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> item: nums)&#123;</span><br><span class="line">		mp[item]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2) build a heap: make_pair&lt;frequent, value&gt;</span></span><br><span class="line">	<span class="keyword">auto</span> Comp = [](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">		<span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">	&#125;;</span><br><span class="line">	priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(Comp)&gt; pq(Comp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> itr=mp.begin(); itr!=mp.end(); itr++)&#123;</span><br><span class="line">		pq.push(make_pair(itr-&gt;second, itr-&gt;first));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3) push top k of heap to 'res'</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">		res.push_back(pq.top().second);</span><br><span class="line">		pq.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如测试用例：{1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,4,4,4,5,6,7,8} 返回频数最大的前3个元素2,3,1。</p>
<h1 id="692-Top-K-freqent-words"><a href="#692-Top-K-freqent-words" class="headerlink" title="692 Top-K freqent words"></a>692 Top-K freqent words</h1><p>同上一个问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 1) build a map</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item: words)</span><br><span class="line">        mp[item]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2) build a Max heap</span></span><br><span class="line">    <span class="comment">// 2.1) use lambda func and pass lambda to 'pq'</span></span><br><span class="line">    <span class="keyword">auto</span> comp = [](pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&amp; a, pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first&lt;b.first || (a.first==b.first &amp;&amp; a.second&gt;b.second);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt;, <span class="keyword">decltype</span>(comp)&gt; pq(comp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2) declare container &amp;&amp; the element type</span></span><br><span class="line">    <span class="comment">// priority_queue&lt;pair&lt;int,string&gt;, vector&lt;pair&lt;int, string&gt;&gt;, Comp&gt; pq;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> itr=mp.begin(); itr!=mp.end(); itr++)</span><br><span class="line">        pq.push(make_pair(itr-&gt;second, itr-&gt;first));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) push top k words to 'res'</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mp.size();i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pq.top().second&lt;&lt;<span class="string">": "</span>&lt;&lt;pq.top().first&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        res.push_back(pq.top().second);</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Comp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&amp; a, pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&amp; b)</span></span></span><br><span class="line">        return a.first&lt;b.first || (a.first==b.first &amp;&amp; a.second&gt;b.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/30/LeetCode-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3/" data-id="ckc11odiq0000wkfzhvvx5pi4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-caffe-工具箱" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/28/caffe-%E5%B7%A5%E5%85%B7%E7%AE%B1/" class="article-date">
  <time datetime="2020-06-28T01:42:00.000Z" itemprop="datePublished">2020-06-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Caffe/">Caffe</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/28/caffe-%E5%B7%A5%E5%85%B7%E7%AE%B1/">caffe-工具箱</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="caffe使用工具"><a href="#caffe使用工具" class="headerlink" title="caffe使用工具"></a>caffe使用工具</h1><p>caffe 编译后生成动态链接库 <code>libcaffe.so</code>。使用caffe时，在main.cpp中调用相应API，编译时包含对应的头文件，链接时加入 <code>libcaffe.so</code>。如此才是一个完整的caffe应用。</p>
<p>在tools/中就是一些调用<code>libcaffe.so</code>的工具源码。</p>
<p>前面提到过，caffe.bin工具由4个功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./caffe.bin train           <span class="comment">#train or finetune a model</span></span><br><span class="line">./caffe.bin <span class="built_in">test</span>            <span class="comment">#score a model</span></span><br><span class="line">./caffe.bin device_query    <span class="comment">#show GPU diagnostic information</span></span><br><span class="line">./caffe.bin time            <span class="comment">#benchmark model execution time</span></span><br></pre></td></tr></table></figure>

<p>从<code>tools/caffe.cpp</code>中看看是如何实现传递不同的参数，执行不同的功能。</p>
<p>首先定义一个caffe命令注册表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*BrewFunction)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;caffe::<span class="built_in">string</span>, BrewFunction&gt; BrewMap;</span><br><span class="line">BrewMap g_brew_map;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RegisterBrewFunction(func) \</span></span><br><span class="line"><span class="keyword">namespace</span> &#123; \</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">Registerer_</span>##<span class="title">func</span> &#123;</span> \</span><br><span class="line">    <span class="keyword">public</span>: <span class="comment">/* NOLINT */</span> \</span><br><span class="line">        __Registerer_#<span class="meta">#func() &#123; \</span></span><br><span class="line">    g_brew_map[<span class="meta">#func] = &amp;func; \</span></span><br><span class="line">    &#125; \</span><br><span class="line">&#125;; \</span><br><span class="line">__Registerer_#<span class="meta">#func g_registerer_##func; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="device-query命令："><a href="#device-query命令：" class="headerlink" title="device_query命令："></a>device_query命令：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Querying GPUs "</span> &lt;&lt; FLAGS_gpu;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gpus;</span><br><span class="line">    get_gpus(&amp;gpus);  <span class="comment">// TODO </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gpus.size(); ++i) &#123;</span><br><span class="line">        caffe::Caffe::SetDevice(gpus[i]);</span><br><span class="line">        caffe::Caffe::DeviceQuery();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">RegisterBrewFunction(device_query);</span><br></pre></td></tr></table></figure>

<h2 id="train命令"><a href="#train命令" class="headerlink" title="train命令"></a>train命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">train</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">RegisterBrewFunction(train);</span><br></pre></td></tr></table></figure>

<h2 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">RegisterBrewFunction(test);</span><br></pre></td></tr></table></figure>

<h2 id="time命令"><a href="#time命令" class="headerlink" title="time命令"></a>time命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">time</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">RegisterBrewFunction(time);</span><br></pre></td></tr></table></figure>

<p>上述将4条命令加入注册表。</p>
<p>从注册表中取对应的命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> BrewFunction <span class="title">GetBrewFunction</span><span class="params">(<span class="keyword">const</span> caffe::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_brew_map.count(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> g_brew_map[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从main函数中调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    gflags::SetUsageMessage(<span class="string">"command line brew\n"</span></span><br><span class="line">        <span class="string">"usage: caffe &lt;command&gt; &lt;args&gt;\n\n"</span></span><br><span class="line">        <span class="string">"commands:\n"</span></span><br><span class="line">        <span class="string">"  train           train or finetune a model\n"</span></span><br><span class="line">        <span class="string">"  test            score a model\n"</span></span><br><span class="line">        <span class="string">"  device_query    show GPU diagnostic information\n"</span></span><br><span class="line">        <span class="string">"  time            benchmark model execution time"</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> GetBrewFunction(caffe::<span class="built_in">string</span>(argv[<span class="number">1</span>]))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上实现了在caffe.bin工具中执行不同的命令。</p>
<p>还有其他工具：特征提取，图像格式转换，计算图像均值，等等。</p>
<h1 id="编写自己的工具"><a href="#编写自己的工具" class="headerlink" title="编写自己的工具"></a>编写自己的工具</h1><p>编写自己的工具帮助理解 caffe 框架和操作。</p>
<h1 id="caffe中的GPU实现"><a href="#caffe中的GPU实现" class="headerlink" title="caffe中的GPU实现"></a>caffe中的GPU实现</h1><p>其实caffe不需要手动编写CUDA程序，而是直接使用<code>cuBLAS</code>实现数学计算，相当于CPU端的<code>OpenBLAS</code>和<code>MKL</code>计算库。</p>
<p>上述是从数学计算角度，而对于DL中常见算子，如卷积，下采样等，在<code>cuDNN</code>中都已实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/28/caffe-%E5%B7%A5%E5%85%B7%E7%AE%B1/" data-id="ckc02u6ia0000s0fz5l378eik" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Caffe/" rel="tag">Caffe</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-merge应用-求逆序对" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/25/LeetCode-merge%E5%BA%94%E7%94%A8-%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/" class="article-date">
  <time datetime="2020-06-24T19:14:48.000Z" itemprop="datePublished">2020-06-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/25/LeetCode-merge%E5%BA%94%E7%94%A8-%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/">LeetCode-merge应用-求逆序对</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>分治&amp;归并</p>
<p>涉及到两两比较的操作，都可以考虑<font color="red" size="4">分治&amp;归并</font>。并归使得当前的对象两两比较完备，而分治使得两个分别两两比较后的对象<font color="red">之间</font>两两比较，完备。</p>
<p>问题描述，求逆序对个数：<code>[2,7,8,1,3,5]</code>，比如其中的(2,7) (2,8) (2,3) (2,5)以2 开始的逆序对有4个。求一共有多少个逆序对。</p>
<p>思路：</p>
<p>如描述中的例子，当分制后，有<code>[2,7,8]</code>和<code>[1,3,5]</code>两部分，而2&gt;1，所以以1为逆序对中第二个元素的逆序对有3个，(2,1) (7,1) (8,1)。这是因为并归操作的前提是两部分，分别有序。</p>
<p>核心是，当左部分第一个元素2大于右边第一个元素1时，count+=3，（2,7,8 有3个元素）。这是这个问题的关键！</p>
<p>实现：</p>
<p>看Merge操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeOp_</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* aux = <span class="keyword">new</span> <span class="keyword">int</span>[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">        aux[i-l]=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=l;</span><br><span class="line">    <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b=j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=l;k&lt;=r;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;mid) &#123; <span class="comment">// 左边排玩</span></span><br><span class="line">            nums[k]=aux[j-l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j&gt;r) &#123; <span class="comment">// 右边排完</span></span><br><span class="line">            nums[k]=aux[i-l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (aux[i-l]&lt;=aux[j-l])&#123;</span><br><span class="line">            nums[k] = aux[i-l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 左部分元素大于右部分元素时，记录逆序对个数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(aux[i-l]&gt;aux[j-l])&#123;</span><br><span class="line">            count_ += (b-i);  <span class="comment">// 这里</span></span><br><span class="line">            nums[k] = aux[j-l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> aux;</span><br><span class="line">    aux=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>count_ += (b-i);</code> 便是记录逆序对个数。</p>
<p>将上述操作放入下面code的完整的求逆序对解法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sol_mergeSort</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> count_=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">split_</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (r&lt;=l) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = (r-l)/<span class="number">2</span>+l;</span><br><span class="line">		split_(nums, l, mid);</span><br><span class="line">		split_(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">		mergeOp_(nums, l, mid, r);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mergeOp_()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">		split_(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count_;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试对象：<code>{1,3,4,0,2,5}</code>，逆序对有5对儿。</p>
<p>上述code结果： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>  </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>  <span class="comment">// 排序后的结果</span></span><br></pre></td></tr></table></figure>

<p>复杂度：O(N*longN)</p>
<p><font color="gree" size="5">敲黑板</font>：从这个问题体会分治策略</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/25/LeetCode-merge%E5%BA%94%E7%94%A8-%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9/" data-id="ckbubwopd00003wfz6z552ijt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-链表相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/23/LeetCode-%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2020-06-23T01:50:23.000Z" itemprop="datePublished">2020-06-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/23/LeetCode-%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/">LeetCode-链表相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>给出链表结点的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode() : val(<span class="number">0</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从数组构造一个链表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// create a linkedList from a vector</span></span><br><span class="line"><span class="function">ListNode* <span class="title">createList</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    ListNode* tail = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ListNode* tmpNode = <span class="keyword">new</span> ListNode(nums[i], tail);</span><br><span class="line">        tail = tmpNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="补充-递归"><a href="#补充-递归" class="headerlink" title="补充 递归"></a>补充 递归</h1><p>从链表到树的递归操作，体会<font color="red">递归从上到下，执行从底向上</font>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traverse a list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printListRecurvely</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    printListRecurvely(head-&gt;next);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; head-&gt;val &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    inOrderTraverse(root-&gt;left);</span><br><span class="line">    inOrderTraverse(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="206-翻转整个链表"><a href="#206-翻转整个链表" class="headerlink" title="206 翻转整个链表"></a>206 翻转整个链表</h1><p>思路一与#92的翻转子操作相似，定义三个指针，并初始化，在移动到链表尾部的过程中改变next指针的指向，从而实现翻转链表。</p>
<p>实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// # 206 翻转整个链表</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* left = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* mid = head;</span><br><span class="line">    ListNode* right = head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// operation</span></span><br><span class="line">        mid-&gt;next = left;</span><br><span class="line">        <span class="comment">// move ptrs</span></span><br><span class="line">        left = mid;</span><br><span class="line">        mid = right;</span><br><span class="line">        right = right-&gt;next;       </span><br><span class="line">    &#125;</span><br><span class="line">    mid-&gt;next = left;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路二：递归实现，从最后一个结点开始向前指向，最终返回最后一个结点。实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* p = reverseList(head-&gt;next);</span><br><span class="line"></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其过程图示见笔记本。</p>
<p>分析<font color="red" size="4">递归返回值</font>：返回值p始终指向原始链表的尾结点，而它又正好是翻转后的头结点。</p>
<h1 id="92-翻转链表两个位置间的结点，部分翻转"><a href="#92-翻转链表两个位置间的结点，部分翻转" class="headerlink" title="92 翻转链表两个位置间的结点，部分翻转"></a>92 翻转链表两个位置间的结点，部分翻转</h1><p>例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>思路：先实现翻转连个结点间的结点，作为子造作，后移动指针，找到对应的m和n，调用子操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//# 92 翻转链表某个部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sol92</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// reverse node from head to tail</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = tail;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != tail) &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于对整个链表的翻转，上述函数参数<code>tail</code>为<code>nullptr</code>，即表示链表结尾的结点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        assert(m &lt;= n);</span><br><span class="line">        <span class="comment">// if (!head) return head;</span></span><br><span class="line">        <span class="comment">// if (m==n) return head;</span></span><br><span class="line"></span><br><span class="line">        ListNode* dhead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head);</span><br><span class="line"></span><br><span class="line">        ListNode* nodeM = dhead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            nodeM = nodeM-&gt;next;</span><br><span class="line"></span><br><span class="line">        ListNode* nodeN = dhead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            nodeN = nodeN-&gt;next;</span><br><span class="line"></span><br><span class="line">        ListNode* subHead = dhead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">            subHead = subHead-&gt;next;</span><br><span class="line"></span><br><span class="line">        subHead-&gt;next = reverseList(nodeM, nodeN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>过程示意图见笔记本。</p>
<h1 id="142-判断链表是否有环，若有则返回环的起点"><a href="#142-判断链表是否有环，若有则返回环的起点" class="headerlink" title="142 判断链表是否有环，若有则返回环的起点"></a>142 判断链表是否有环，若有则返回环的起点</h1><p>思路一：在纸上<font color="red">比划比划，找规律</font>。当快慢两指针相遇时，慢指针和entry指针同时向后移动，直到两者相遇，此时两指针所指向的就是环的起点。</p>
<p>思路二：首先判断是否有环，然后快慢指针在若干步后相遇（相遇时慢指针所走的步数正好是环中的节点数）。最后让新指针从头开始，慢指针从相遇位置开始，一起移动知道两者相遇，此时的相遇结点就是环的入口。</p>
<p>两思路其实是一样的。</p>
<p>实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sol142</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">ListNode* <span class="title">entryPoint</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		ListNode* dhead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head);</span><br><span class="line">		ListNode* fast = dhead;</span><br><span class="line">		ListNode* slow = dhead;</span><br><span class="line">		ListNode* entry = dhead;</span><br><span class="line">		<span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next )&#123;</span><br><span class="line">			fast = fast-&gt;next-&gt;next;</span><br><span class="line">			slow = slow-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (slow == fast)&#123; <span class="comment">// 表示有环</span></span><br><span class="line">                <span class="comment">// slow和entry同时移动，直到两者相遇，相遇点就是</span></span><br><span class="line">                <span class="comment">// 环的起点</span></span><br><span class="line">				<span class="keyword">while</span>(slow != entry)&#123;</span><br><span class="line">					slow = slow-&gt;next;</span><br><span class="line">					entry = entry-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> entry;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="61-切断链表后再接上"><a href="#61-切断链表后再接上" class="headerlink" title="61 切断链表后再接上"></a>61 切断链表后再接上</h1><p>描述：</p>
<p>翻转链表，从右边第k个位置切断，交换两部分位置，后将两部分接上，返回新的链表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>初始化所有指针，后移到其应该在的位置，最后重新链接两部分。就是指针操作。</p>
<p>实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sol61</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//1. get the length of list</span></span><br><span class="line">		ListNode* curr = head;</span><br><span class="line">		<span class="keyword">int</span> length=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(curr-&gt;next)&#123;</span><br><span class="line">			curr = curr-&gt;next;</span><br><span class="line">			length++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 注意这里，</span></span><br><span class="line">		<span class="keyword">int</span> newK = k%length;</span><br><span class="line">		<span class="keyword">if</span> (newK == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//2. init ptrs</span></span><br><span class="line">		ListNode* dhead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>, head);</span><br><span class="line">		ListNode* end = dhead;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;newK;i++)&#123;</span><br><span class="line">			end=end-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		ListNode* pre = dhead;</span><br><span class="line">		ListNode* newHead = head;</span><br><span class="line">		<span class="keyword">while</span>(end-&gt;next)&#123;</span><br><span class="line">			end=end-&gt;next;</span><br><span class="line">			pre=pre-&gt;next;</span><br><span class="line">			newHead=newHead-&gt;next;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//3. move ptrs</span></span><br><span class="line">		pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">		end-&gt;next = head;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//4. clean up</span></span><br><span class="line">		<span class="keyword">delete</span> dhead;</span><br><span class="line">		dhead=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="328-奇数号结点链表，偶数号结点链表"><a href="#328-奇数号结点链表，偶数号结点链表" class="headerlink" title="328 奇数号结点链表，偶数号结点链表"></a>328 奇数号结点链表，偶数号结点链表</h1><p>描述：</p>
<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>思路：遍历结点，更改结点next指针，奇数结点相连，偶数结点相连，最后将偶数节点链表的头接在奇数结点链表的尾。示意图见笔记。</p>
<p>实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sol328</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">		ListNode* odd = head;</span><br><span class="line">		ListNode* oddCur = head;</span><br><span class="line">		ListNode* even = head-&gt;next;</span><br><span class="line">		ListNode* evenCur = head-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>( <span class="literal">true</span> )&#123;</span><br><span class="line">			<span class="comment">// 奇数个结点</span></span><br><span class="line">			<span class="keyword">if</span> (oddCur-&gt;next==<span class="literal">nullptr</span> &amp;&amp; evenCur==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">				oddCur-&gt;next = even;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 偶数个结点</span></span><br><span class="line">			<span class="keyword">if</span> (oddCur-&gt;next-&gt;next==<span class="literal">nullptr</span> &amp;&amp; evenCur-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">				oddCur-&gt;next = even;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">			oddCur-&gt;next = oddCur-&gt;next-&gt;next;</span><br><span class="line">			oddCur = oddCur-&gt;next;</span><br><span class="line">			</span><br><span class="line">			evenCur-&gt;next = evenCur-&gt;next-&gt;next;</span><br><span class="line">			evenCur = evenCur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> odd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度： O(N)</p>
<p>很直接的解法，但<font color="red" size="5">花了好长时间</font>: 原因 1.测试vector马虎了；2.<font color="red" size="5">多个if判断的顺序问题</font>。</p>
<p>重点在这儿，如果上述code中这两个if调换顺序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 奇数个结点</span></span><br><span class="line"><span class="keyword">if</span> (oddCur-&gt;next-&gt;next==<span class="literal">nullptr</span> &amp;&amp; evenCur-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    oddCur-&gt;next = even;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 偶数个结点</span></span><br><span class="line"><span class="keyword">if</span> (oddCur-&gt;next==<span class="literal">nullptr</span> &amp;&amp; evenCur==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    oddCur-&gt;next = even;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当结点个数为奇数个，且到链表尾时，第一个if语句中<code>oddCur-&gt;next-&gt;next==nullptr</code>就会出错，因为<code>oddCur-&gt;next-&gt;next</code>指向未定义的位置。所以总是出现<code>Segmentation fault (core dumped)</code>。！！！</p>
<p><font color="gree" size="5">注意</font>:</p>
<ol>
<li>多个if判断的顺序不是随意的。</li>
<li>如果在中间某处找不到错误，那么从头开始再找，别马虎。</li>
</ol>
<h1 id="430-扁平化一个多层链表"><a href="#430-扁平化一个多层链表" class="headerlink" title="430 扁平化一个多层链表"></a>430 扁平化一个多层链表</h1><p>描述：给出一个结点定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node* child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并构造一个多层链表，目标是将这个多层链表变为一层，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input：</span><br><span class="line"><span class="number">1</span> - <span class="number">2</span> - <span class="number">3</span> - <span class="number">4</span> - <span class="number">5</span> - null</span><br><span class="line">    |</span><br><span class="line">    <span class="number">6</span> - <span class="number">7</span> - <span class="number">8</span> - <span class="number">9</span> - null</span><br><span class="line">            |</span><br><span class="line">            <span class="number">10</span> - <span class="number">11</span> - null</span><br><span class="line">            </span><br><span class="line">output:</span><br><span class="line"><span class="number">1</span> - <span class="number">2</span> - [<span class="number">6</span> - <span class="number">7</span> - <span class="number">8</span> - [<span class="number">10</span> - <span class="number">11</span>] - <span class="number">9</span>] - <span class="number">3</span> - <span class="number">4</span> - <span class="number">5</span> - null</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>在循环的过程中改变了循环的对象，所以可以将所有深度的结点遍历到。这是由浅入深的扁平化过程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">遇到第一个含有child的结点后：</span><br><span class="line">1 - 2 - 6 - 7 - 8 - 9 - 3 - 4 - 5 - null</span><br><span class="line">                |</span><br><span class="line">                10 - 11 - null</span><br><span class="line"></span><br><span class="line">遇到第二个含有child的结点后：</span><br><span class="line">1 - 2 - 6 - 7 - 8 - 10 - 11 - 9 - 3 - 4 - 5 - null</span><br></pre></td></tr></table></figure>

<p>实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node* h = head; h; h = h-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;child)&#123;</span><br><span class="line">            Node* next = h-&gt;next;</span><br><span class="line">            h-&gt;next = h-&gt;child;</span><br><span class="line">            h-&gt;next-&gt;prev = h;</span><br><span class="line">            h-&gt;child = <span class="literal">NULL</span>;</span><br><span class="line">            Node* p = h-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next) p = p-&gt;next;</span><br><span class="line">            p-&gt;next = next;</span><br><span class="line">            <span class="keyword">if</span> (next) next-&gt;prev = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度： O(N)</p>
<p>这个思路很neat！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/23/LeetCode-%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/" data-id="ckbubwor500033wfz15y499lb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CUDA/">CUDA</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Caffe/">Caffe</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Deep-Learning/">Deep Learning</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a><span class="category-list-count">29</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linear-Algebra/">Linear Algebra</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/">Machine Learning</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Reinforcement-Learning/">Reinforcement Learning</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Utility/">Utility</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%85%E5%BD%92%E7%B1%BB/">待归类</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithms/" rel="tag">Algorithms</a><span class="tag-list-count">56</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CUDA/" rel="tag">CUDA</a><span class="tag-list-count">34</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Caffe/" rel="tag">Caffe</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test-Analysis/" rel="tag">Test Analysis</a><span class="tag-list-count">6</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithms/" style="font-size: 20px;">Algorithms</a> <a href="/tags/CUDA/" style="font-size: 16.67px;">CUDA</a> <a href="/tags/Caffe/" style="font-size: 13.33px;">Caffe</a> <a href="/tags/Test-Analysis/" style="font-size: 10px;">Test Analysis</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">31</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">38</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/01/">January 1970</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/12/LeetCode-Trie/">LeetCode-Trie</a>
          </li>
        
          <li>
            <a href="/2020/07/11/LeetCode-BST-%E6%89%BE%E5%89%8D%E9%A9%B1%E4%B8%8E%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9/">LeetCode-BST 找前驱与后继结点</a>
          </li>
        
          <li>
            <a href="/2020/07/08/CUDA-%E5%B9%B6%E8%A1%8CRadix-Sort/">CUDA-并行Radix Sort</a>
          </li>
        
          <li>
            <a href="/2020/07/02/LeetCode-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/">LeetCode-判断链表是否相交</a>
          </li>
        
          <li>
            <a href="/2020/07/01/cpp-%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98-%E6%A0%88%E5%86%85%E5%AD%98-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">cpp-静态内存-栈内存-动态内存</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Junhui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>